<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>–í–∏–∑—É–∞–ª—å–Ω—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#06b6d4;
    --accent-2:#8b5cf6;
    --card:#0b1226;
    --muted:#94a3b8;
    --white:#ffffff;
    --success:#10b981;
    --danger:#ef4444;
    --panel-width:300px;
  }
  
  /* Theme: Light mode color variables */
  [data-theme="light"] {
    --bg:#f8fafc;
    --panel:#ffffff;
    --accent:#0ea5e9;
    --accent-2:#6366f1;
    --card:#ffffff;
    --muted:#64748b;
    --white:#1e293b;
    --success:#059669;
    --danger:#dc2626;
  }
  
  [data-theme="light"] body {
    background: linear-gradient(180deg, #f1f5f9 0%, #e2e8f0 100%);
    color: var(--white);
  }
  
  [data-theme="light"] .left,
  [data-theme="light"] .right-panel {
    background: linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.01));
    box-shadow: 0 8px 30px rgba(0,0,0,0.1);
  }
  
  [data-theme="light"] .center {
    box-shadow: 0 10px 40px rgba(0,0,0,0.1);
    background: linear-gradient(180deg, rgba(0,0,0,0.01), rgba(0,0,0,0.0));
  }
  
  [data-theme="light"] .toolbar {
    border-bottom: 1px solid rgba(0,0,0,0.1);
    background: linear-gradient(180deg, rgba(0,0,0,0.02), transparent);
  }
  
  [data-theme="light"] .block {
    background: var(--card);
    box-shadow: 0 12px 30px rgba(0,0,0,0.15);
  }
  
  [data-theme="light"] .block:hover {
    box-shadow: 0 20px 60px rgba(0,0,0,0.2);
  }
  
  [data-theme="light"] .block-header {
    background: linear-gradient(90deg, rgba(0,0,0,0.05), rgba(0,0,0,0.02));
    color: var(--white);
  }
  
  [data-theme="light"] .block-content {
    background: linear-gradient(180deg, rgba(0,0,0,0.02), rgba(0,0,0,0.00));
  }
  
  [data-theme="light"] .field-input {
    background: rgba(0,0,0,0.05);
    color: var(--white);
    border: 1px solid rgba(0,0,0,0.1);
    resize: vertical;
    min-height: 32px;
    max-height: 200px;
    font-family: inherit;
    line-height: 1.4;
    overflow-y: auto;
  }
  
  
  [data-theme="light"] .category-header {
    background: linear-gradient(90deg, rgba(0,0,0,0.02), transparent);
  }
  
  [data-theme="light"] .category-header:hover {
    box-shadow: 0 6px 18px rgba(0,0,0,0.15);
  }
  
  [data-theme="light"] .block-item {
    background: linear-gradient(90deg, rgba(0,0,0,0.02), rgba(0,0,0,0.01));
    border: 1px solid rgba(0,0,0,0.1);
  }
  
  [data-theme="light"] .block-item:hover {
    box-shadow: 0 10px 30px rgba(0,0,0,0.15);
  }
  
  /* Force white text on canvas blocks in light theme for readability */
  [data-theme="light"] .block,
  [data-theme="light"] .block-header,
  [data-theme="light"] .block-content,
  [data-theme="light"] .block .small,
  [data-theme="light"] .block .block-name {
    color: #ffffff !important;
  }
  [data-theme="light"] .field-input {
    color: #ffffff !important;
  }
  
  /* Force white text in context menu (right-click) under light theme */
  [data-theme="light"] #blockContextMenu .menu-item {
    color: #ffffff !important;
  }
  
  /* Connection lines for light theme */
  [data-theme="light"] .connection-line { 
    background: linear-gradient(90deg, #0ea5e9, #6366f1) !important; 
  }
  
  /* Settings modal for light themes */
  [data-theme="light"] #settingsModal .modal > div,
  [data-theme="nebo"] #settingsModal .modal > div {
    background: rgba(0,0,0,0.03) !important;
    border: 1px solid rgba(0,0,0,0.15) !important;
  }
  [data-theme="light"] #settingsModal label,
  [data-theme="nebo"] #settingsModal label {
    background: rgba(0,0,0,0.03) !important;
  }
  [data-theme="light"] #settingsModal label:hover,
  [data-theme="nebo"] #settingsModal label:hover {
    border-color: var(--accent) !important;
  }
  [data-theme="light"] .settings-subgroup,
  [data-theme="nebo"] .settings-subgroup {
    border-color: rgba(0,0,0,0.3) !important;
  }
  
  /* Project name display and settings button for light themes */
  [data-theme="light"] #projectNameDisplay,
  [data-theme="nebo"] #projectNameDisplay {
    background: rgba(0,0,0,0.05) !important;
    border: 1px solid rgba(0,0,0,0.15) !important;
    border-radius: 8px !important;
  }
  [data-theme="light"] .btn-icon,
  [data-theme="nebo"] .btn-icon {
    border: 1px solid rgba(0,0,0,0.15) !important;
    border-radius: 6px !important;
  }
  [data-theme="light"] .btn-icon:hover,
  [data-theme="nebo"] .btn-icon:hover {
    border-color: var(--accent) !important;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; font-family:Inter, Roboto, Arial, sans-serif; background:linear-gradient(180deg,#071025 0%,#0b1220 100%); color:var(--white); -webkit-font-smoothing:antialiased}
  .app { display:flex; height:100vh; gap:16px; padding:16px; }
  .left {
    width:var(--panel-width);
    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    border-radius:12px; padding:14px; box-shadow:0 8px 30px rgba(2,6,23,0.6); overflow:auto;
  }
  .left h2 { margin:0 0 12px; font-size:18px; letter-spacing:0.2px; color:var(--white); }
  .category-header { display:flex; justify-content:space-between; align-items:center; padding:8px; cursor:pointer; border-radius:8px; margin-top:8px; transition:all .18s; background:linear-gradient(90deg, rgba(255,255,255,0.02), transparent); }
  .category-header:hover { transform:translateY(-3px); box-shadow:0 6px 18px rgba(2,6,23,0.45); }
  .category-title { font-weight:600; color:#e6eef6; }
  [data-theme="light"] .category-title { font-weight:600; color:#1e293b; }
  .collapse-indicator { opacity:0.7; font-size:12px; }
  .block-list { display:grid; gap:8px; margin-top:8px; padding-bottom:12px; }
  .block-item { display:flex; gap:8px; align-items:center; padding:10px; border-radius:10px; cursor:grab; user-select:none;
    background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border:1px solid rgba(255,255,255,0.03);
    transition:transform .12s, box-shadow .12s; }
  .block-item:hover { transform:translateY(-4px); box-shadow:0 10px 30px rgba(2,6,23,0.55); }
  .color-dot { width:14px; height:14px; border-radius:50%; box-shadow:0 2px 6px rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.12); }
  .block-name { font-size:13px; color:#e6eef6; font-weight:600; }
  [data-theme="light"] .block-name { font-size:13px; color:#1e293b; font-weight:600; }

  .center {
    flex:1; position:relative; overflow:hidden; border-radius:12px; box-shadow:0 10px 40px rgba(2,6,23,0.6);
    background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.0));
    display:flex; flex-direction:column;
  }
  .toolbar { display:flex; gap:10px; padding:12px; align-items:center; border-bottom:1px solid rgba(255,255,255,0.03); background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent); }
  .btn { background:linear-gradient(90deg,var(--accent),var(--accent-2)); color:#022; padding:8px 12px; border-radius:10px; border:none; font-weight:700; cursor:pointer; box-shadow:0 8px 24px rgba(14,165,233,0.08); transition:transform .12s; }
  .btn-icon { background:rgba(255,255,255,0.05); color:var(--white); padding:6px; border-radius:8px; border:1px solid rgba(255,255,255,0.1); cursor:pointer; transition:all 0.2s; display:flex; align-items:center; justify-content:center; }
  .btn-icon:hover { background:rgba(255,255,255,0.1); border-color:var(--accent); transform:scale(1.05); }
  .btn:hover { transform:translateY(-3px); }
  .btn-ghost { background:transparent; border:1px solid rgba(255,255,255,0.06); color:var(--white); padding:8px 10px; border-radius:10px; cursor:pointer; }
  
  /* Theme selector styles */
  .theme-selector {
    display: flex;
    align-items: center;
    background: rgba(255,255,255,0.08);
    border-radius: 12px;
    padding: 6px;
    border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
  }
  
  .theme-selector:hover {
    background: rgba(255,255,255,0.12);
    border-color: rgba(255,255,255,0.25);
    box-shadow: 0 6px 20px rgba(0,0,0,0.15);
  }
  
  #themeDropdown {
    background: transparent;
    border: none;
    color: var(--white);
    font-size: 13px;
    font-weight: 600;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
    outline: none;
    min-width: 140px;
    transition: all 0.2s ease;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 8px center;
    background-size: 16px;
    padding-right: 32px;
  }
  
  #themeDropdown:hover {
    background-color: rgba(255,255,255,0.1);
  }
  
  #themeDropdown:focus {
    background-color: rgba(255,255,255,0.15);
    box-shadow: 0 0 0 2px rgba(6,182,212,0.3);
  }
  
  #themeDropdown option {
    background: #1a1a1a;
    color: #ffffff;
    padding: 10px 12px;
    font-size: 13px;
    font-weight: 500;
  }
  
  [data-theme="light"] .theme-selector {
    background: rgba(0,0,0,0.08);
    border: 1px solid rgba(0,0,0,0.15);
  }
  
  [data-theme="light"] .theme-selector:hover {
    background: rgba(0,0,0,0.12);
    border-color: rgba(0,0,0,0.25);
  }
  
  [data-theme="light"] #themeDropdown {
    color: var(--white);
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23000000' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
  }
  
  [data-theme="light"] #themeDropdown:hover {
    background-color: rgba(0,0,0,0.1);
  }
  
  [data-theme="light"] #themeDropdown option {
    background: #ffffff;
    color: #1e293b;
  }
  
  [data-theme="halloween"] .theme-selector {
    background: rgba(255,140,0,0.1);
    border: 1px solid rgba(255,140,0,0.3);
  }
  
  [data-theme="halloween"] .theme-selector:hover {
    background: rgba(255,140,0,0.15);
    border-color: rgba(255,140,0,0.5);
  }
  
  [data-theme="halloween"] #themeDropdown {
    color: var(--white);
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23FF8C00' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
  }
  
  [data-theme="halloween"] #themeDropdown:hover {
    background-color: rgba(255,140,0,0.2);
  }
  
  [data-theme="halloween"] #themeDropdown option {
    background: #2d1b0f;
    color: #ffffff;
  }

  .workspace { position:relative; flex:1; overflow:hidden; display:flex; }
  #viewport { position:relative; flex:1; overflow:hidden; }
  #mainCanvas { position:absolute; left:0; top:0; width:16000px; height:16000px; transform:translate(0px,0px) scale(1); transition:transform .08s linear; }
  .block { position:absolute; min-width:140px; border-radius:12px; color:var(--white); background:var(--card); box-shadow: 0 12px 30px rgba(2,6,23,0.6); overflow:visible; transform-origin:left top; transition:box-shadow .12s, transform .08s; }
  .block:hover { box-shadow:0 20px 60px rgba(2,6,23,0.75); }
  .block-warning { outline: 2px solid #f59e0b; box-shadow: 0 0 0 3px rgba(245, 158, 11, 0.25), 0 14px 36px rgba(245, 158, 11, 0.25) !important; }
  .block-error { outline: 2px solid #ef4444; box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.30), 0 14px 36px rgba(239, 68, 68, 0.30) !important; }
  /* Highlight styles */
  .block-warning.highlight-outline { box-shadow: none !important; }
  .block-error.highlight-outline { box-shadow: none !important; }
  .block-warning.highlight-symbol { outline: none !important; box-shadow: none !important; }
  .block-error.highlight-symbol { outline: none !important; box-shadow: none !important; }
  .block-warning.highlight-none { outline: none !important; box-shadow: none !important; }
  .block-error.highlight-none { outline: none !important; box-shadow: none !important; }
  .block-ignored { opacity: 0.4; filter: brightness(0.5); }
  .block-ignored:hover { opacity: 0.5; filter: brightness(0.6); }
  .block-indicator { position:absolute; top:6px; right:6px; width:22px; height:22px; border-radius:50%; display:none; align-items:center; justify-content:center; font-weight:800; font-size:13px; color:#0b1220; z-index:70; box-shadow:0 6px 14px rgba(0,0,0,0.25); }
  .indicator-warning { background:#f59e0b; color:#1f2937; }
  .indicator-error { background:#ef4444; color:#fff; }
  .block-header { padding:12px; font-weight:800; letter-spacing:0.2px; font-size:14px; background:linear-gradient(90deg, rgba(0,0,0,0.18), rgba(255,255,255,0.02)); cursor:move; -webkit-user-select:none; -moz-user-select:none; user-select:none; color: var(--white); }
  .block-content { padding:10px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00)); min-height:36px; display:flex; flex-direction:column; gap:8px; }
  .field-input { 
    padding:8px; 
    border-radius:8px; 
    border:1px solid rgba(0,0,0,0.15); 
    font-size:13px; 
    background:rgba(255,255,255,0.96); 
    color:#0b1220;
    resize: vertical;
    min-height: 32px;
    max-height: 200px;
    font-family: inherit;
    line-height: 1.4;
    overflow-y: auto;
  }
  
  /* Single-line input field styles */
  .field-input.single-line {
    resize: none;
    height: 32px;
    min-height: 32px;
    max-height: 32px;
    overflow: hidden;
    white-space: nowrap;
  }
  
  /* Multi-line input field styles */
  .field-input.multi-line {
    resize: vertical;
    min-height: 32px;
    max-height: 200px;
  }
  
  /* Autocomplete styles */
  .autocomplete-container {
    position: relative;
    display: inline-block;
    width: 100%;
  }
  
  .autocomplete-dropdown {
    position: fixed;
    background: var(--card);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    z-index: 10000;
    max-height: 200px;
    overflow-y: auto;
    display: none;
    min-width: 200px;
    max-width: 300px;
  }
  
  .autocomplete-item {
    padding: 8px 12px;
    cursor: pointer;
    color: var(--white);
    border-bottom: 1px solid rgba(255,255,255,0.05);
    transition: background-color 0.2s;
  }
  
  .autocomplete-item:hover {
    background: var(--accent);
    color: #000;
  }
  
  .autocomplete-item:last-child {
    border-bottom: none;
  }
  
  .autocomplete-item.highlighted {
    background: var(--accent);
    color: #000;
  }
  
  .autocomplete-item .value-text {
    font-weight: 500;
  }
  
  .autocomplete-item .value-count {
    font-size: 11px;
    opacity: 0.7;
    margin-left: 8px;
  }

  /* Variables registry styles */
  .variables-registry { 
    margin-top: 8px; 
    display: flex; 
    flex-direction: column; 
    gap: 6px; 
    max-height: 300px; 
    overflow-y: auto; 
    padding-right: 4px;
  }
  
  /* Variables registry scrollbar styles */
  .variables-registry::-webkit-scrollbar {
    width: 6px;
  }
  
  .variables-registry::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.05);
    border-radius: 3px;
  }
  
  .variables-registry::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 3px;
  }
  
  .variables-registry::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.3);
  }
  
  /* Firefox scrollbar support */
  .variables-registry {
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.2) rgba(255, 255, 255, 0.05);
  }
  .var-row { display: flex; align-items: center; gap: 8px; padding: 6px 8px; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.06); border-radius: 8px; }
  .var-name { flex: 1; color: var(--white); font-size: 13px; }
  .var-count { color: rgba(255,255,255,0.7); font-size: 12px; }
  .tag-select { background: #000; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: #fff; font-size: 12px; padding: 4px 6px; }
  .tag-select option { background: #000; color: #fff; }
  #blockSpacing { background: rgba(255,255,255,0.05) !important; color: var(--white) !important; }
  #blockSpacing option { background: #0b1220 !important; color: #ffffff !important; }
  .tag-icon { width: 16px; height: 16px; display: inline-flex; align-items: center; justify-content: center; }
  
  /* Variable counter color by theme */
  /* Default (dark themes, hacker, mono) - white/semi-transparent already set */
  [data-theme="light"] .var-count,
  [data-theme="nebo"] .var-count { color: #000 !important; }

  /* Error warning modal styles */
  .error-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
  }

  .error-modal-backdrop {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .error-modal-content {
    position: relative;
    background: var(--card);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 16px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    max-width: 500px;
    width: 100%;
    max-height: 80vh;
    overflow: hidden;
    animation: errorModalSlideIn 0.3s ease-out;
    margin: auto;
    /* Ensure content is centered inside the backdrop on all sizes */
    display: flex;
    flex-direction: column;
    justify-content: center;
  }

  @keyframes errorModalSlideIn {
    from {
      opacity: 0;
      transform: scale(0.9) translateY(-20px);
    }
    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  .error-modal-header {
    padding: 24px 24px 16px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }

  .error-modal-header h3 {
    margin: 0;
    color: #ef4444;
    font-size: 20px;
    font-weight: 700;
  }

  .error-modal-body {
    padding: 20px 24px;
    line-height: 1.6;
    color: var(--white);
  }

  .error-modal-body p {
    margin: 0 0 12px;
  }

  .error-modal-body p:last-child {
    margin-bottom: 0;
  }

  .issues-summary {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
    padding: 16px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .issue-count {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 16px;
  }

  .issue-icon {
    font-size: 20px;
  }

  .issue-text {
    color: var(--white);
  }

  .error-count {
    color: #ef4444;
  }

  .warning-count {
    color: #f59e0b;
  }

  .error-modal-footer {
    padding: 16px 24px 24px;
    display: flex;
    gap: 12px;
    justify-content: flex-end;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
  }

  .btn-danger {
    background: #ef4444 !important;
    color: white !important;
    border: none !important;
    opacity: 0.5;
    cursor: not-allowed;
    transition: all 0.3s ease;
  }

  .btn-danger:not(:disabled) {
    opacity: 1;
    cursor: pointer;
  }

  .btn-danger:not(:disabled):hover {
    background: #dc2626 !important;
    transform: translateY(-2px);
  }

  /* Disable text selection for utility elements */
  .connector, .connection-line, .connection-point { -webkit-user-select:none; -moz-user-select:none; user-select:none; }
  .temp-line { pointer-events:none; }

  .connector { position:absolute; width:20px; height:20px; border-radius:50%; background:#fff; border:2px solid rgba(0,0,0,0.5); z-index:60; transition: all 0.2s ease; }
  .connector.connector-valid { background: #00ff00; border-color: #00aa00; box-shadow: 0 0 10px rgba(0,255,0,0.5); }
  .connector.connector-invalid { opacity: 0.3; filter: brightness(0.5); }
  .connector-top{ top:-10px; left:50%; transform:translateX(-50%); }
  .connector-bottom{ bottom:-10px; left:50%; transform:translateX(-50%); }
  .connector-right{ top:50%; right:-10px; transform:translateY(-50%); }
  .connector-left{ top:50%; left:-10px; transform:translateY(-50%); }
  /* Horizontal flowchart connectors */
  .flowchart-horizontal .connector-top{ display:none; }
  .flowchart-horizontal .connector-bottom{ display:none; }
  .flowchart-horizontal .connector-left{ display:block; top:50%; left:-10px; transform:translateY(-50%); }
  .flowchart-horizontal .connector-right{ top:50%; right:-10px; transform:translateY(-50%); }
  .flowchart-horizontal .connector-right-top{ top:30%; right:-10px; transform:translateY(-50%); }
  .flowchart-horizontal .connector-right-bottom{ bottom:30%; right:-10px; transform:translateY(50%); }
  .connector.connector-collapsed {
    background:#adff2f;
    border-color:#73c21f;
    box-shadow:0 0 12px rgba(173,255,47,0.6);
    cursor:not-allowed;
  }

  /* Connector tooltip styles */
  .connector-tooltip {
    position: fixed;
    background: #000;
    color: #ffd700;
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 600;
    white-space: nowrap;
    z-index: 100;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    transform: translate(-50%, -100%);
  }
  .connector-tooltip.show {
    opacity: 1;
  }
  .connector-tooltip-bottom {
    transform: translate(-50%, 0);
  }
  .connector-tooltip-right {
    transform: translate(0, -50%);
  }
  .connector-tooltip-left {
    transform: translate(-100%, -50%);
  }
  .connector-tooltip-right-top {
    transform: translate(0, -50%);
  }
  .connector-tooltip-right-bottom {
    transform: translate(0, -50%);
  }

  /* Input field tooltip styles */
  .field-tooltip {
    position: fixed;
    background: #000;
    color: #ffd700;
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 600;
    white-space: nowrap;
    z-index: 100;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    transform: translate(-50%, -100%);
  }
  .field-tooltip.show {
    opacity: 1;
  }

  .connection-line{ position:absolute; height:4px; background:linear-gradient(90deg,var(--accent),var(--accent-2)); transform-origin:0 50%; z-index:40; border-radius:6px; box-shadow:0 6px 16px rgba(11,20,40,0.3); }
  .connection-line.preview-connection{ background:transparent; border-top:2px dashed rgba(6,182,212,0.6); box-shadow:none; }
  .connection-svg{ position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:40; }
  .connection-svg path{ transition:stroke 0.2s ease; }
  .connection-point{ position:absolute; width:12px; height:12px; border-radius:50%; background:var(--success); z-index:45; box-shadow:0 6px 16px rgba(16,185,129,0.12); cursor:context-menu; }
  .connection-point-tooltip { position: fixed; background: rgba(0,0,0,0.85); color: #fff; padding:6px 8px; border-radius:6px; font-size:12px; z-index:30000; pointer-events:none; opacity:0; transition: opacity 0.12s ease; transform: translate(-50%, -120%); white-space:nowrap; }
  .connection-point-tooltip.show { opacity:1; }
  .block-connection-tooltip { position: fixed; background: rgba(3,7,18,0.9); color:#fff; padding:10px 12px; border-radius:10px; font-size:12px; line-height:1.5; max-width:260px; box-shadow:0 10px 30px rgba(0,0,0,0.4); pointer-events:none; opacity:0; transform:translate(-50%, -110%); transition: opacity 0.15s ease, transform 0.15s ease; z-index:30000; }
  .block-connection-tooltip.show { opacity:1; transform:translate(-50%, -120%); }

  /* Connection line colors */
  .connection-line.color-system { 
    background: linear-gradient(90deg, var(--accent), var(--accent-2)); 
  }
  .connection-line.color-orange { 
    background: linear-gradient(90deg, #ff8c00, #ffa500); 
  }
  .connection-line.color-red { 
    background: linear-gradient(90deg, #ff4444, #ff6666); 
  }
  .connection-line.color-green { 
    background: linear-gradient(90deg, #00ff88, #44ffaa); 
  }
  .connection-line.color-purple { 
    background: linear-gradient(90deg, #8b5cf6, #a78bfa); 
  }


  /* Connection context menu styles */
  .connection-context-menu {
    position: absolute;
    z-index: 10000;
    background: var(--panel);
    border: 1px solid var(--accent-2);
    border-radius: 8px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    color: var(--white);
    padding: 8px 0;
    display: none;
    min-width: 200px;
  }
  
  .connection-context-menu .menu-section {
    padding: 4px 0;
    border-bottom: 1px solid rgba(255,255,255,0.1);
  }
  
  .connection-context-menu .menu-section:last-child {
    border-bottom: none;
  }
  
  .connection-context-menu .menu-section-title {
    padding: 6px 12px;
    font-size: 12px;
    font-weight: 600;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .connection-context-menu .menu-item {
    padding: 8px 12px;
    cursor: pointer;
    user-select: none;
    color: var(--white);
    display: flex;
    align-items: center;
    gap: 8px;
    transition: background-color 0.2s;
  }
  
  .connection-context-menu .menu-item:hover {
    background: var(--accent);
    color: #000;
  }
  
  .connection-context-menu .menu-item .color-preview {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 1px solid rgba(255,255,255,0.3);
  }

  .right-panel { width:300px; background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent); border-radius:12px; padding:12px; box-shadow:0 8px 40px rgba(2,6,23,0.6); display:flex; flex-direction:column; }
  .panel-title { font-weight:800; margin-bottom:10px }
  .small { font-size:13px; color:var(--muted) }
  .mods-section { 
    margin-top:auto; 
    margin-bottom: 40px; /* –û—Ç—Å—Ç—É–ø —Å–Ω–∏–∑—É —á—Ç–æ–±—ã –Ω–µ –Ω–∞–µ–∑–∂–∞–ª–∞ –ø–ª–∞—à–∫–∞ licensed */
  }
  .mods-panel {
    overflow-x: hidden;
    padding-right: 4px;
  }
  .mods-panel.scrollable {
    max-height: calc(3 * 40px); /* –í—ã—Å–æ—Ç–∞ –¥–ª—è 3 —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø—Ä–∏–º–µ—Ä–Ω–æ */
    overflow-y: auto;
  }
  .mods-panel::-webkit-scrollbar {
    width: 6px;
  }
  .mods-panel::-webkit-scrollbar-track {
    background: rgba(255,255,255,0.05);
    border-radius: 3px;
  }
  .mods-panel::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.2);
    border-radius: 3px;
  }
  .mods-panel::-webkit-scrollbar-thumb:hover {
    background: rgba(255,255,255,0.3);
  }
  
  /* Panel tabs styles */
  .panel-tabs {
    display: flex;
    margin-bottom: 12px;
    background: rgba(255,255,255,0.03);
    border-radius: 8px;
    padding: 4px;
  }
  
  .tab-button {
    flex: 1;
    padding: 8px 12px;
    border: none;
    background: transparent;
    color: var(--muted);
    border-radius: 6px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    transition: all 0.2s;
  }
  
  .tab-button.active {
    background: var(--accent);
    color: white;
    box-shadow: 0 2px 8px rgba(14,165,233,0.3);
  }
  
  .tab-button:hover:not(.active) {
    background: rgba(255,255,255,0.1);
    color: var(--white);
  }
  
  .tab-content {
    display: none;
  }
  
  .tab-content.active {
    display: block;
  }
  
  
  
  /* Custom dialog modal styles */
  .custom-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
  }
  
  .custom-modal-content {
    background: var(--card);
    border-radius: 16px;
    padding: 24px;
    min-width: 400px;
    max-width: 600px;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.1);
  }
  
  .custom-modal-header {
    font-size: 20px;
    font-weight: 700;
    margin-bottom: 16px;
    color: var(--white);
  }
  
  .custom-modal-body {
    margin-bottom: 20px;
  }
  
  .custom-modal-footer {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
  }
  
  .custom-input {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.05);
    color: var(--white);
    font-size: 14px;
    margin-bottom: 12px;
  }
  
  .custom-input:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(6,182,212,0.1);
  }
  
  .custom-input::placeholder {
    color: var(--muted);
  }
  
  /* Notification styles */
  .notification {
    position: fixed;
    top: 20px;
    right: 20px;
    background: var(--card);
    border-radius: 12px;
    padding: 16px 20px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.1);
    z-index: 10001;
    min-width: 300px;
    max-width: 400px;
    transform: translateX(100%);
    transition: transform 0.3s ease;
  }
  
  .notification.show {
    transform: translateX(0);
  }
  
  .notification.success {
    border-left: 4px solid var(--success);
  }
  
  .notification.error {
    border-left: 4px solid var(--danger);
  }
  
  .notification-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 8px;
  }
  
  .notification-icon {
    font-size: 20px;
  }
  
  .notification-title {
    font-weight: 600;
    color: var(--white);
    font-size: 16px;
  }
  
  .notification-message {
    color: var(--muted);
    font-size: 14px;
    line-height: 1.4;
  }
  
  .notification-close {
    position: absolute;
    top: 8px;
    right: 8px;
    background: none;
    border: none;
    color: var(--muted);
    cursor: pointer;
    font-size: 18px;
    padding: 4px;
    border-radius: 4px;
    transition: all 0.2s;
  }
  
  .notification-close:hover {
    background: rgba(255,255,255,0.1);
    color: var(--white);
  }
  

  /* Issues/warnings module styles */
  .issues-container { margin-top:12px; max-height:320px; overflow:auto; padding-right:6px; }
  .issue {
    display:flex; gap:8px; align-items:flex-start; padding:10px; border-radius:8px; margin-bottom:8px;
    font-size:13px; line-height:1.2;
  }
  .issue .icon {
    min-width:20px; min-height:20px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:800;
    flex-shrink:0;
  }
  .issue.warning { background: rgba(74, 63, 12, 0.12); color: #5a4e07; transition: all 0.2s ease; }
  .issue.warning:hover { background: rgba(74, 63, 12, 0.2); transform: translateY(-1px); }
  .issue.warning .icon { background: #4f3700; color: #ffd54a; width:26px; height:26px; border-radius:4px; display:flex; align-items:center; justify-content:center; }
  .issue.error { background: rgba(139, 0, 0, 0.08); color: #7a1515; transition: all 0.2s ease; }
  .issue.error:hover { background: rgba(139, 0, 0, 0.15); transform: translateY(-1px); }
  .issue.error .icon { background: #7a1515; color: #ffccd5; width:26px; height:26px; border-radius:50%; display:flex; align-items:center; justify-content:center; }
  /* Deemphasized (non-selected) issues when selection is active */
  .issue.deemphasized { opacity: 0.45; filter: grayscale(40%); }

  /* Help tour system styles */
  .help-tour-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    z-index: 99999;
    pointer-events: none;
  }

  .help-tour-spotlight {
    position: absolute;
    border: 3px solid var(--accent);
    border-radius: 12px;
    background: transparent;
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.7), 0 0 30px rgba(6, 182, 212, 0.8);
    pointer-events: none;
    transition: all 0.3s ease;
    z-index: 99999;
  }

  .help-tour-tooltip {
    position: absolute;
    background: var(--card);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.1);
    max-width: 350px;
    z-index: 99999;
    pointer-events: auto;
    animation: helpTooltipAppear 0.3s ease;
  }

  @keyframes helpTooltipAppear {
    from {
      opacity: 0;
      transform: scale(0.9) translateY(10px);
    }
    to {
      opacity: 1;
      transform: scale(1) translateY(0);
    }
  }

  .help-tour-tooltip h3 {
    margin: 0 0 12px 0;
    font-size: 18px;
    font-weight: 700;
    color: var(--white);
  }

  .help-tour-tooltip p {
    margin: 0 0 16px 0;
    font-size: 14px;
    line-height: 1.5;
    color: var(--muted);
  }

  .help-tour-tooltip .help-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
  }

  .help-tour-tooltip .btn {
    padding: 8px 16px;
    font-size: 13px;
  }

  .help-tour-tooltip .btn-ghost {
    padding: 8px 16px;
    font-size: 13px;
  }

  .help-tour-progress {
    position: absolute;
    bottom: 12px;
    left: 20px;
    font-size: 12px;
    color: var(--muted);
    font-weight: 600;
  }

  /* Highlight effect for tour elements */
  .help-tour-highlighted {
    position: relative;
    z-index: 99999 !important;
    transform: scale(1.02);
    transition: all 0.3s ease;
    filter: brightness(1.1) contrast(1.1);
    box-shadow: 0 0 20px rgba(6, 182, 212, 0.4);
  }

  @media (max-width:1100px){ .left{display:none} .right-panel{display:none} }

/* Additional themes and context menu styles */

/* Context menu base styles */
.context-menu {
  position: absolute;
  z-index: 9999;
  background: var(--panel);
  border: 1px solid var(--accent-2);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.2);
  color: #ffffff;
  padding: 4px 0;
  display: none;
}
.context-menu-item {
  padding: 6px 12px;
  cursor: pointer;
  user-select: none;
  color: #ffffff;
}
.context-menu-item:hover {
  background: var(--accent);
  color: #000;
}

/* Theme: Hacker */
[data-theme="hacker"] {
  --bg: #000000;
  --panel: #000000;
  --accent: #7CFC00;
  --accent-2: #3a7f00;
  --card: #000000;
  --muted: #9ae89a;
  --white: #e6ffe6;
}
[data-theme="hacker"] body { background: #000; color: var(--white); }
[data-theme="hacker"] .block,
[data-theme="hacker"] .block-header,
[data-theme="hacker"] .block-content,
[data-theme="hacker"] .block-item {
  background: #000 !important;
  color: #7CFC00 !important;
  border: 1px solid #7CFC00 !important;
}
[data-theme="hacker"] .color-dot { background: #7CFC00 !important; }
[data-theme="hacker"] .connection-line { background: linear-gradient(90deg, #7CFC00, #3a7f00) !important; }
[data-theme="hacker"] .theme-option.active { background: #7CFC00; color: #000; }
[data-theme="hacker"] .context-menu { background: #000; color: #ffffff; border-color: #3a7f00; }
[data-theme="hacker"] .context-menu-item { color: #ffffff; }
[data-theme="hacker"] .context-menu-item:hover { background: #7CFC00; color: #000; }

/* Theme: Sky */
[data-theme="nebo"] {
  --bg: #f8ffff;
  --panel: #ffffff;
  --accent: #40E0D0;
  --accent-2: #a7f1ec;
  --card: #ffffff;
  --muted: #6b94a1;
  --white: #003333;
}
[data-theme="nebo"] body {
  background: linear-gradient(180deg, #f9feff 0%, #eefcff 100%);
  color: var(--white);
}
[data-theme="nebo"] .block,
[data-theme="nebo"] .block-header,
[data-theme="nebo"] .block-content,
[data-theme="nebo"] .block-item {
  background: #ffffff !important;
  color: #003333 !important;
  border-color: rgba(64,224,208,0.15) !important;
}
[data-theme="nebo"] .block-group-title,
[data-theme="nebo"] .block-category-title,
[data-theme="nebo"] .block-name {
  color: #000000 !important;
}
[data-theme="nebo"] .category-title {
  color: #000000 !important;
}
[data-theme="nebo"] .color-dot { background: #40E0D0 !important; }
[data-theme="nebo"] .connection-line { background: linear-gradient(90deg, #40E0D0, #a7f1ec) !important; }
[data-theme="nebo"] .theme-option.active { background: #40E0D0; color: #003; }
[data-theme="nebo"] .context-menu { background: #fff; color: #ffffff; border-color: #40E0D0; }
[data-theme="nebo"] .context-menu-item { color: #ffffff; }
[data-theme="nebo"] .context-menu-item:hover { background: #40E0D0; color: #000; }

/* Theme: Monochrome */
[data-theme="mono"] {
  --bg: #0f0f0f;
  --panel: #111111;
  --accent: #ffffff;
  --accent-2: #bfbfbf;
  --card: #0b0b0b;
  --muted: #9a9a9a;
  --white: #ffffff;
}
[data-theme="mono"] body { background: #0b0b0b; color: var(--white); }
[data-theme="mono"] .block,
[data-theme="mono"] .block-header,
[data-theme="mono"] .block-content,
[data-theme="mono"] .block-item {
  background: #111 !important;
  color: #fff !important;
  border: 1px solid #ffffff !important;
}
[data-theme="mono"] .color-dot { background: #fff !important; }
[data-theme="mono"] .connection-line { background: linear-gradient(90deg, #ffffff, #bfbfbf) !important; }
[data-theme="mono"] .theme-option.active { background: #fff; color: #000; }
[data-theme="mono"] .context-menu { background: #111; color: #ffffff; border-color: #bfbfbf; }
[data-theme="mono"] .context-menu-item { color: #ffffff; }
[data-theme="mono"] .context-menu-item:hover { background: #fff; color: #000; }

/* Theme: Halloween */
[data-theme="halloween"] {
  --bg: #1a0f0a;
  --panel: #2d1b0f;
  --accent: #FF8C00;
  --accent-2: #ff6b00;
  --card: #1a0f0a;
  --muted: #cc8c66;
  --white: #ffffff;
}
[data-theme="halloween"] body { background: #1a0f0a; color: var(--white); }
[data-theme="halloween"] .block,
[data-theme="halloween"] .block-header,
[data-theme="halloween"] .block-content,
[data-theme="halloween"] .block-item {
  background: #2d1b0f !important;
  color: #fff !important;
  border: 1px solid #FF8C00 !important;
}
[data-theme="halloween"] .color-dot { background: #FF8C00 !important; }
[data-theme="halloween"] .connection-line { background: linear-gradient(90deg, #FF8C00, #ff6b00) !important; }
[data-theme="halloween"] .context-menu { background: #2d1b0f; color: #ffffff; border-color: #FF8C00; }
[data-theme="halloween"] .context-menu-item { color: #ffffff; }
[data-theme="halloween"] .context-menu-item:hover { background: #FF8C00; color: #000; }

/* Theme: Pink-Violet */
[data-theme="pinkviolet"] {
  --bg: #2a133d;
  --panel: #3b2562;
  --accent: #ff91e9;
  --accent-2: #ad5fff;
  --card: #41275a;
  --muted: #c97ad9;
  --white: #fff1fa;
}
[data-theme="pinkviolet"] body { background: linear-gradient(180deg, #2a133d 0%, #41275a 100%); color: var(--white); }
[data-theme="pinkviolet"] .block,
[data-theme="pinkviolet"] .block-header,
[data-theme="pinkviolet"] .block-content,
[data-theme="pinkviolet"] .block-item {
  background: #3b2562 !important;
  color: #fff1fa !important;
  border: 1px solid #ad5fff !important;
}
[data-theme="pinkviolet"] .color-dot { background: #ff91e9 !important; }
[data-theme="pinkviolet"] .connection-line { background: linear-gradient(90deg, #ff91e9, #ad5fff) !important; }
[data-theme="pinkviolet"] .theme-option.active { background: #ff91e9; color: #2a133d; }
[data-theme="pinkviolet"] .context-menu { background: #3b2562; color: #fff1fa; border-color: #ad5fff; }
[data-theme="pinkviolet"] .context-menu-item { color: #fff1fa; }
[data-theme="pinkviolet"] .context-menu-item:hover { background: #ff91e9; color: #2a133d; }

/* Theme: Red */
[data-theme="red"] {
  --bg: #0f0f0f;
  --panel: #111111;
  --accent: #ff2121;
  --accent-2: #ee5959;
  --card: #0b0b0b;
  --muted: #ee5959;
  --white: #ff2121;
}
[data-theme="red"] body { background: #0b0b0b; color: var(--white); }
[data-theme="red"] .block,
[data-theme="red"] .block-header,
[data-theme="red"] .block-content,
[data-theme="red"] .block-item {
  background: #111 !important;
  color: #ff2121 !important;
  border: 1px solid #ff2121 !important;
}
[data-theme="red"] .color-dot { background: #ff2121 !important; }
[data-theme="red"] .connection-line { background: linear-gradient(90deg, #ff2121, #ee5959) !important; }
[data-theme="red"] .theme-option.active { background: #ff2121; color: #111; }
[data-theme="red"] .context-menu { background: #111; color: #ff2121; border-color: #ff2121; }
[data-theme="red"] .context-menu-item { color: #ff2121; }
[data-theme="red"] .context-menu-item:hover { background: #ff2121; color: #000; }


/* Fixed themes and context menu */

/* Context menu with white text for all themes */
.context-menu {
  position: absolute;
  z-index: 9999;
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.15);
  color: #ffffff;
  padding: 4px 0;
  display: none;
}
.context-menu-item {
  padding: 6px 12px;
  cursor: pointer;
  user-select: none;
  color: #ffffff;
}
.context-menu-item:hover {
  background: #f0f0f0;
  color: #000;
}

/* Rounded block styles */
.block,
.block-header,
.block-content,
.block-item {
  border-radius: 10px !important;
}

/* Theme: Hacker block styles */
[data-theme="hacker"] .block,
[data-theme="hacker"] .block-header,
[data-theme="hacker"] .block-content,
[data-theme="hacker"] .block-item {
  border-radius: 10px !important;
  border: 1px solid #7CFC00 !important;
}

/* Theme: Sky block styles */
[data-theme="nebo"] .block,
[data-theme="nebo"] .block-header,
[data-theme="nebo"] .block-content,
[data-theme="nebo"] .block-item {
  border-radius: 10px !important;
}
[data-theme="nebo"] .block-group-title,
[data-theme="nebo"] .block-category-title,
[data-theme="nebo"] .block-name {
  color: #000000 !important;
}
[data-theme="nebo"] .category-title {
  color: #000000 !important;
}

/* Theme: Monochrome block styles */
[data-theme="mono"] .block,
[data-theme="mono"] .block-header,
[data-theme="mono"] .block-content,
[data-theme="mono"] .block-item {
  border-radius: 10px !important;
  border: 1px solid #ffffff !important;
}

/* ===== Themed basic modal (shared) ===== */
.modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.55); backdrop-filter: blur(2px); display:flex; align-items:center; justify-content:center; z-index:10050; }
.modal { background: var(--card); color: var(--white); border-radius: 14px; border: 1px solid rgba(255,255,255,0.08); box-shadow: 0 20px 60px rgba(2,6,23,0.6); padding: 20px; width: min(560px, 92vw); }
[data-theme="light"] .modal { border: 1px solid rgba(0,0,0,0.08); }
.modal h3 { margin: 0 0 10px 0; font-size: 18px; font-weight: 800; }
.modal .input { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); background: transparent; color: var(--white); outline: none; }
[data-theme="light"] .modal .input { border: 1px solid rgba(0,0,0,0.12); color: var(--white); }

body {
    font-family: monospace !important;
    font-size: 18px !important;
}
button, .button, input[type=button], input[type=submit] {
    font-family: monospace !important;
    font-size: 16px !important;
}

/* License agreement styles */
.license-scroll {
  max-height: 420px;
  overflow-y: auto;
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 12px;
  padding: 16px;
  background: rgba(0,0,0,0.25);
  margin-bottom: 16px;
  box-shadow: inset 0 0 12px rgba(0,0,0,0.25);
}

.license-text {
  white-space: pre-wrap;
  font-family: Consolas, 'Courier New', monospace;
  font-size: 14px;
  line-height: 1.6;
  color: var(--white);
}

.license-hint {
  font-size: 13px;
  color: var(--muted);
  margin-bottom: 12px;
}

#acceptLicenseBtn {
  min-width: 140px;
}

#acceptLicenseBtn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  box-shadow: none;
}

  /* License badge */
  .license-badge {
    position: fixed;
    bottom: 16px;
    right: 16px;
    z-index: 10060;
    font-size: 12px;
    font-weight: 700;
    color: var(--white);
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.12);
    padding: 6px 10px;
    border-radius: 10px;
    backdrop-filter: blur(2px);
    user-select: none;
    pointer-events: none;
  }

  /* Selection area */
  .selection-area {
    position: absolute;
    border: 2px dashed;
    background: rgba(255, 255, 255, 0.05);
    pointer-events: none;
    z-index: 1000;
    border-radius: 8px;
  }

  .selection-area.has-issues {
    border-color: #d4a017;
  }

  .selection-area.no-issues {
    border-color: #10b981;
  }

  /* Small summary box shown in bottom-right of selection area */
  .selection-summary {
    position: absolute;
    right: 8px;
    bottom: 8px;
    background: #000; /* always black */
    color: var(--white);
    border: 1px solid rgba(255,255,255,0.06);
    padding: 6px 8px;
    border-radius: 8px;
    display: none;
    gap: 8px;
    align-items: center;
    z-index: 1010;
    box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    font-size: 12px;
    min-width: 120px;
    justify-content: flex-end;
  }
  .selection-summary-item { display:flex; align-items:center; gap:6px; margin-left:6px; }
  .selection-summary .mini-icon { width:18px; height:18px; display:flex; align-items:center; justify-content:center; font-size:11px; border-radius:4px; }
  .selection-summary .mini-text { font-size:11px; color:var(--muted); }
  .selection-summary .mini-warning { background:#4f3700; color:#ffd54a; width:14px; height:14px; display:inline-flex; align-items:center; justify-content:center; border-radius:3px; font-weight:700; }
  .selection-summary .mini-error { background:#7a1515; color:#ffccd5; width:14px; height:14px; display:inline-flex; align-items:center; justify-content:center; border-radius:50%; font-weight:700; }
  .selection-summary .mini-ignored { background:#16a34a; color:#ffffff; width:14px; height:14px; display:inline-flex; align-items:center; justify-content:center; border-radius:999px; font-weight:700; }

  /* Selected blocks */
  .block-selected {
    outline: 2px solid rgba(14, 165, 233, 0.8);
    outline-offset: 2px;
  }
</style>
</head>
<body>
  <div class="app">

    <!-- Left palette -->
    <div class="left">
      <h2>–ü–∞–ª–∏—Ç—Ä–∞ –±–ª–æ–∫–æ–≤</h2>
      <div id="categoriesList"></div>

      <div style="height:8px"></div>
      <div style="display:flex; gap:8px;">
        <button class="btn" onclick="openExportModal()">‚¨á –≠–∫—Å–ø–æ—Ä—Ç (.turtcd)</button>
        <button class="btn" onclick="saveProject()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
      </div>
      
      <div style="height:8px"></div>
      <button class="btn-ghost" onclick="openClearModal()" style="width:100%; color:var(--danger); border-color:var(--danger);">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª–µ</button>

      <div style="height:12px"></div>
      <input id="importFile" type="file" accept=".turtcd,application/json" style="display:none" onchange="importFromFile(event)"/>
      <button class="btn-ghost" onclick="document.getElementById('importFile').click()">‚¨Ü –ò–º–ø–æ—Ä—Ç (.turtcd)</button>

      <div style="height:12px"></div>
      <div class="small">–ü–æ–¥—Å–∫–∞–∑–∫–∏: –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π –±–ª–æ–∫–∏ –∏–∑ –ø–∞–ª–∏—Ç—Ä—ã –Ω–∞ –ø–æ–ª–µ. Ctrl + –õ–ö–ú ‚Äî –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã. –ü–ö–ú –Ω–∞ –±–ª–æ–∫ ‚Äî –º–µ–Ω—é.</div>
    </div>

    <!-- Center area -->
    <div class="center">
      <div class="toolbar">
        <button class="btn" onclick="compileProject()">‚ñ∂ –°–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å</button>
        <button class="btn-ghost" onclick="goToProjectSelection()">üè† –ú–µ–Ω—é</button>
        <button class="btn-ghost" onclick="startHelpTour()">‚ùì –ü–æ–º–æ—â—å</button>
        <div id="saveStatusIndicator" style="margin-left:8px; padding:6px 12px; background:rgba(255,255,255,0.05); border-radius:8px; border:1px solid rgba(34,197,94,0.3); color:#22c55e; font-size:13px; font-weight:500; display:flex; align-items:center; gap:6px;">
          <span>‚úì</span>
          <span>–ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã</span>
        </div>
        <div style="flex:1"></div>
        <div class="theme-selector">
          <select id="themeDropdown" onchange="setTheme(this.value)">
            <option value="dark">üåô –¢—ë–º–Ω–∞—è</option>
            <option value="light">‚òÄÔ∏è –°–≤–µ—Ç–ª–∞—è</option>
            <option value="hacker">üñ•Ô∏è –•–∞–∫–µ—Ä</option>
            <option value="nebo">‚òÅÔ∏è –ù–µ–±–æ</option>
            <option value="mono">‚¨õ –ú–æ–Ω–æ</option>
            <option value="halloween">üéÉ –•—ç–ª–ª–æ—É–∏–Ω</option>
            <option value="pinkviolet">üå∏ –†–æ–∑–æ–≤–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤–∞—è</option>
            <option value="red">üî¥ –ö—Ä–∞—Å–Ω–∞—è</option>
          </select>
        </div>
      </div>

      <div class="workspace" id="workspace">
        <div id="viewport" style="flex:1; position:relative; overflow:hidden">
          <div id="mainCanvas"></div>
        </div>
      </div>
    </div>

    <!-- Right info panel -->
    <div class="right-panel">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px; gap:8px;">
        <div id="projectNameDisplay" class="panel-title" style="margin:0; padding:8px 12px; background:rgba(255,255,255,0.05); border-radius:8px; border:1px solid rgba(255,255,255,0.1); flex:1;">–ü—Ä–æ–µ–∫—Ç</div>
        <button id="revertChangesBtn" class="btn-icon" onclick="revertChanges()" title="–û—Ç–∫–∞—Ç–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è" style="width:32px; height:32px; padding:0; display:flex; align-items:center; justify-content:center; font-size:18px; opacity:0.5; cursor:not-allowed;" disabled>
          ‚Ü∂
        </button>
        <button class="btn-icon" onclick="openSettingsModal()" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏" style="width:32px; height:32px; padding:0; display:flex; align-items:center; justify-content:center; font-size:18px;">
          ‚öôÔ∏è
        </button>
      </div>
      <div><strong>–ë–ª–æ–∫–∏:</strong> <span id="blocksCount">0</span></div>
      <div><strong>–°–≤—è–∑–∏:</strong> <span id="connsCount">0</span></div>
      <div style="height:12px"></div>
      <div class="small">–ò—Å–ø–æ–ª—å–∑—É–π ¬´–°–æ—Ö—Ä–∞–Ω–∏—Ç—å¬ª –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ, ¬´–≠–∫—Å–ø–æ—Ä—Ç¬ª ‚Äî —Å–∫–∞—á–∞—Ç—å –ª–æ–∫–∞–ª—å–Ω–æ .turtcd</div>

      <div style="height:8px"></div>
      <button id="toggleGlobalIgnoreBtn" class="btn" onclick="toggleGlobalIgnore()">–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –æ—à–∏–±–∫–∏</button>

      <div style="height:8px"></div>
      <button id="openRgbPickerBtn" class="btn-ghost" onclick="openRgbPickerModal()" style="width:100%;">üé® RGB</button>

      <div style="height:8px"></div>
      

      <!-- Issues and warnings panel -->
      <div id="issuesPanel" class="issues-container" aria-live="polite"></div>

      <!-- Variables registry -->
      <div style="height:16px"></div>
      <div class="panel-title">–†–µ–µ—Å—Ç—Ä –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö</div>
      <div id="variableRegistry" class="variables-registry"></div>

      <div class="mods-section">
        <div style="height:16px"></div>
        <div style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:8px;">
          <div class="panel-title" style="margin:0;">–ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏</div>
          <div style="display:flex; gap:6px;">
            <button type="button" title="–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏" onclick="enableAllMods()" style="width:26px; height:26px; border:2px solid #22c55e; background:transparent; color:#22c55e; border-radius:6px; font-weight:700; padding:0;">A</button>
            <button type="button" title="–û—Å—Ç–∞–≤–∏—Ç—å —Ç–æ–ª—å–∫–æ –æ—Å–Ω–æ–≤–Ω—É—é –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—é" onclick="disableAllNonCoreMods()" style="width:26px; height:26px; border:2px solid #9ca3af; background:transparent; color:#9ca3af; border-radius:6px; font-weight:700; padding:0;">O</button>
          </div>
        </div>
        <div id="modsPanel" class="mods-panel small"></div>
      </div>
    </div>
  </div>

  <!-- Context menu for blocks -->
  <div id="blockContextMenu" style="position:absolute; display:none; z-index:20000;">
    <div style="background:#071025; padding:8px; border-radius:8px; box-shadow:0 8px 28px rgba(2,6,23,0.6); min-width:160px;">
      <div id="blockPathInfo" class="menu-item" style="padding:8px; cursor:default; color:rgba(255,255,255,0.8); border-bottom:1px solid rgba(255,255,255,0.08); margin-bottom:4px; display:none;">
        
      </div>
      <div id="lockMenuItem" class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff;" onclick="toggleLockForContextBlock()">üîí –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –±–ª–æ–∫</div>
      <div id="collapseBranchMenuItem" class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff; display:none;" onclick="toggleContextBlockRightBranch()">‚ûñ –°–≤–µ—Ä–Ω—É—Ç—å –≤–µ—Ç–∫—É</div>
      <div class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff;" onclick="duplicateContextBlock()">üìÑ –î—É–±–ª–∏—Ä–æ–≤–∞—Ç—å</div>
      <div class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff;" onclick="toggleFieldInputType()">üîÑ –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ç–∏–ø –ø–æ–ª–µ–π</div>
      <div class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff;" onclick="clearContextBlock()">üßπ –û—á–∏—Å—Ç–∏—Ç—å –±–ª–æ–∫</div>
      <div id="ignoreBlockMenuItem" class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff; display:none;" onclick="toggleIgnoreBlock()">üö´ –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å</div>
      <div id="ignoreIssueMenuItem" class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff;" onclick="toggleIgnoreIssuesForContextBlock()">üü¢ –í–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –¥–ª—è —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞</div>
      <div class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff;" onclick="deleteContextBlock()">üóëÔ∏è –£–¥–∞–ª–∏—Ç—å</div>
    </div>
  </div>

  <!-- Context menu for connections -->
  <div id="connectionContextMenu" class="connection-context-menu">
    <div class="menu-section">
      <div class="menu-item" onclick="deleteConnection()" style="color: var(--danger);">
        <span>üóëÔ∏è –£–¥–∞–ª–∏—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ</span>
      </div>
    </div>
    
    <div class="menu-section">
      <div class="menu-section-title">–¶–≤–µ—Ç</div>
      <div class="menu-item" onclick="changeConnectionColor('system')">
        <div class="color-preview" style="background: linear-gradient(90deg, var(--accent), var(--accent-2));"></div>
        <span>–°–∏—Å—Ç–µ–º–Ω—ã–π —Ü–≤–µ—Ç</span>
      </div>
      <div class="menu-item" onclick="changeConnectionColor('orange')">
        <div class="color-preview" style="background: linear-gradient(90deg, #ff8c00, #ffa500);"></div>
        <span>–û—Ä–∞–Ω–∂–µ–≤—ã–π</span>
      </div>
      <div class="menu-item" onclick="changeConnectionColor('red')">
        <div class="color-preview" style="background: linear-gradient(90deg, #ff4444, #ff6666);"></div>
        <span>–ö—Ä–∞—Å–Ω—ã–π</span>
      </div>
      <div class="menu-item" onclick="changeConnectionColor('green')">
        <div class="color-preview" style="background: linear-gradient(90deg, #00ff88, #44ffaa);"></div>
        <span>–ó–µ–ª–µ–Ω—ã–π</span>
      </div>
      <div class="menu-item" onclick="changeConnectionColor('purple')">
        <div class="color-preview" style="background: linear-gradient(90deg, #8b5cf6, #a78bfa);"></div>
        <span>–§–∏–æ–ª–µ—Ç–æ–≤—ã–π</span>
      </div>
    </div>
  </div>

  <!-- Context menu for selection -->
  <div id="selectionContextMenu" style="position:absolute; display:none; z-index:20000;">
    <div style="background:#071025; padding:8px; border-radius:8px; box-shadow:0 8px 28px rgba(2,6,23,0.6); min-width:200px;">
      <div class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff;" onclick="clearSelectedBlocks()">üßπ –û—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª—è –≤–≤–æ–¥–∞</div>
      <div class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff;" onclick="deleteSelectedBlocksConnections()">üîó –£–¥–∞–ª–∏—Ç—å —Å–≤—è–∑–∏</div>
      <div id="toggleIgnoreIssuesMenuItem" class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff;" onclick="toggleIgnoreIssuesForSelected()">üü¢ –í–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫</div>
      <div id="toggleIgnoreMenuItem" class="menu-item" style="padding:8px; cursor:pointer; color:#ffffff;" onclick="toggleIgnoreSelectedBlocks()">üö´ –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å</div>
      <div style="height:6px"></div>
      <div class="menu-item" style="padding:8px; cursor:pointer; color: var(--danger);" onclick="deleteSelectedBlocks()">üóëÔ∏è –£–¥–∞–ª–∏—Ç—å</div>
    </div>
  </div>

  <!-- Save modal -->
  <div id="saveModal" style="display:none">
    <div class="modal-backdrop">
      <div class="modal" onkeydown="if(event.key==='Enter' && event.target.id==='saveFilename'){event.preventDefault();saveToServer();}">
        <h3>–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–æ–µ–∫—Ç</h3>
        <div style="margin-bottom:8px">–ò–º—è —Ñ–∞–π–ª–∞ (–±–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è):</div>
        <input id="saveFilename" class="input" placeholder="–º–æ–π_–ø—Ä–æ–µ–∫—Ç">
        <div style="height:12px"></div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn" onclick="saveToServer()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
          <button class="btn-ghost" onclick="closeSaveModal()">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Export .turtcd modal -->
  <div id="exportModal" style="display:none">
    <div class="modal-backdrop">
      <div class="modal">
        <h3>–≠–∫—Å–ø–æ—Ä—Ç –ø—Ä–æ–µ–∫—Ç–∞ (.turtcd)</h3>
        <div style="margin-bottom:8px">–ò–º—è —Ñ–∞–π–ª–∞ (–±–µ–∑ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è):</div>
        <input id="exportFilename" class="input" placeholder="project">
        <div class="small" style="opacity:0.8; margin-top:6px">–§–∞–π–ª –±—É–¥–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω –Ω–∞ –≤–∞—à–µ–º –∫–æ–º–ø—å—é—Ç–µ—Ä–µ.</div>
        <div style="height:12px"></div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn" onclick="confirmExportTurtcd()">–°–∫–∞—á–∞—Ç—å</button>
          <button class="btn-ghost" onclick="closeExportModal()">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Unsaved changes modal -->
  <div id="unsavedChangesModal" style="display:none">
    <div class="modal-backdrop">
      <div class="modal" onkeydown="if(event.key==='Enter' && !event.target.matches('input,textarea')){event.preventDefault();confirmUnsavedSave();}">
        <h3>–ù–µ—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è</h3>
        <div class="small" style="opacity:0.9; margin-bottom:12px">
          –í –ø—Ä–æ–µ–∫—Ç–µ –µ—Å—Ç—å –Ω–µ—Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è. –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø–µ—Ä–µ–¥ –≤—ã—Ö–æ–¥–æ–º –≤ –º–µ–Ω—é?
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn" onclick="confirmUnsavedSave()">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
          <button class="btn-ghost" onclick="confirmUnsavedDiscard()">–ù–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å</button>
          <button class="btn-ghost" onclick="closeUnsavedChangesModal()">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Clear workspace modal -->
  <div id="clearModal" style="display:none">
    <div class="modal-backdrop">
      <div class="modal" onkeydown="if(event.key==='Enter' && !event.target.matches('input,textarea')){event.preventDefault();confirmClearWorkspace();}">
        <h3>–û—á–∏—Å—Ç–∏—Ç—å —Ä–∞–±–æ—á–µ–µ –ø–æ–ª–µ</h3>
        <div style="margin-bottom:8px">–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –≤—Å–µ –±–ª–æ–∫–∏ —Å —Ä–∞–±–æ—á–µ–≥–æ –ø–æ–ª—è? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.</div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn" onclick="confirmClearWorkspace()">–û—á–∏—Å—Ç–∏—Ç—å</button>
          <button class="btn-ghost" onclick="closeClearModal()">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
  </div>

  <div id="resetSettingsModal" style="display:none">
    <div class="modal-backdrop" style="z-index:10060;">
      <div class="modal" onkeydown="if(event.key==='Enter' && !event.target.matches('input,textarea')){event.preventDefault();confirmResetSettings();}">
        <h3>–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é</h3>
        <div style="margin-bottom:8px">–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —Å–±—Ä–æ—Å–∏—Ç—å –≤—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫ –∑–Ω–∞—á–µ–Ω–∏—è–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.</div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn" onclick="confirmResetSettings()">–í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å</button>
          <button class="btn-ghost" onclick="closeResetSettingsModal()">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Revert changes confirmation modal -->
  <div id="revertChangesModal" style="display:none">
    <div class="modal-backdrop" onclick="closeRevertChangesModal()">
      <div class="modal" onkeydown="if(event.key==='Enter' && !event.target.matches('input,textarea')){event.preventDefault();confirmRevertChanges();}">
        <h3>–û—Ç–∫–∞—Ç–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è</h3>
        <div style="margin-bottom:8px">–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–∫–∞—Ç–∏—Ç—å –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏? –í—Å–µ –Ω–µ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –±—É–¥—É—Ç –ø–æ—Ç–µ—Ä—è–Ω—ã.</div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn" onclick="confirmRevertChanges()" style="background:linear-gradient(90deg,var(--accent),var(--accent-2));">–û—Ç–∫–∞—Ç–∏—Ç—å</button>
          <button class="btn-ghost" onclick="closeRevertChangesModal()">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Server list modal -->
  <div id="serverModal" style="display:none">
    <div class="modal-backdrop">
      <div class="modal">
        <h3>–ü—Ä–æ–µ–∫—Ç—ã –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ</h3>
        <div id="serverList" style="max-height:280px; overflow:auto; margin-top:8px"></div>
        <div style="height:12px"></div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn-ghost" onclick="closeServerModal()">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
      </div>
    </div>
  </div>


  <!-- Settings modal -->
  <div id="settingsModal" style="display:none">
    <div class="modal-backdrop" onclick="closeSettingsModal()">
      <div class="modal" onclick="event.stopPropagation()" style="max-width:1400px; width:85vw; position:relative;">
        <button onclick="closeSettingsModal()" style="position:absolute; top:12px; right:12px; width:32px; height:32px; border:none; background:rgba(255,255,255,0.1); border-radius:6px; color:var(--white); font-size:18px; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.15)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'" title="–ó–∞–∫—Ä—ã—Ç—å">‚úï</button>
        <h3>‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
        <div style="max-height:70vh; overflow:auto; padding-right:6px;">
          <!-- –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–∫ -->
          <div style="margin-bottom:24px; padding:16px; background:rgba(255,255,255,0.03); border-radius:12px; border:1px solid rgba(255,255,255,0.1);">
            <div style="font-weight:700; font-size:14px; margin-bottom:16px; color:#ff69b4; text-transform:uppercase; letter-spacing:0.5px;">–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–∫</div>
            <div style="display:flex; gap:16px; flex-wrap:wrap;">
              <div style="flex:1; min-width:300px; margin-bottom:12px">
                <div style="font-weight:600; margin-bottom:6px">–ú–æ–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä</div>
                <div style="display:flex; gap:8px; margin-bottom:8px">
                  <input type="text" id="settingsIdDisplay" readonly style="flex:1; padding:10px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:8px; color:var(--white); font-size:14px; font-family:monospace;" value="">
                  <button class="btn" onclick="copySettingsId()" style="white-space:nowrap;">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
                </div>
                <div class="small" style="opacity:0.7">–ö—Ä–∞—Ç–∫–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–µ–∫—É—â–∏—Ö –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö</div>
              </div>
              
              <div style="flex:1; min-width:300px; margin-bottom:12px">
                <div style="font-weight:600; margin-bottom:6px">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä</div>
                <div style="display:flex; gap:8px">
                  <input type="text" id="settingsIdInput" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–∫" style="flex:1; padding:10px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:8px; color:var(--white); font-size:14px; font-family:monospace;">
                  <button class="btn" onclick="applySettingsId()" style="white-space:nowrap;">–ü—Ä–∏–º–µ–Ω–∏—Ç—å</button>
                </div>
                <div class="small" style="opacity:0.7; margin-top:6px">–í—Å—Ç–∞–≤—å—Ç–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∏ –Ω–∞–∂–º–∏—Ç–µ "–ü—Ä–∏–º–µ–Ω–∏—Ç—å"</div>
              </div>
            </div>
          </div>
          
          <div style="display:flex; gap:16px; margin-bottom:16px; flex-wrap:wrap;">
          <!-- –°–∏—Å—Ç–µ–º–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ -->
          <div style="flex:1; min-width:320px; padding:12px; background:rgba(255,255,255,0.03); border-radius:12px; border:1px solid rgba(255,255,255,0.1);">
            <div style="font-weight:700; font-size:14px; margin-bottom:12px; color:var(--accent); text-transform:uppercase; letter-spacing:0.5px;">–°–∏—Å—Ç–µ–º–Ω—ã–µ</div>
            
            <div style="margin-bottom:12px; margin-top:16px;">
              <div style="font-weight:700; font-size:14px; margin-bottom:12px; color:var(--accent); text-transform:uppercase; letter-spacing:0.5px;">–ü—Ä–æ—á–µ–µ:</div>
            </div>
            
            <div style="margin-bottom:10px">
              <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                     onmouseover="this.style.borderColor='var(--accent)'" 
                     onmouseout="this.style.borderColor='transparent'">
                <input type="checkbox" id="showModsList" onchange="toggleShowModsList(this.checked)" style="cursor:pointer" checked>
                <div style="flex:1">
                  <div style="font-weight:600">–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–π</div>
                  <div class="small" style="opacity:0.7">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–π –≤ –ø—Ä–∞–≤–æ–π –ø–∞–Ω–µ–ª–∏</div>
                </div>
              </label>
            </div>
            
            <div style="margin-bottom:10px">
              <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                     onmouseover="this.style.borderColor='var(--accent)'" 
                     onmouseout="this.style.borderColor='transparent'">
                <input type="checkbox" id="allFieldsMultiLine" onchange="toggleAllFieldsMultiLine(this.checked)" style="cursor:pointer">
                <div style="flex:1">
                  <div style="font-weight:600">–í—Å–µ –ø–æ–ª—è –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–µ</div>
                  <div class="small" style="opacity:0.7">–í—Å–µ –ø–æ–ª—è –Ω–æ–≤—ã—Ö –±–ª–æ–∫–æ–≤ –±—É–¥—É—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å—Å—è –∫–∞–∫ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–µ</div>
                </div>
              </label>
            </div>
            
            <div style="margin-bottom:10px">
              <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                     onmouseover="this.style.borderColor='var(--accent)'" 
                     onmouseout="this.style.borderColor='transparent'">
                <input type="checkbox" id="autoCompleteQuotes" onchange="toggleAutoCompleteQuotes(this.checked)" style="cursor:pointer">
                <div style="flex:1">
                  <div style="font-weight:600">–ê–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–∞–≤—ã—á–µ–∫ –∏ —Å–∫–æ–±–æ–∫</div>
                  <div class="small" style="opacity:0.7">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è—Ç—å –∑–∞–∫—Ä—ã–≤–∞—é—â–∏–µ –∫–∞–≤—ã—á–∫–∏ –∏ —Å–∫–æ–±–∫–∏ –ø—Ä–∏ –≤–≤–æ–¥–µ</div>
                </div>
              </label>
            </div>
            
            <div style="margin-bottom:10px">
              <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                     onmouseover="this.style.borderColor='var(--accent)'" 
                     onmouseout="this.style.borderColor='transparent'">
                <input type="checkbox" id="arrowInversion" onchange="toggleArrowInversion(this.checked)" style="cursor:pointer">
                <div style="flex:1">
                  <div style="font-weight:600">–ò–Ω–≤–µ—Ä—Å–∏—è —Å—Ç—Ä–µ–ª–æ–∫</div>
                  <div class="small" style="opacity:0.7">–ú–µ–Ω—è–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–µ–ª–æ–∫ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è –ø–æ —Å—Ü–µ–Ω–µ</div>
                </div>
              </label>
            </div>
            
            <div style="margin-bottom:10px">
              <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                     onmouseover="this.style.borderColor='var(--accent)'" 
                     onmouseout="this.style.borderColor='transparent'">
                <input type="checkbox" id="strictBlockSelection" onchange="toggleStrictBlockSelection(this.checked)" style="cursor:pointer">
                <div style="flex:1">
                  <div style="font-weight:600">–î–∏–Ω–∞–º–∏—á–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –±–ª–æ–∫–æ–≤</div>
                  <div class="small" style="opacity:0.7">–ë–ª–æ–∫ –≤—ã–¥–µ–ª—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–∞—è —á–∞—Å—Ç—å –ø–æ–ø–∞–¥–∞–µ—Ç –≤ –æ–±–ª–∞—Å—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏—è</div>
                </div>
              </label>
            </div>
            
            <div class="settings-subgroup" style="margin-bottom:16px; padding:12px; border:1px dashed rgba(255,255,255,0.4); border-radius:8px;">
              <div style="margin-bottom:10px">
                <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="checkbox" id="autoSnapBlocks" onchange="toggleAutoSnapBlocks(this.checked)" style="cursor:pointer">
                  <div style="flex:1">
                    <div style="font-weight:600">–ê–≤—Ç–æ–ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–ª–æ–∫–æ–≤</div>
                    <div class="small" style="opacity:0.7">–ü—Ä–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏ –±–ª–æ–∫ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–º–∞–≥–Ω–∏—á–∏–≤–∞–µ—Ç—Å—è –∫ —Å–≤–æ–±–æ–¥–Ω—ã–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–∞–º –¥—Ä—É–≥–∏—Ö –±–ª–æ–∫–æ–≤</div>
                  </div>
                </label>
              </div>
              
              <div id="autoConnectBlocksSetting" style="margin-bottom:10px; opacity:0.5; pointer-events:none;">
                <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="checkbox" id="autoConnectBlocks" onchange="toggleAutoConnectBlocks(this.checked)" style="cursor:pointer" checked>
                  <div style="flex:1">
                    <div style="font-weight:600">–°–æ–µ–¥–∏–Ω—è—Ç—å –±–ª–æ–∫–∏ –ø—Ä–∏ –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–µ</div>
                    <div class="small" style="opacity:0.7">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–≤–∞—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø—Ä–∏ –ø—Ä–∏–º–∞–≥–Ω–∏—á–∏–≤–∞–Ω–∏–∏ –±–ª–æ–∫–∞</div>
                  </div>
                </label>
              </div>
              
              <div id="blockSpacingSetting" style="opacity:0.5; pointer-events:none;">
                <div style="font-weight:600; margin-bottom:6px">–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –±–ª–æ–∫–∞–º–∏</div>
                <select id="blockSpacing" onchange="changeBlockSpacing(this.value)" style="width:100%; padding:10px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); border-radius:8px; color:var(--white); font-size:14px; cursor:pointer;">
                  <option value="min" style="background:#0b1220; color:#ffffff;">–ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ</option>
                  <option value="optimal" selected style="background:#0b1220; color:#ffffff;">–û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ</option>
                  <option value="max" style="background:#0b1220; color:#ffffff;">–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ</option>
                </select>
                <div class="small" style="opacity:0.7; margin-top:6px">–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –±–ª–æ–∫–∞–º–∏ –ø—Ä–∏ –∞–≤—Ç–æ–ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–µ</div>
              </div>
            </div>
            
            <div style="margin-bottom:16px">
              <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s; margin-bottom:6px" 
                     onmouseover="this.style.borderColor='var(--accent)'" 
                     onmouseout="this.style.borderColor='transparent'">
                <input type="checkbox" id="showConnectorLabels" onchange="toggleShowConnectorLabels(this.checked)" style="cursor:pointer" checked>
                <div style="flex:1">
                  <div style="font-weight:600">–ü–æ–¥–ø–∏—Å—ã–≤–∞—Ç—å –∏–º–µ–Ω–∞ –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–æ–≤</div>
                  <div class="small" style="opacity:0.7">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å tooltip —Å –∏–º–µ–Ω–∞–º–∏ –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–æ–≤</div>
                </div>
              </label>
              <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s; margin-bottom:6px" 
                     onmouseover="this.style.borderColor='var(--accent)'" 
                     onmouseout="this.style.borderColor='transparent'">
                <input type="checkbox" id="showFieldLabels" onchange="toggleShowFieldLabels(this.checked)" style="cursor:pointer" checked>
                <div style="flex:1">
                  <div style="font-weight:600">–ü–æ–¥–ø–∏—Å—ã–≤–∞—Ç—å –∏–º–µ–Ω–∞ –ø–æ–ª–µ–π –≤–≤–æ–¥–∞</div>
                  <div class="small" style="opacity:0.7">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å tooltip —Å –∏–º–µ–Ω–∞–º–∏ –ø–æ–ª–µ–π –≤–≤–æ–¥–∞</div>
                </div>
              </label>
              <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                     onmouseover="this.style.borderColor='var(--accent)'" 
                     onmouseout="this.style.borderColor='transparent'">
                <input type="checkbox" id="showCompiledCode" onchange="toggleShowCompiledCode(this.checked)" style="cursor:pointer">
                <div style="flex:1">
                  <div style="font-weight:600">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∫–æ–¥ –ø–æ—Å–ª–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏</div>
                  <div class="small" style="opacity:0.7">–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥ –≤ –æ–∫–Ω–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏</div>
                </div>
              </label>
            </div>
          </div>
          
          <!-- –î–µ–±–∞–≥–≥–∏–Ω–≥ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ -->
          <div style="flex:1; min-width:320px; padding:12px; background:rgba(255,255,255,0.03); border-radius:12px; border:1px solid rgba(255,255,255,0.1);">
            <div style="font-weight:700; font-size:14px; margin-bottom:12px; color:#f59e0b; text-transform:uppercase; letter-spacing:0.5px;">–î–µ–±–∞–≥–≥–∏–Ω–≥</div>
            
            <div class="settings-subgroup" style="margin-bottom:16px; padding:12px; border:1px dashed rgba(255,255,255,0.4); border-radius:8px;">
              <div style="font-weight:600; margin-bottom:6px">–ë–ª–æ–∫–∏ —Å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è–º–∏</div>
              <div style="display:flex; gap:8px; flex-direction:column">
                <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="radio" name="warningHighlightStyle" value="full" id="warningHighlightStyleFull" onchange="changeWarningHighlightStyle('full')" style="cursor:pointer">
                  <div style="flex:1">
                    <div style="font-weight:600">–ü–æ–ª–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ</div>
                    <div class="small" style="opacity:0.7">–û–±–≤–æ–¥–∫–∞, —Ç–µ–Ω—å –∏ —Å–∏–º–≤–æ–ª –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è</div>
                  </div>
                </label>
                <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="radio" name="warningHighlightStyle" value="outline" id="warningHighlightStyleOutline" onchange="changeWarningHighlightStyle('outline')" style="cursor:pointer">
                  <div style="flex:1">
                    <div style="font-weight:600">–¢–æ–ª—å–∫–æ –æ–±–≤–æ–¥–∫–∞</div>
                    <div class="small" style="opacity:0.7">–¢–æ–ª—å–∫–æ —Ü–≤–µ—Ç–Ω–∞—è —Ä–∞–º–∫–∞ –≤–æ–∫—Ä—É–≥ –±–ª–æ–∫–∞</div>
                  </div>
                </label>
                <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="radio" name="warningHighlightStyle" value="symbol" id="warningHighlightStyleSymbol" onchange="changeWarningHighlightStyle('symbol')" style="cursor:pointer">
                  <div style="flex:1">
                    <div style="font-weight:600">–¢–æ–ª—å–∫–æ —Å–∏–º–≤–æ–ª –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è</div>
                    <div class="small" style="opacity:0.7">–¢–æ–ª—å–∫–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä "!" –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É</div>
                  </div>
                </label>
                <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="radio" name="warningHighlightStyle" value="none" id="warningHighlightStyleNone" onchange="changeWarningHighlightStyle('none')" style="cursor:pointer">
                  <div style="flex:1">
                    <div style="font-weight:600">–ù–µ –≤—ã–¥–µ–ª—è—Ç—å</div>
                    <div class="small" style="opacity:0.7">–ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–∫—Ä—ã—Ç—å –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ</div>
                  </div>
                </label>
              </div>
            </div>
            
            <div class="settings-subgroup" style="margin-bottom:16px; padding:12px; border:1px dashed rgba(255,255,255,0.4); border-radius:8px;">
              <div style="font-weight:600; margin-bottom:6px">–ë–ª–æ–∫–∏ —Å –æ—à–∏–±–∫–∞–º–∏</div>
              <div style="display:flex; gap:8px; flex-direction:column">
                <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="radio" name="errorHighlightStyle" value="full" id="errorHighlightStyleFull" onchange="changeErrorHighlightStyle('full')" style="cursor:pointer">
                  <div style="flex:1">
                    <div style="font-weight:600">–ü–æ–ª–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ</div>
                    <div class="small" style="opacity:0.7">–û–±–≤–æ–¥–∫–∞, —Ç–µ–Ω—å –∏ —Å–∏–º–≤–æ–ª –æ—à–∏–±–∫–∏</div>
                  </div>
                </label>
                <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="radio" name="errorHighlightStyle" value="outline" id="errorHighlightStyleOutline" onchange="changeErrorHighlightStyle('outline')" style="cursor:pointer">
                  <div style="flex:1">
                    <div style="font-weight:600">–¢–æ–ª—å–∫–æ –æ–±–≤–æ–¥–∫–∞</div>
                    <div class="small" style="opacity:0.7">–¢–æ–ª—å–∫–æ —Ü–≤–µ—Ç–Ω–∞—è —Ä–∞–º–∫–∞ –≤–æ–∫—Ä—É–≥ –±–ª–æ–∫–∞</div>
                  </div>
                </label>
                <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="radio" name="errorHighlightStyle" value="symbol" id="errorHighlightStyleSymbol" onchange="changeErrorHighlightStyle('symbol')" style="cursor:pointer">
                  <div style="flex:1">
                    <div style="font-weight:600">–¢–æ–ª—å–∫–æ —Å–∏–º–≤–æ–ª –æ—à–∏–±–∫–∏</div>
                    <div class="small" style="opacity:0.7">–¢–æ–ª—å–∫–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä "‚úï" –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É</div>
                  </div>
                </label>
                <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="radio" name="errorHighlightStyle" value="none" id="errorHighlightStyleNone" onchange="changeErrorHighlightStyle('none')" style="cursor:pointer">
                  <div style="flex:1">
                    <div style="font-weight:600">–ù–µ –≤—ã–¥–µ–ª—è—Ç—å</div>
                    <div class="small" style="opacity:0.7">–ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–∫—Ä—ã—Ç—å –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –≤—ã–¥–µ–ª–µ–Ω–∏–µ</div>
                  </div>
                </label>
              </div>
            </div>
            
            <div style="margin-bottom:16px">
              <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                     onmouseover="this.style.borderColor='var(--accent)'" 
                     onmouseout="this.style.borderColor='transparent'">
                <input type="checkbox" id="showSelectionSummary" onchange="toggleShowSelectionSummary(this.checked)" style="cursor:pointer" checked>
                <div style="flex:1">
                  <div style="font-weight:600">–ö—Ä–∞—Ç–∫–∞—è —Å–≤–æ–¥–∫–∞ –Ω–∞ –≤—ã–¥–µ–ª–µ–Ω–∏–∏</div>
                  <div class="small" style="opacity:0.7">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤—ã–¥–µ–ª–µ–Ω–Ω—ã—Ö –±–ª–æ–∫–∞—Ö</div>
                </div>
              </label>
            </div>
            
            <div style="margin-bottom:16px">
              <label style="display:flex; align-items:center; gap:10px; padding:10px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid transparent; transition:all 0.2s" 
                     onmouseover="this.style.borderColor='var(--accent)'" 
                     onmouseout="this.style.borderColor='transparent'">
                <input type="checkbox" id="showBlockPath" onchange="toggleShowBlockPath(this.checked)" style="cursor:pointer" checked>
                <div style="flex:1">
                  <div style="font-weight:600">–û—Ç–æ–±—Ä–∞–∂–∞—Ç—å –ø—É—Ç—å –±–ª–æ–∫–∞</div>
                  <div class="small" style="opacity:0.7">–ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø—É—Ç—å –±–ª–æ–∫–∞ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–º –º–µ–Ω—é –ø—Ä–∏ –ü–ö–ú</div>
                </div>
              </label>
            </div>
          </div>
          </div>

          <div style="display:flex; gap:16px; flex-wrap:wrap;">
            <!-- TSS -->
            <div style="flex:1; min-width:320px; padding:12px; background:rgba(255,255,255,0.03); border-radius:12px; border:1px solid rgba(255,255,255,0.1);">
              <div style="font-weight:700; font-size:14px; margin-bottom:12px; color:#34d399; text-transform:uppercase; letter-spacing:0.5px;">TSS (Turt Safety System)</div>
              
              <div style="margin-bottom:12px">
                <div style="font-weight:600; margin-bottom:6px">–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ä–µ–∂–∏–º</div>
                <div style="display:flex; gap:8px; flex-direction:column">
                  <label style="display:flex; align-items:center; gap:10px; padding:12px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid rgba(239,68,68,0.5); transition:all 0.2s" 
                         onmouseover="this.style.borderColor='rgba(239,68,68,0.8)'" 
                         onmouseout="this.style.borderColor='rgba(239,68,68,0.5)'">
                    <input type="radio" name="settingsSafeMode" value="full" id="settingsSafeModeFull" onchange="changeSafeMode('full')" style="cursor:pointer">
                    <div style="flex:1">
                      <div style="font-weight:600; color:var(--danger);">–ü–æ–ª–Ω–∞—è —Å–≤–æ–±–æ–¥–∞</div>
                      <div class="small" style="opacity:0.7">–°–æ–∑–¥–∞–Ω–∏–µ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ª—é–±—ã—Ö —Ñ–∞–π–ª–æ–≤ –∏ –ø–∞–ø–æ–∫</div>
                    </div>
                  </label>
                  <label style="display:flex; align-items:center; gap:10px; padding:12px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid rgba(245,158,11,0.5); transition:all 0.2s" 
                         onmouseover="this.style.borderColor='rgba(245,158,11,0.8)'" 
                         onmouseout="this.style.borderColor='rgba(245,158,11,0.5)'">
                    <input type="radio" name="settingsSafeMode" value="limited" id="settingsSafeModeLimited" onchange="changeSafeMode('limited')" style="cursor:pointer">
                    <div style="flex:1">
                      <div style="font-weight:600; color:#f59e0b;">–û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–µ –ø—Ä–∞–≤–∞</div>
                      <div class="small" style="opacity:0.7">–†–∞–±–æ—Ç–∞ —Ç–æ–ª—å–∫–æ —Å —Ñ–∞–π–ª–∞–º–∏ –ø—Ä–æ–µ–∫—Ç–∞ –∏ –±–µ–∑–æ–ø–∞—Å–Ω—ã–º–∏ –∫–∞—Ç–∞–ª–æ–≥–∞–º–∏</div>
                    </div>
                  </label>
                  <label style="display:flex; align-items:center; gap:10px; padding:12px; background:rgba(255,255,255,0.03); border-radius:8px; cursor:pointer; border:2px solid rgba(16,185,129,0.5); transition:all 0.2s" 
                         onmouseover="this.style.borderColor='rgba(16,185,129,0.8)'" 
                         onmouseout="this.style.borderColor='rgba(16,185,129,0.5)'">
                    <input type="radio" name="settingsSafeMode" value="restricted" id="settingsSafeModeRestricted" onchange="changeSafeMode('restricted')" style="cursor:pointer">
                    <div style="flex:1">
                      <div style="font-weight:600; color:var(--success);">–ü–æ–ª–Ω—ã–π –∑–∞–ø—Ä–µ—Ç</div>
                      <div class="small" style="opacity:0.7">–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ª—é–±—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π —Å —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–æ–π</div>
                    </div>
                  </label>
                </div>
              </div>

              <div>
                <label style="display:flex; align-items:flex-start; gap:10px; padding:12px; background:rgba(255,255,255,0.03); border-radius:8px; border:2px solid transparent; transition:all 0.2s" 
                       onmouseover="this.style.borderColor='var(--accent)'" 
                       onmouseout="this.style.borderColor='transparent'">
                  <input type="checkbox" id="tssSecurityToggle" onchange="toggleTssSecurity(this.checked)" style="cursor:pointer; margin-top:4px" checked>
                  <div style="flex:1">
                    <div style="font-weight:600">–°–ª—É–∂–±–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ TSS</div>
                    <div class="small" style="opacity:0.75">–ü—Ä–∏ –≤–∫–ª—é—á–µ–Ω–∏–∏ TSS –±–ª–æ–∫–∏—Ä—É–µ—Ç –∑–∞–ø—É—Å–∫ –∏ —Å–±–æ—Ä–∫—É –ø—Ä–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–∫–∞—Ö –∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è—Ö</div>
                  </div>
                </label>
                <div id="tssSecurityDescription" class="small" style="margin-top:6px; opacity:0.85; color:#22c55e;"></div>
              </div>
            </div>

            <!-- Setup -->
            <div style="flex:1; min-width:320px; padding:12px; background:rgba(255,255,255,0.03); border-radius:12px; border:1px solid rgba(255,255,255,0.1);">
              <div style="font-weight:700; font-size:14px; margin-bottom:12px; color:#60a5fa; text-transform:uppercase; letter-spacing:0.5px;">Setup</div>
              <div class="small" style="opacity:0.75; margin-bottom:10px;">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ <code>requirements.txt</code>, –∏–∑–º–µ–Ω—è–π—Ç–µ –µ–≥–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∑–Ω–∞–µ—Ç–µ —á—Ç–æ –¥–µ–ª–∞–µ—Ç–µ –∏ —è–≤–ª—è–µ—Ç–µ—Å—å –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –¥–≤–∏–∂–∫–∞</div>
              <textarea id="requirementsEditor" disabled rows="12" style="width:100%; min-height:220px; border-radius:10px; border:1px solid rgba(255,255,255,0.15); background:rgba(0,0,0,0.35); color:var(--white); font-family:'Consolas','Fira Code',monospace; font-size:13px; padding:12px; resize:vertical;">–ó–∞–≥—Ä—É–∑–∫–∞...</textarea>
              <div style="display:flex; gap:10px; align-items:center; margin-top:12px; flex-wrap:wrap;">
                <button id="saveRequirementsBtn" class="btn" onclick="saveRequirementsChanges()" style="padding:10px 18px; font-size:14px; background:linear-gradient(90deg,var(--accent),var(--accent-2)); border:none; border-radius:8px; cursor:pointer;">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å requirements.txt</button>
                <span class="small" style="opacity:0.8;">–ü–æ—Å–ª–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –ª–∞—É–Ω—á–µ—Ä –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π</span>
              </div>
            </div>
          </div>
          <div style="display:flex; justify-content:flex-end; margin-top:12px;">
            <button class="btn-ghost" onclick="openResetSettingsModal()" style="padding:10px 14px;">‚Ü∫ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Requirements status modal -->
  <div id="requirementsStatusModal" style="display:none">
    <div class="modal-backdrop" onclick="closeRequirementsStatusModal()">
      <div class="modal" onclick="event.stopPropagation()" style="max-width:420px">
        <h3 id="requirementsStatusModalTitle">–°—Ç–∞—Ç—É—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è</h3>
        <div id="requirementsStatusModalMessage" class="small" style="margin:12px 0; opacity:0.85;"></div>
        <div style="display:flex; justify-content:flex-end; gap:8px;">
          <button class="btn" onclick="closeRequirementsStatusModal()" style="background:linear-gradient(90deg,var(--accent),var(--accent-2));">–ü–æ–Ω—è—Ç–Ω–æ</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Warning modal (only warnings are shown) -->
  <div id="errorWarningModal" class="error-modal" style="display:none">
    <div class="error-modal-backdrop">
      <div class="error-modal-content">
        <div class="error-modal-header">
          <h3>‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è</h3>
        </div>
        <div class="error-modal-body">
          <div class="issues-summary">
            <div class="issue-count warning-count">
              <span class="issue-icon">‚ö†Ô∏è</span>
              <span class="issue-text">–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π: <strong id="warningCount">0</strong></span>
            </div>
          </div>
          <p>–í –≤–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è –≤ –ø—Ä–∞–≤–æ–π –ø–∞–Ω–µ–ª–∏.</p>
          <p><strong>–í–Ω–∏–º–∞–Ω–∏–µ:</strong> –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –Ω–µ–≤–µ—Ä–Ω–æ–º—É –∏–ª–∏ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–æ–º—É –ø–æ–≤–µ–¥–µ–Ω–∏—é –ø—Ä–æ–≥—Ä–∞–º–º—ã.</p>
        </div>
        <div class="error-modal-footer">
          <button class="btn-ghost" onclick="closeErrorWarningModal()">‚Üê –í–µ—Ä–Ω—É—Ç—å—Å—è –∫ –∫–æ–¥—É</button>
          <button id="ignoreErrorsBtn" class="btn btn-danger" onclick="ignoreErrorsAndCompile()" disabled>–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å (3—Å)</button>
        </div>
      </div>
    </div>
  </div>

  <!-- RGB picker modal -->
  <div id="rgbPickerModal" style="display:none">
    <div class="modal-backdrop" onclick="closeRgbPickerModal()">
      <div class="modal" onclick="event.stopPropagation()" style="max-width:380px">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
          <h3 style="margin:0;">–í—ã–±–æ—Ä —Ü–≤–µ—Ç–∞</h3>
          <button class="btn-ghost" onclick="closeRgbPickerModal()" title="–ó–∞–∫—Ä—ã—Ç—å" style="padding:6px 10px;">‚úï</button>
        </div>
        <div style="margin-top:12px; display:flex; flex-direction:column; gap:12px;">
          <input id="rgbColorInput" type="color" value="#ff0000" style="width:100%; height:48px; border:none; background:transparent; cursor:pointer;">
          <div style="display:flex; gap:8px; align-items:center;">
            <input id="rgbColorValue" type="text" readonly value="#ff0000" style="flex:1; padding:10px; border-radius:8px; border:1px solid rgba(255,255,255,0.2); background:rgba(255,255,255,0.05); color:var(--white); font-family:'Consolas','Fira Code',monospace;">
            <button class="btn" onclick="copyRgbValue()" style="padding:10px 14px;">üìã</button>
          </div>

          <div style="border-top:1px solid rgba(255,255,255,0.08); padding-top:8px; display:flex; flex-direction:column; gap:10px;">
            <div style="font-weight:600;">–°—Ç–∏–ª—å —Ç–µ–∫—Å—Ç–∞</div>
            <div style="display:flex; gap:8px;">
              <select id="rgbFontSelector" style="flex:1; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.28); background:#0f172a; color:#e5e7eb;">
                <option value="Arial" selected style="background:#0f172a; color:#e5e7eb;">Arial</option>
                <option value="Segoe UI" style="background:#0f172a; color:#e5e7eb;">Segoe UI</option>
                <option value="Roboto" style="background:#0f172a; color:#e5e7eb;">Roboto</option>
                <option value="Courier New" style="background:#0f172a; color:#e5e7eb;">Courier New</option>
                <option value="Times New Roman" style="background:#0f172a; color:#e5e7eb;">Times New Roman</option>
                <option value="Tahoma" style="background:#0f172a; color:#e5e7eb;">Tahoma</option>
                <option value="Verdana" style="background:#0f172a; color:#e5e7eb;">Verdana</option>
                <option value="Monospace" style="background:#0f172a; color:#e5e7eb;">Monospace</option>
              </select>
              <input id="rgbFontSize" type="number" min="6" max="72" value="14" style="width:80px; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.2); background:rgba(255,255,255,0.04); color:var(--white);" />
            </div>
            <div id="rgbFontPreview" style="padding:10px; border-radius:8px; border:1px dashed rgba(255,255,255,0.25); background:rgba(255,255,255,0.03); color:var(--white);">
              –≠—Ç–æ –ø—Ä–æ—Å—Ç–æ–π –ø—Ä–∏–º–µ—Ä –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –≤–∞–º–∏ —Å—Ç–∏–ª—è !
            </div>
            <div id="rgbFontInfo" style="padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.12); background:rgba(255,255,255,0.02); color:var(--white); font-family:'Consolas','Fira Code',monospace; font-size:13px;">
              Arial, 14
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

    <!-- Compile blocked modal (when errors exist) -->
    <div id="compileBlockedModal" class="error-modal" style="display:none">
      <div class="error-modal-backdrop">
        <div class="error-modal-content">
          <div class="error-modal-header">
            <h3>‚õî –°–±–æ—Ä–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞ ‚Äî –û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –æ—à–∏–±–∫–∏</h3>
          </div>
          <div class="error-modal-body">
            <p>–í –ø—Ä–æ–µ–∫—Ç–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω—ã –æ—à–∏–±–∫–∏, –∏–∑-–∑–∞ –∫–æ—Ç–æ—Ä—ã—Ö —Å–±–æ—Ä–∫–∞ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞.</p>
            <p style="margin-top:12px">–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—à–∏–±–æ–∫: <strong id="compileBlockedErrorCount">0</strong></p>
            <!-- Removed: detailed sentence per user request -->
          </div>
          <div class="error-modal-footer">
            <button class="btn" onclick="closeCompileBlockedModal()" style="background:linear-gradient(90deg,var(--accent),var(--accent-2));">–ó–∞–∫—Ä—ã—Ç—å</button>
          </div>
        </div>
      </div>
    </div>

  <!-- Unknown blocks modal -->
  <div id="unknownBlocksModal" style="display:none">
    <div class="modal-backdrop">
      <div class="modal">
        <h3>–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –Ω–µ–∑–Ω–∞–∫–æ–º—ã–µ –±–ª–æ–∫–∏</h3>
        <div class="small" style="opacity:0.9; margin-bottom:8px">
          –í–æ–∑–º–æ–∂–Ω–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ –≤ –ø–∞–ø–∫–µ <code>mods</code>. –ü—Ä–æ–µ–∫—Ç –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é.
        </div>
        <div id="unknownBlocksList" class="small" style="max-height:220px; overflow:auto; padding:8px; border:1px dashed rgba(255,255,255,0.15); border-radius:8px"></div>
        <div style="height:12px"></div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn-ghost" onclick="closeUnknownBlocksModal()">–ü–æ–Ω—è—Ç–Ω–æ</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Global ignore confirmation modal -->
  <div id="globalIgnoreModal" style="display:none">
    <div class="modal-backdrop">
      <div class="modal">
        <h3>–í–Ω–∏–º–∞–Ω–∏–µ: –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫</h3>
        <div class="small" style="opacity:0.9; margin-bottom:12px">
          –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –æ—à–∏–±–æ–∫ –∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Ä–∞–±–æ—Ç–µ –∏ –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Å–ª—É—á–∞—è—Ö –Ω–∞–Ω–µ—Å—Ç–∏ —É—Ä–æ–Ω –≤–∞—à–µ–º—É –∫–æ–º–ø—å—é—Ç–µ—Ä—É.
        </div>
        <div class="small" style="opacity:0.9; margin-bottom:16px">
          –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø–æ–Ω–∏–º–∞–µ—Ç–µ –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è.
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn-ghost" onclick="closeGlobalIgnoreModal()">–û—Ç–º–µ–Ω–∏—Ç—å</button>
          <button id="confirmGlobalIgnoreBtn" class="btn btn-danger" onclick="confirmGlobalIgnore()" disabled>–Ø –∑–Ω–∞—é —á—Ç–æ –¥–µ–ª–∞—é (10—Å)</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Empty project warning modal -->
  <div id="emptyProjectModal" style="display:none">
    <div class="modal-backdrop">
      <div class="modal">
        <h3>‚ö†Ô∏è –ü—Ä–æ–µ–∫—Ç –ø—É—Å—Ç</h3>
        <div style="margin-bottom:16px">
          <p>–í–∞—à –ø—Ä–æ–µ–∫—Ç –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∏—Å–ø–æ–ª–Ω—è–µ–º–æ–≥–æ –∫–æ–¥–∞ –∏–ª–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏.</p>
          <p style="color: var(--muted); font-size: 14px; margin-top: 8px;">
            <strong>–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é:</strong> –∑–∞–ø—É—Å–∫, —Å–±–æ—Ä–∫–∞ –≤ .exe –∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤ .py
          </p>
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn-ghost" onclick="closeEmptyProjectModal()">–ü–æ–Ω—è—Ç–Ω–æ</button>
        </div>
      </div>
    </div>
  </div>

  <!-- No header blocks warning modal -->
  <div id="noHeaderBlocksModal" style="display:none">
    <div class="modal-backdrop">
      <div class="modal">
        <h3>‚ö†Ô∏è –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –±–ª–æ–∫ "–ù–∞—á–∞–ª–æ"</h3>
        <div style="margin-bottom:16px">
          <p>–ù–∞ —Ä–∞–±–æ—á–µ–º –ø–æ–ª–µ –Ω–µ —Ä–∞–∑–º–µ—â–µ–Ω –Ω–∏ –æ–¥–∏–Ω –±–ª–æ–∫ —Ç–∏–ø–∞ "–ù–∞—á–∞–ª–æ" (header).</p>
          <p style="color: var(--muted); font-size: 14px; margin-top: 8px;">
            –ë–µ–∑ –±–ª–æ–∫–∞ "–ù–∞—á–∞–ª–æ" –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–µ –±—É–¥–µ—Ç –∏–º–µ—Ç—å —Ç–æ—á–∫–∏ –≤—Ö–æ–¥–∞ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.
          </p>
          <p><strong>–£–≤–µ—Ä–µ–Ω—ã –ª–∏ –≤—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –Ω–∞—á–∞—Ç—å —Å–±–æ—Ä–∫—É?</strong></p>
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn-ghost" onclick="closeNoHeaderBlocksModal()">–û—Ç–º–µ–Ω–∞</button>
          <button class="btn" onclick="confirmCompileWithoutHeader()">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å–±–æ—Ä–∫—É</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Variable usage history modal -->
  <div id="variableHistoryModal" style="display:none">
    <div class="modal-backdrop">
      <div class="modal" style="max-width:500px">
        <h3 id="variableHistoryTitle">–ò—Å—Ç–æ—Ä–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π</h3>
        <div style="margin-bottom:16px">
          <div id="variableHistoryList" style="max-height:400px; overflow:auto; border:1px solid rgba(255,255,255,0.1); border-radius:8px; padding:8px;">
            <!-- List will be populated by JavaScript -->
          </div>
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn-ghost" onclick="closeVariableHistoryModal()">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Delete block/branch modal -->
  <div id="deleteBlockBranchModal" style="display:none">
    <div class="modal-backdrop" onclick="if(event.target === this) closeDeleteBlockBranchModal()">
      <div class="modal">
        <h3>–£–¥–∞–ª–µ–Ω–∏–µ –±–ª–æ–∫–∞</h3>
        <div style="margin-bottom:16px">
          <p>–ö –ø—Ä–∞–≤–æ–º—É –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä—É —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞ –ø–æ–¥—Å–æ–µ–¥–∏–Ω–µ–Ω—ã –¥—Ä—É–≥–∏–µ –±–ª–æ–∫–∏. –ß—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å?</p>
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn" onclick="confirmDeleteBlockOnly()" style="background:linear-gradient(90deg,var(--accent),var(--accent-2));">–¢–æ–ª—å–∫–æ –±–ª–æ–∫</button>
          <button class="btn" onclick="confirmDeleteBranch()" style="background:linear-gradient(90deg,var(--danger),#c0392b);">–í—Å—é –≤–µ—Ç–∫—É</button>
          <button class="btn-ghost" onclick="closeDeleteBlockBranchModal()">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Duplicate block/branch modal -->
  <div id="duplicateBlockBranchModal" style="display:none">
    <div class="modal-backdrop" onclick="if(event.target === this) closeDuplicateBlockBranchModal()">
      <div class="modal">
        <h3>–î—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –±–ª–æ–∫–∞</h3>
        <div style="margin-bottom:16px">
          <p>–ö –ø—Ä–∞–≤–æ–º—É –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä—É —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞ –ø–æ–¥—Å–æ–µ–¥–∏–Ω–µ–Ω—ã –¥—Ä—É–≥–∏–µ –±–ª–æ–∫–∏. –ß—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å?</p>
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end">
          <button class="btn" onclick="confirmDuplicateBlockOnly()" style="background:linear-gradient(90deg,var(--accent),var(--accent-2));">–¢–æ–ª—å–∫–æ –±–ª–æ–∫</button>
          <button class="btn" onclick="confirmDuplicateBranch()" style="background:linear-gradient(90deg,var(--accent),var(--accent-2));">–í—Å—é –≤–µ—Ç–∫—É</button>
          <button class="btn-ghost" onclick="closeDuplicateBlockBranchModal()">–û—Ç–º–µ–Ω–∞</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Failed to fetch error modal -->
  <div id="failedToFetchModal" class="error-modal" style="display:none">
    <div class="error-modal-backdrop">
      <div class="error-modal-content">
        <div class="error-modal-header">
          <h3>‚ùå Failed to fetch ‚Äî –û—à–∏–±–∫–∞ —Å–±–æ—Ä–∫–∏ –∫–æ–¥–∞</h3>
        </div>
        <div class="error-modal-body">
          <p><strong>–ß—Ç–æ –ø—Ä–æ–∏–∑–æ—à–ª–æ?</strong></p>
          <p>–ü—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à –ø—Ä–æ–µ–∫—Ç –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ —Å–µ—Ç–µ–≤–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è.</p>
          
          <p style="margin-top: 16px;"><strong>–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã:</strong></p>
          <ul style="margin: 8px 0; padding-left: 20px;">
            <li style="margin-bottom: 6px;">–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Å–æ–µ–¥–∏–Ω–µ–Ω—ã –±–ª–æ–∫–∏ ‚Äî –æ–Ω–∏ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω—ã –º–µ–∂–¥—É —Å–æ–±–æ–π –∏–ª–∏ –∏—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã</li>
            <li style="margin-bottom: 6px;">–û—à–∏–±–∫–∞ –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ —Å–µ—Ä–≤–µ—Ä–∞ ‚Äî –ø—Ä–æ–±–ª–µ–º–∞ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –≤–∞—à–µ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞</li>
            <li style="margin-bottom: 6px;">–ü—Ä–æ–±–ª–µ–º–∞ —Å–µ—Ç–µ–≤–æ–≥–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è ‚Äî –ø–æ—Ç–µ—Ä—è —Å–≤—è–∑–∏ —Å —Å–µ—Ä–≤–µ—Ä–æ–º</li>
          </ul>
          
          <p style="margin-top: 16px;"><strong>–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:</strong></p>
          <ul style="margin: 8px 0; padding-left: 20px;">
            <li style="margin-bottom: 6px;">–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –º–µ–∂–¥—É –±–ª–æ–∫–∞–º–∏</li>
            <li style="margin-bottom: 6px;">–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö —Å–æ–≤–º–µ—Å—Ç–∏–º—ã</li>
            <li style="margin-bottom: 6px;">–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å —Å–±–æ—Ä–∫—É –∫–æ–¥–∞ –µ—â–µ —Ä–∞–∑</li>
            <li style="margin-bottom: 6px;">–ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–æ–º</li>
          </ul>
        </div>
        <div class="error-modal-footer">
          <button class="btn-ghost" onclick="closeFailedToFetchModal()">–ó–∞–∫—Ä—ã—Ç—å</button>
          <button class="btn" onclick="closeFailedToFetchModal(); setTimeout(() => compileProject(), 300);" style="background:linear-gradient(90deg,var(--accent),var(--accent-2));">–ü–æ–≤—Ç–æ—Ä–∏—Ç—å —Å–±–æ—Ä–∫—É</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* ========== State ========== */
let blocksConfig = { categories: [] };
let projectData = { blocks: [], connections: [] };
let enabledMods = {}; // { [modId]: boolean }

// Unsaved changes tracking
let _savedSnapshot = null;
let _pendingAfterUnsavedAction = null; // function to execute after choosing in modal

let dragState = null;           // dragging a block element
let connecting = null;          // creating connection {blockEl, connEl, startX, startY, tempLine}
let camera = { x: 0, y: 0, scale: 1 };    // camera translation
let isPanning = false;
let panStart = null;
let panCameraStart = null;
let selectionState = null;     // {startX, startY, currentX, currentY, areaEl, selectedBlockIds: Set, isActive: boolean}
let contextBlockEl = null;
let contextConnectionEl = null;

// Autocomplete system for value fields
let valueHistory = new Map(); // Stores history of entered values
let currentAutocomplete = null; // Current active autocomplete
let variableTags = {}; // { variableName: tag }
const TAGS = [
  { key: '–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è', icon: 'üî§' },
  { key: '–ú–∞—Å—Å–∏–≤', icon: 'üìö' },
  { key: '–û–±—å–µ–∫—Ç', icon: 'üì¶' },
  { key: '–§—É–Ω–∫—Ü–∏—è', icon: '‚öôÔ∏è' },
  { key: '–¶–≤–µ—Ç', icon: 'üé®' },
  { key: '–ö–æ–Ω—Å—Ç—Ä–∞–Ω—Ç–∞', icon: 'üîí' },
  { key: '–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö', icon: 'üóÑÔ∏è' },
  { key: '–ö–ª—é—á', icon: 'üîë' }
];

function getTagIcon(tag){
  const t = TAGS.find(t => t.key === tag) || TAGS[0];
  return t.icon;
}

function getVariableTag(name){
  return variableTags[name] || '–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è';
}

function setVariableTag(name, tag){
  variableTags[name] = tag;
  try { localStorage.setItem('turtcd_variable_tags', JSON.stringify(variableTags)); } catch(e) {}
  renderVariableRegistry();
  // Update autocomplete dropdown if open
  if (currentAutocomplete && currentAutocomplete.dropdown) {
    const input = currentAutocomplete.input;
    const suggestions = getSimilarValues(input.value, 8);
    const dropdown = createAutocompleteDropdown(input, suggestions);
    dropdown.style.display = 'block';
  }
}

function loadVariableTags(){
  try {
    const raw = localStorage.getItem('turtcd_variable_tags');
    variableTags = raw ? JSON.parse(raw) : {};
  } catch(e) { variableTags = {}; }
}

// Variable name validation: letters/digits/underscores only, no spaces/punctuation, not digits only
function isValidVariableName(name){
  if (!name || typeof name !== 'string') return false;
  const trimmed = name.trim();
  if (trimmed === '') return false;
  // Do not allow only digits and underscores (but allow letters with digits)
  if (/^[\d_]+$/.test(trimmed)) return false;
  // Unicode letters, digits, underscores, but not only digits/underscores
  const pattern = /^[\p{L}\p{N}_]+$/u;
  return pattern.test(trimmed);
}

/* ========== Utils ========== */
function genId(){ return 'b-' + Math.random().toString(36).slice(2,10); }
function el(tag, attrs={}, ...children){
  const e=document.createElement(tag);
  for(const k in attrs){
    if(k === 'className') e.className = attrs[k];
    else if(k === 'onclick') e.setAttribute('onclick', attrs[k]);
    else e[k]=attrs[k];
  }
  children.flat().forEach(c=> typeof c === 'string'? e.appendChild(document.createTextNode(c)) : e.appendChild(c));
  return e;
}

// ========== Unsaved changes helpers ==========
function getProjectSnapshot(){
  // Only persist meaningful, deterministic data for comparison
  // Camera position is excluded as it's auto-saved separately
  const snapshotObj = {
    blocks: projectData.blocks,
    connections: projectData.connections,
    variableTags: (typeof variableTags !== 'undefined') ? variableTags : {}
  };
  try {
    return JSON.stringify(snapshotObj);
  } catch(e) {
    return '';
  }
}
let cameraSaveTimeout = null;
function saveCameraPosition(){
  // Debounce —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã - —Å–æ—Ö—Ä–∞–Ω—è–µ–º —á–µ—Ä–µ–∑ 500ms –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è
  if(cameraSaveTimeout){
    clearTimeout(cameraSaveTimeout);
  }
  cameraSaveTimeout = setTimeout(() => {
    const currentProject = localStorage.getItem('currentProject');
    if(currentProject){
      try {
        const cameraData = {
          x: camera.x,
          y: camera.y,
          scale: camera.scale
        };
        localStorage.setItem(`turtcd_camera_${currentProject}`, JSON.stringify(cameraData));
      } catch(e) {
        console.warn('Failed to save camera position:', e);
      }
    }
    cameraSaveTimeout = null;
  }, 500);
}
function loadCameraPosition(){
  const currentProject = localStorage.getItem('currentProject');
  if(currentProject){
    try {
      const saved = localStorage.getItem(`turtcd_camera_${currentProject}`);
      if(saved){
        const cameraData = JSON.parse(saved);
        if(cameraData.x !== undefined) camera.x = cameraData.x;
        if(cameraData.y !== undefined) camera.y = cameraData.y;
        if(cameraData.scale !== undefined) camera.scale = cameraData.scale;
        updateCamera();
      }
    } catch(e) {
      console.warn('Failed to load camera position:', e);
    }
  }
}

function markProjectSaved(){
  _savedSnapshot = getProjectSnapshot();
  updateSaveStatusIndicator();
}

function hasUnsavedChanges(){
  if (_savedSnapshot === null) return true; // if never saved
  return getProjectSnapshot() !== _savedSnapshot;
}
function updateCamera(){ 
  mainCanvas.style.transform = `translate(${camera.x}px,${camera.y}px) scale(${camera.scale})`;
}
// Update dropdown position during panning so it doesn't move away
const _origUpdateCamera = updateCamera;
updateCamera = function(){
  _origUpdateCamera();
  if (currentAutocomplete && currentAutocomplete.dropdown && currentAutocomplete.dropdown._positionDropdown) {
    currentAutocomplete.dropdown._positionDropdown();
  }
}

/* Autocomplete for value fields */
function saveValueToHistory(value) {
  if (!value || value.trim() === '') return;
  if (!isValidVariableName(value)) return;
  
  const trimmedValue = value.trim();
  if (valueHistory.has(trimmedValue)) {
    valueHistory.set(trimmedValue, valueHistory.get(trimmedValue) + 1);
  } else {
    valueHistory.set(trimmedValue, 1);
  }
  
  // Save to localStorage for persistence
  localStorage.setItem('turtcd_value_history', JSON.stringify(Array.from(valueHistory.entries())));
}

function loadValueHistory() {
  // Collect values only from 'value' type fields in current project
  valueHistory.clear();
  
  projectData.blocks.forEach(block => {
    const cfg = findCfg(block.template);
    if (!cfg || !cfg.fields || !block.fields) return;
    
    cfg.fields.forEach(f => {
      if (f.type !== 'value') return;
      const v = block.fields[f.name];
      if (!v || typeof v !== 'string') return;
      const trimmedValue = v.trim();
      if (trimmedValue === '') return;
      if (!isValidVariableName(trimmedValue)) return;
      if (valueHistory.has(trimmedValue)) {
        valueHistory.set(trimmedValue, valueHistory.get(trimmedValue) + 1);
      } else {
        valueHistory.set(trimmedValue, 1);
      }
    });
  });

  renderVariableRegistry();
}

function renderVariableRegistry(){
  const container = document.getElementById('variableRegistry');
  if (!container) return;
  container.innerHTML = '';
  
  // Sort by frequency, then by name
  const entries = Array.from(valueHistory.entries())
    .sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]));
  
  entries.forEach(([name, count]) => {
    const row = el('div', { className: 'var-row' });
    const icon = el('span', { className: 'tag-icon' }, getTagIcon(getVariableTag(name)));
    const n = el('div', { className: 'var-name' }, name);
    const c = el('div', { className: 'var-count' }, `√ó${count}`);
    
    const select = el('select', { className: 'tag-select' });
    TAGS.forEach(t => {
      const opt = el('option', { value: t.key }, t.key);
      if (getVariableTag(name) === t.key) opt.selected = true;
      select.appendChild(opt);
    });
    select.addEventListener('change', (e)=>{
      setVariableTag(name, e.target.value);
    });
    
    // Make variable name clickable to open usage history
    n.style.cursor = 'pointer';
    n.title = '–ö–ª–∏–∫–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –ø—Ä–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∏—Å—Ç–æ—Ä–∏—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è';
    n.addEventListener('click', ()=> {
      showVariableHistory(name);
    });
    
    row.appendChild(icon);
    row.appendChild(n);
    row.appendChild(c);
    row.appendChild(select);
    container.appendChild(row);
  });
}

function getSimilarValues(query, limit = 10) {
  if (!query || query.trim() === '') {
    // If query is empty, show most popular values
    return Array.from(valueHistory.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, limit)
      .map(([value, count]) => ({ value, count }));
  }
  
  const trimmedQuery = query.trim().toLowerCase();
  const results = [];
  
  for (const [value, count] of valueHistory.entries()) {
    const valueLower = value.toLowerCase();
    
    // Show only variables that start with entered text
    if (valueLower.startsWith(trimmedQuery)) {
      results.push({ value, count, similarity: 1.0 });
    }
  }
  
  // Sort by popularity (usage frequency)
  return results
    .sort((a, b) => b.count - a.count)
    .slice(0, limit)
    .map(({ value, count }) => ({ value, count }));
}

function calculateSimilarity(query, target) {
  if (target.includes(query)) {
    // Exact match - highest priority
    return 1.0;
  }
  
  // Check string start
  if (target.startsWith(query)) {
    return 0.8;
  }
  
  // Check substring match
  if (target.includes(query)) {
    return 0.6;
  }
  
  // Simple character similarity check
  let matches = 0;
  for (let i = 0; i < Math.min(query.length, target.length); i++) {
    if (query[i] === target[i]) {
      matches++;
    }
  }
  
  return matches / Math.max(query.length, target.length) * 0.4;
}

function createAutocompleteDropdown(input, suggestions) {
  // Remove existing dropdown
  if (currentAutocomplete && currentAutocomplete.dropdown) {
    currentAutocomplete.dropdown.remove();
    currentAutocomplete = null;
  }
  
  if (suggestions.length === 0) {
    return;
  }
  
  const dropdown = el('div', { className: 'autocomplete-dropdown' });
  
  suggestions.forEach((suggestion, index) => {
    const item = el('div', { 
      className: 'autocomplete-item',
      'data-value': suggestion.value,
      'data-index': index
    });
    
    const icon = el('span', { className: 'tag-icon' }, getTagIcon(getVariableTag(suggestion.value)));
    const valueText = el('span', { className: 'value-text' }, suggestion.value);
    const valueCount = el('span', { className: 'value-count' }, `(${suggestion.count})`);
    
    item.appendChild(icon);
    item.appendChild(valueText);
    item.appendChild(valueCount);
    
    // Handle click
    item.addEventListener('click', () => {
      input.value = suggestion.value;
      input.dispatchEvent(new Event('input', { bubbles: true }));
      hideAutocomplete();
    });
    
    // Handle hover
    item.addEventListener('mouseenter', () => {
      dropdown.querySelectorAll('.autocomplete-item').forEach(el => el.classList.remove('highlighted'));
      item.classList.add('highlighted');
    });
    
    dropdown.appendChild(item);
  });
  
  // Add dropdown to body for proper positioning
  document.body.appendChild(dropdown);
  
  // Universal positioning function next to input
  function positionDropdown(){
    const inputRect = input.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    const dropdownWidth = 300;
    const dropdownHeight = 200;
    
    // Main position: right of field, aligned to top
    let left = inputRect.right + 8;
    let top = inputRect.top;
    
    // If doesn't fit on right, try left of field
    if (left + dropdownWidth > viewportWidth) {
      left = inputRect.left - dropdownWidth - 8;
    }
    // If doesn't fit on left, align to right edge
    if (left < 10) left = Math.max(10, viewportWidth - dropdownWidth - 10);
    
    // Control vertical: if bottom overflows, raise; if top overflows, lower
    if (top + dropdownHeight > viewportHeight) top = Math.max(10, viewportHeight - dropdownHeight - 10);
    if (top < 10) top = 10;
    
    // Constrain coordinates to screen boundaries
    left = Math.max(10, Math.min(left, viewportWidth - dropdownWidth - 10));
    top = Math.max(10, Math.min(top, viewportHeight - dropdownHeight - 10));
    
    dropdown.style.left = left + 'px';
    dropdown.style.top = top + 'px';
  }
  
  // Initial positioning
  positionDropdown();
  
  currentAutocomplete = { input, dropdown };
  
  // Add window resize handler
  const repositionHandler = () => {
    if (currentAutocomplete && currentAutocomplete.dropdown) positionDropdown();
  };
  
  window.addEventListener('resize', repositionHandler);
  window.addEventListener('scroll', repositionHandler, { passive: true });
  document.addEventListener('mousemove', repositionHandler, { passive: true });
  
  // Save handler for later removal
  dropdown._repositionHandler = repositionHandler;
  dropdown._positionDropdown = positionDropdown;
  
  return dropdown;
}

/* ========== Global ignore helpers ========== */
function isGlobalIgnoreEnabled(){
  return !!(projectData && projectData.globalIgnore === true);
}
function setGlobalIgnoreEnabled(v){
  if (!projectData) return;
  projectData.globalIgnore = !!v;
}
function updateGlobalIgnoreButtonState(){
  const btn = document.getElementById('toggleGlobalIgnoreBtn');
  if (!btn) return;
  const enabled = isGlobalIgnoreEnabled();
  btn.textContent = enabled ? '–í—ã–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫' : '–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –æ—à–∏–±–∫–∏';
}
function toggleGlobalIgnore(){
  const enabled = isGlobalIgnoreEnabled();
  if (!enabled){
    openGlobalIgnoreModal();
  } else {
    // Disable global ignore
    setGlobalIgnoreEnabled(false);
    // Remove ignoreIssues from all blocks
    projectData.blocks.forEach(b => { 
      b.ignoreIssues = false;
      const blockEl = mainCanvas.querySelector(`.block[data-block-id="${b.id}"]`);
      if(blockEl) applyBlockIgnoreIssuesState(blockEl, b);
    });
    updateIssues();
    // After panel update, unlock problematic blocks and report
    unlockLockedProblematicBlocksAndReport();
  }
}
function openGlobalIgnoreModal(){
  const modal = document.getElementById('globalIgnoreModal');
  const btn = document.getElementById('confirmGlobalIgnoreBtn');
  if (!modal || !btn) return;
  modal.style.display = 'block';
  let countdown = 10;
  btn.disabled = true;
  btn.textContent = `–Ø –∑–Ω–∞—é —á—Ç–æ –¥–µ–ª–∞—é (${countdown}—Å)`;
  if (modal._timer) { clearInterval(modal._timer); }
  modal._timer = setInterval(()=>{
    countdown--;
    if (countdown > 0){
      btn.textContent = `–Ø –∑–Ω–∞—é —á—Ç–æ –¥–µ–ª–∞—é (${countdown}—Å)`;
    } else {
      clearInterval(modal._timer);
      modal._timer = null;
      btn.disabled = false;
      btn.textContent = '–Ø –∑–Ω–∞—é —á—Ç–æ –¥–µ–ª–∞—é';
    }
  }, 1000);
}
function closeGlobalIgnoreModal(){
  const modal = document.getElementById('globalIgnoreModal');
  if (!modal) return;
  if (modal._timer){ clearInterval(modal._timer); modal._timer = null; }
  modal.style.display = 'none';
}
function confirmGlobalIgnore(){
  // Enable global ignore
  setGlobalIgnoreEnabled(true);
  // Set ignoreIssues=true for all blocks
  projectData.blocks.forEach(b => { 
    b.ignoreIssues = true;
    const blockEl = mainCanvas.querySelector(`.block[data-block-id="${b.id}"]`);
    if(blockEl) applyBlockIgnoreIssuesState(blockEl, b);
  });
  closeGlobalIgnoreModal();
  updateIssues();
}

 

// Unlocks blocks with non-ignored issues and shows notification with count
function unlockLockedProblematicBlocksAndReport(){
  const panel = document.getElementById('issuesPanel');
  if (!panel) return;
  const problematicIds = new Set();
  panel.querySelectorAll('.issue').forEach(n => {
    const bid = n.dataset && n.dataset.blockId;
    if (bid && !n.classList.contains('ignored')) {
      problematicIds.add(bid);
    }
  });
  let removed = 0;
  problematicIds.forEach(bid => {
    const bd = projectData.blocks.find(b => b.id === bid);
    if (bd && bd.locked){
      bd.locked = false;
      const el = mainCanvas.querySelector(`.block[data-block-id="${bid}"]`);
      if (el) applyBlockLockState(el, bd);
      removed++;
    }
  });
  if (removed > 0){
    showNotification('error', '–°–Ω—è—Ç–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫', `–°–Ω—è—Ç–æ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫ —Å –ø—Ä–æ–±–ª–µ–º–Ω—ã—Ö –±–ª–æ–∫–æ–≤: ${removed}`);
  } else {
    showNotification('success', '–°–Ω—è—Ç–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫', '–°–Ω–∏–º–∞—Ç—å –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –Ω–µ –ø–æ—Ç—Ä–µ–±–æ–≤–∞–ª–æ—Å—å');
  }
}

function showAutocomplete(input) {
  const query = input.value;
  const suggestions = getSimilarValues(query, 8);
  
  if (suggestions.length > 0) {
    const dropdown = createAutocompleteDropdown(input, suggestions);
    dropdown.style.display = 'block';
  }
}

function hideAutocomplete() {
  if (currentAutocomplete && currentAutocomplete.dropdown) {
    // Remove event handlers
    if (currentAutocomplete.dropdown._repositionHandler) {
      window.removeEventListener('resize', currentAutocomplete.dropdown._repositionHandler);
      window.removeEventListener('scroll', currentAutocomplete.dropdown._repositionHandler);
    }
    
    currentAutocomplete.dropdown.remove();
    currentAutocomplete = null;
  }
}

function handleAutocompleteKeydown(input, event) {
  if (!currentAutocomplete || !currentAutocomplete.dropdown) return;
  
  const items = currentAutocomplete.dropdown.querySelectorAll('.autocomplete-item');
  const highlighted = currentAutocomplete.dropdown.querySelector('.autocomplete-item.highlighted');
  let currentIndex = highlighted ? parseInt(highlighted.dataset.index) : -1;
  
  switch (event.key) {
    case 'ArrowDown':
      event.preventDefault();
      currentIndex = Math.min(currentIndex + 1, items.length - 1);
      break;
    case 'ArrowUp':
      event.preventDefault();
      currentIndex = Math.max(currentIndex - 1, -1);
      break;
    case 'Enter':
      event.preventDefault();
      if (highlighted) {
        input.value = highlighted.dataset.value;
        input.dispatchEvent(new Event('input', { bubbles: true }));
        hideAutocomplete();
      }
      return;
    case 'Escape':
      event.preventDefault();
      hideAutocomplete();
      return;
  }
  
  // Update highlight
  items.forEach((item, index) => {
    item.classList.toggle('highlighted', index === currentIndex);
  });
}

/* ========== Load blocks config (from server) & render palette ========== */
async function loadBlocksConfig(){
  try {
    const r = await fetch('/api/blocks');
    blocksConfig = await r.json();
  } catch(err){
    console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å /api/blocks', err);
    // fallback example config so UI is usable
    blocksConfig = {
      categories: [
        { name: '–û—Å–Ω–æ–≤–Ω—ã–µ', collapsed: false, blocks: [
          { id: 'start', name: 'Start', color: '#0ea5a4', type: 'header', width: 220, height: 60, fields: [] },
          { id: 'print', name: 'Print', color: '#8b5cf6', type: 'classic', width: 160, height: 80, fields: [{ name: 'text', label: 'Text' }] },
        ] }
      ]
    };
  }
  renderPalette();
  renderModsPanel();
}
function renderPalette(){
  const root = document.getElementById('categoriesList');
  root.innerHTML = '';
  const activeMods = getEnabledMods();
  blocksConfig.categories.forEach(cat=>{
    const modId = cat.modId || 'core';
    if (activeMods[modId] === false) return; // Hide categories of disabled mods
    const header = el('div',{className:'category-header'}, el('div',{className:'category-title'}, cat.name), el('div',{className:'collapse-indicator'}, cat.collapsed ? '‚ñ∂' : '‚ñº'));
    const list = el('div',{className:'block-list'});
    if(cat.collapsed) list.style.display='none';
    header.addEventListener('click', ()=>{
      list.style.display = list.style.display === 'none' ? 'block' : 'none';
      const ind = header.querySelector('.collapse-indicator');
      ind.textContent = list.style.display === 'none' ? '‚ñ∂' : '‚ñº';
    });
    cat.blocks.forEach(b=>{
      const item = el('div',{className:'block-item', draggable:true});
      item.dataset.templateId = b.id;
      const dot = el('span',{className:'color-dot'});
      dot.style.background = b.color || '#7f8c8d';
      const name = el('div',{className:'block-name'}, b.name);
      item.appendChild(dot); item.appendChild(name);
      // click create (center-ish)
      item.addEventListener('click', ()=> createFromTemplate(b.id, 200 - camera.x, 200 - camera.y));
      // dragstart - use text/plain for compatibility
      item.addEventListener('dragstart', (ev)=> {
        ev.dataTransfer.setData('text/plain', b.id);
        ev.dataTransfer.effectAllowed = 'copy';
      
      });
    // dragend: no-op cleanup
    item.addEventListener('dragend', ()=>{});
      list.appendChild(item);
    });
    root.appendChild(header);
    root.appendChild(list);
  });
}

/* ========== Mods panel ========== */
function getEnabledMods(){
  if (!Object.keys(enabledMods).length){
    try{
      const raw = localStorage.getItem('turtcd_enabled_mods');
      enabledMods = raw ? JSON.parse(raw) : {};
    }catch(e){ enabledMods = {}; }
  }
  return enabledMods;
}
function setModEnabled(modId, value){
  enabledMods[modId] = value;
  try{ localStorage.setItem('turtcd_enabled_mods', JSON.stringify(enabledMods)); }catch(e){}
  renderModsPanel();
  renderPalette();
  updateGlobalIgnoreButtonState();
}
function enableAllMods(){
  const mods = summarizeMods();
  const state = getEnabledMods();
  mods.forEach(m=>{ state[m.modId] = true; });
  try{ localStorage.setItem('turtcd_enabled_mods', JSON.stringify(state)); }catch(e){}
  enabledMods = state;
  renderModsPanel();
  renderPalette();
  updateGlobalIgnoreButtonState();
}
function disableAllNonCoreMods(){
  const mods = summarizeMods();
  const state = getEnabledMods();
  mods.forEach(m=>{
    if(m.modId === 'core') state[m.modId] = true;
    else state[m.modId] = false;
  });
  try{ localStorage.setItem('turtcd_enabled_mods', JSON.stringify(state)); }catch(e){}
  enabledMods = state;
  renderModsPanel();
  renderPalette();
  updateGlobalIgnoreButtonState();
}
function summarizeMods(){
  const byMod = {};
  for(const cat of (blocksConfig.categories||[])){
    const modId = cat.modId || 'core';
    const modName = cat.modName || (modId==='core'?'–û—Å–Ω–æ–≤–Ω—ã–µ':'–ú–æ–¥');
    if(!byMod[modId]) byMod[modId] = { modId, modName, groups: 0, blocks: 0 };
    byMod[modId].groups += 1;
    byMod[modId].blocks += (cat.blocks||[]).length;
  }
  return Object.values(byMod).sort((a,b)=> a.modId.localeCompare(b.modId));
}
function renderModsPanel(){
  const panel = document.getElementById('modsPanel'); if(!panel) return;
  if(!isShowModsListEnabled()) {
    panel.innerHTML = '';
    return;
  }
  const mods = summarizeMods();
  const state = getEnabledMods();
  // ensure every mod has default enabled=true
  mods.forEach(m=>{ if(!(m.modId in state)) state[m.modId] = true; });
  try{ localStorage.setItem('turtcd_enabled_mods', JSON.stringify(state)); }catch(e){}
  panel.innerHTML = '';
  // Add scrollable class if more than 3 mods
  if(mods.length > 3){
    panel.classList.add('scrollable');
  } else {
    panel.classList.remove('scrollable');
  }
  mods.forEach(m=>{
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = 'space-between';
    row.style.padding = '6px 0';
    const info = document.createElement('div');
    info.textContent = `${m.modName} ‚Äî –≥—Ä—É–ø–ø: ${m.groups}, –±–ª–æ–∫–æ–≤: ${m.blocks}`;
    const toggle = document.createElement('label');
    toggle.style.display = 'inline-flex'; 
    toggle.style.alignItems = 'center'; 
    toggle.style.gap = '8px';
    toggle.style.cursor = 'pointer';
    
    // Create toggle switch
    const switchContainer = document.createElement('div');
    switchContainer.style.position = 'relative';
    switchContainer.style.width = '44px';
    switchContainer.style.height = '24px';
    switchContainer.style.backgroundColor = state[m.modId] !== false ? 'var(--accent)' : 'rgba(255,255,255,0.2)';
    switchContainer.style.borderRadius = '12px';
    switchContainer.style.transition = 'background-color 0.3s ease';
    
    const switchThumb = document.createElement('div');
    switchThumb.style.position = 'absolute';
    switchThumb.style.top = '2px';
    switchThumb.style.left = state[m.modId] !== false ? '22px' : '2px';
    switchThumb.style.width = '20px';
    switchThumb.style.height = '20px';
    switchThumb.style.backgroundColor = '#fff';
    switchThumb.style.borderRadius = '50%';
    switchThumb.style.transition = 'left 0.3s ease';
    switchThumb.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
    
    switchContainer.appendChild(switchThumb);
    
    const span = document.createElement('span'); 
    span.textContent = state[m.modId] !== false ? '–í–∫–ª' : '–í—ã–∫–ª';
    span.style.fontSize = '12px';
    span.style.fontWeight = '500';
    
    // Add click handler
    toggle.addEventListener('click', (e) => {
      e.preventDefault();
      playButtonSound('toggle');
      const newState = !(state[m.modId] !== false);
      setModEnabled(m.modId, newState);
      
      // Update visual state
      switchContainer.style.backgroundColor = newState ? 'var(--accent)' : 'rgba(255,255,255,0.2)';
      switchThumb.style.left = newState ? '22px' : '2px';
      span.textContent = newState ? '–í–∫–ª' : '–í—ã–∫–ª';
    });
    toggle.appendChild(switchContainer); 
    toggle.appendChild(span);
    row.appendChild(info); 
    row.appendChild(toggle);
    panel.appendChild(row);
  });
}

/* ========== Canvas & block creation ========== */
const mainCanvas = document.getElementById('mainCanvas');
 
let _connectionsUpdateFrame = null;
function scheduleConnectionsUpdate(options = {}) {
  const immediate = !!options.immediate;
  if (immediate) {
    if (_connectionsUpdateFrame) {
      cancelAnimationFrame(_connectionsUpdateFrame);
      _connectionsUpdateFrame = null;
    }
    updateConnections();
    return;
  }
  if (_connectionsUpdateFrame) return;
  _connectionsUpdateFrame = requestAnimationFrame(() => {
    _connectionsUpdateFrame = null;
    updateConnections();
  });
}


function createFromTemplate(templateId, x, y){
  const cfg = findCfg(templateId); if(!cfg) return;
  const id = genId();
  const block = {
    id, template: cfg.id, type: cfg.type,
    x: Math.round(x), y: Math.round(y),
    width: cfg.width || 160, height: cfg.height || 80,
    fields: {},
    fieldTypes: {}, // Initialize field types
    ignoreIssues: isGlobalIgnoreEnabled() ? true : false,
    hiddenBy: [],
    collapsedRightBranch: false
  };
  if(cfg.fields) {
    const allFieldsMultiLine = localStorage.getItem('allFieldsMultiLine') === 'true';
    cfg.fields.forEach(f => {
      block.fields[f.name] = '';
      // Use setting to determine default field type
      block.fieldTypes[f.name] = allFieldsMultiLine ? 'multi-line' : 'single-line';
    });
  }
  projectData.blocks.push(block);
  createInstance(block);
  updateCounts();
  updateConnections();
  // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –∑–Ω–∞—á–µ–Ω–∏–π
  loadValueHistory();
  updateSaveStatusIndicator();
}
function findCfg(templateId){
  for(const cat of blocksConfig.categories) for(const b of cat.blocks) if(b.id===templateId) return b;
  return null;
}

/* ========== Connector tooltips ========== */
function allowedConnect(from, to, fromBlockId, toBlockId) {
  const flowchartType = getFlowchartType();
  
  if(flowchartType === 'horizontal'){
    // Horizontal flowchart connection rules:
    // - output (right or right-bottom) can only connect to input (left)
    // - body (right-top) can only connect to input (left)
    // - left cannot be source (cannot connect from left)
    if (!['right', 'right-top', 'right-bottom'].includes(from) || to !== 'left') {
      return false;
    }
  } else {
    // Vertical flowchart connection rules:
    // - output (bottom) can only connect to input (top)
    // - body (right) can only connect to input (top)
    // - top cannot be source (cannot connect from top)
    if (!['bottom', 'right'].includes(from) || to !== 'top') {
      return false;
    }
  }

  // Check collapsed branch (for vertical: right, for horizontal: right-top)
  const bodyConnector = flowchartType === 'horizontal' ? 'right-top' : 'right';
  if (from === bodyConnector && fromBlockId) {
    const fromBlock = projectData.blocks.find(b => b.id === fromBlockId);
    if (fromBlock && fromBlock.collapsedRightBranch) {
      return false;
    }
  }
  
  if (toBlockId && isBlockHidden(toBlockId)) {
    return false;
  }
  
  // Check: cannot attach non-ignored block to body of ignored block
  if (from === bodyConnector && toBlockId) {
    const toBlock = projectData.blocks.find(b => b.id === toBlockId);
    if (toBlock && toBlock.ignored === true) {
      // Check that source block is also ignored
      if (fromBlockId) {
        const fromBlock = projectData.blocks.find(b => b.id === fromBlockId);
        if (!fromBlock || fromBlock.ignored !== true) {
          return false; // Cannot attach non-ignored block to body of ignored block
        }
      }
    }
  }
  
  return true;
}

function hasConnectorConnection(blockEl, connectorPosition) {
  if (!blockEl || !blockEl.dataset.blockId) return { hasConnection: false, isValid: true };
  const blockId = blockEl.dataset.blockId;
  
  // Check if there are connections where this connector is used as source (from)
  const outgoingConnections = projectData.connections.filter(c => 
    c.from === blockId && c.fromConnector === connectorPosition
  );
  
  // Check if there are connections where this connector is used as destination (to)
  const incomingConnections = projectData.connections.filter(c => 
    c.to === blockId && c.toConnector === connectorPosition
  );
  
  const hasConnection = outgoingConnections.length > 0 || incomingConnections.length > 0;
  
  // Check connection validity
  let isValid = true;
  if (hasConnection) {
    // Check all outgoing connections
    for (const conn of outgoingConnections) {
      const toBlock = projectData.blocks.find(b => b.id === conn.to);
      if (!allowedConnect(conn.fromConnector, conn.toConnector, conn.from, conn.to)) {
        isValid = false;
        break;
      }
    }
    // Check all incoming connections
    if (isValid) {
      for (const conn of incomingConnections) {
        const fromBlock = projectData.blocks.find(b => b.id === conn.from);
        if (!allowedConnect(conn.fromConnector, conn.toConnector, conn.from, conn.to)) {
          isValid = false;
          break;
        }
      }
    }
  }
  
  return { hasConnection, isValid };
}

function getBlockStatusColor(blockEl, blockData) {
  if (!blockEl) return null;
  const ignored = blockEl.classList.contains('block-ignored') || (blockData && (blockData.ignored === true || blockData.ignoreIssues === true));
  if (ignored || isGlobalIgnoreEnabled()) {
    return '#ffffff';
  }
  if (blockEl.classList.contains('block-error') || blockEl.classList.contains('block-warning')) {
    return '#ff4d4f';
  }
  return null;
}

function updateConnectorTooltipColor(tooltip, blockEl, connectionState) {
  if (!tooltip) return;
  
  const blockId = blockEl && blockEl.dataset ? blockEl.dataset.blockId : null;
  const blockData = blockId ? projectData.blocks.find(b => b.id === blockId) : null;
  const statusColor = getBlockStatusColor(blockEl, blockData);
  if (statusColor) {
    tooltip.style.color = statusColor;
    return;
  }
  
  const hasConnection = connectionState ? !!connectionState.hasConnection : false;
  const isValid = connectionState ? !!connectionState.isValid : false;
  
  if (hasConnection) {
    tooltip.style.color = isValid ? '#00ff00' : '#ff4d4f';
  } else {
    tooltip.style.color = '#ffd700';
  }
}

function addFieldTooltip(input, fieldName) {
  const tooltip = document.createElement('div');
  tooltip.className = 'field-tooltip';
  tooltip.textContent = `{${fieldName}}`;
  document.body.appendChild(tooltip);
  
  function updateTooltipColor() {
    const isEmpty = !input.value || input.value.trim() === '';
    if (isEmpty) {
      tooltip.style.color = '#ffd700'; // yellow for empty field
    } else {
      tooltip.style.color = '#00ff00'; // green for filled field
    }
  }
  
  function updateTooltipPosition() {
    const rect = input.getBoundingClientRect();
    tooltip.style.left = (rect.left + rect.width / 2) + 'px';
    tooltip.style.top = (rect.top - 4) + 'px';
  }
  
  input.addEventListener('mouseenter', () => {
    if(!isShowFieldLabelsEnabled()) return;
    updateTooltipColor();
    updateTooltipPosition();
    tooltip.classList.add('show');
  });
  
  input.addEventListener('mouseleave', () => {
    tooltip.classList.remove('show');
  });
  
  input.addEventListener('mousemove', () => {
    if (tooltip.classList.contains('show')) {
      updateTooltipPosition();
    }
  });
  
  // Update tooltip color when field value changes
  input.addEventListener('input', () => {
    if (tooltip.classList.contains('show')) {
      updateTooltipColor();
    }
  });
  
  // Save tooltip reference in input for later updates
  input._tooltip = tooltip;
}

function addConnectorTooltip(connector, position, text) {
  const tooltip = document.createElement('div');
  tooltip.className = `connector-tooltip connector-tooltip-${position}`;
  tooltip.textContent = text;
  document.body.appendChild(tooltip);
  connector.dataset.connectorPosition = position;
  
  function updateTooltipPosition() {
    const rect = connector.getBoundingClientRect();
    
    if (position === 'top') {
      tooltip.style.left = (rect.left + rect.width / 2) + 'px';
      tooltip.style.top = (rect.top - 4) + 'px';
    } else if (position === 'bottom') {
      tooltip.style.left = (rect.left + rect.width / 2) + 'px';
      tooltip.style.top = (rect.bottom + 8) + 'px';
    } else if (position === 'right') {
      tooltip.style.left = (rect.right + 8) + 'px';
      tooltip.style.top = (rect.top + rect.height / 2) + 'px';
      tooltip.style.transform = 'translateY(-50%)';
      tooltip.style.transformOrigin = 'left center';
    } else if (position === 'left') {
      tooltip.style.left = (rect.left - 8) + 'px';
      tooltip.style.top = (rect.top + rect.height / 2) + 'px';
      tooltip.style.transform = 'translate(-100%, -50%)';
      tooltip.style.transformOrigin = 'right center';
    } else if (position === 'right-top') {
      tooltip.style.left = (rect.right + 8) + 'px';
      tooltip.style.top = (rect.top + rect.height * 0.3) + 'px';
      tooltip.style.transform = 'translateY(-50%)';
      tooltip.style.transformOrigin = 'left center';
    } else if (position === 'right-bottom') {
      tooltip.style.left = (rect.right + 8) + 'px';
      tooltip.style.top = (rect.top + rect.height * 0.7) + 'px';
      tooltip.style.transform = 'translateY(-50%)';
      tooltip.style.transformOrigin = 'left center';
    }
  }
  
  connector.addEventListener('mouseenter', () => {
    const blockEl = connector.closest('.block');
    const connectionState = hasConnectorConnection(blockEl, position);
    updateConnectorTooltipColor(tooltip, blockEl, connectionState);
    updateTooltipPosition();
    tooltip.classList.add('show');
  });
  
  connector.addEventListener('mouseleave', () => {
    tooltip.classList.remove('show');
  });
  
  connector.addEventListener('mousemove', () => {
    if (tooltip.classList.contains('show')) {
      const blockEl = connector.closest('.block');
      const connectionState = hasConnectorConnection(blockEl, position);
      updateConnectorTooltipColor(tooltip, blockEl, connectionState);
      updateTooltipPosition();
    }
  });
  
  // Save tooltip reference in connector for later updates
  connector.dataset.tooltipElement = 'true';
  connector._tooltip = tooltip;
}

function createInstance(blockData){
  const cfg = findCfg(blockData.template);
  const isBranchBlock = cfg && (cfg.type === 'condition' || cfg.type === 'loop');
  const wrapper = el('div', { className: 'block' });
  wrapper.style.left = blockData.x + 'px';
  wrapper.style.top = blockData.y + 'px';
  wrapper.style.background = cfg?.color || '#2a4f6b';
  wrapper.dataset.blockId = blockData.id;
  wrapper.dataset.blockType = blockData.type || (cfg && cfg.type) || 'classic';

  const displayName = blockData.displayName || blockData.name || cfg?.name || ('Block ' + blockData.template);
  wrapper.dataset.blockName = displayName;
  const header = el('div', { className: 'block-header' }, displayName);
  const content = el('div', { className: 'block-content' });

  // indicator (top-right)
  const indicator = el('div', { className: 'block-indicator' });
  indicator.setAttribute('aria-hidden', 'true');

  // lock indicator (top-right)
  const lockIndicator = el('div', { className: 'block-lock-indicator', title: '–ë–ª–æ–∫ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω' }, 'üîí');
  lockIndicator.style.position = 'absolute';
  lockIndicator.style.top = '6px';
  lockIndicator.style.right = '6px';
  lockIndicator.style.width = '18px';
  lockIndicator.style.height = '18px';
  lockIndicator.style.display = 'none';
  lockIndicator.style.alignItems = 'center';
  lockIndicator.style.justifyContent = 'center';
  lockIndicator.style.fontSize = '12px';
  lockIndicator.style.background = 'rgba(0,0,0,0.35)';
  lockIndicator.style.borderRadius = '4px';
  lockIndicator.style.pointerEvents = 'none';

  // ignore issues indicator (top-right, left of lock indicator)
  const ignoreIssuesIndicator = el('div', { className: 'block-ignore-issues-indicator', title: '–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –≤–∫–ª—é—á–µ–Ω–æ' }, 'üêõ');
  ignoreIssuesIndicator.style.position = 'absolute';
  ignoreIssuesIndicator.style.top = '6px';
  ignoreIssuesIndicator.style.width = '18px';
  ignoreIssuesIndicator.style.height = '18px';
  ignoreIssuesIndicator.style.display = 'none';
  ignoreIssuesIndicator.style.alignItems = 'center';
  ignoreIssuesIndicator.style.justifyContent = 'center';
  ignoreIssuesIndicator.style.fontSize = '12px';
  ignoreIssuesIndicator.style.background = 'rgba(0,0,0,0.35)';
  ignoreIssuesIndicator.style.borderRadius = '4px';
  ignoreIssuesIndicator.style.pointerEvents = 'none';

  if(cfg && cfg.fields && cfg.fields.length){
    cfg.fields.forEach(f=>{
      // Determine field type: single-line by default if not specified otherwise
      const isMultiLine = blockData.fieldTypes && blockData.fieldTypes[f.name] === 'multi-line';
      const inputType = isMultiLine ? 'textarea' : 'input';
      const inputClass = isMultiLine ? 'field-input multi-line' : 'field-input single-line';
      
      const input = el(inputType, { 
        className: inputClass, 
        placeholder: f.placeholder || f.label || f.name, 
        value: blockData.fields[f.name] || '' 
      });
      if (blockData.locked) { input.disabled = true; }
      
      // Auto-resize only for textarea
      function autoResize(textarea) {
        if (textarea.tagName === 'TEXTAREA') {
          textarea.style.height = 'auto';
          const newHeight = Math.min(textarea.scrollHeight, 200);
          textarea.style.height = newHeight + 'px';
          
          // Save height in block data
          if (!blockData.fieldHeights) {
            blockData.fieldHeights = {};
          }
          blockData.fieldHeights[f.name] = newHeight;
          
          // Update connections after size change
          updateConnections();
        }
      }
      
      // Initialize size with restored saved height (only for textarea)
      if (input.tagName === 'TEXTAREA') {
        if (blockData.fieldHeights && blockData.fieldHeights[f.name]) {
          // Restore saved height
          const savedHeight = blockData.fieldHeights[f.name];
          input.style.height = Math.min(savedHeight, 200) + 'px';
          // Update connections after height restoration (with small delay for rendering completion)
          setTimeout(() => updateConnections(), 10);
        } else {
          // Auto-fit size
          autoResize(input);
        }
        
        // Manual resize handler
        let resizeTimeout;
        const saveHeight = () => {
          const currentHeight = parseInt(input.style.height) || input.offsetHeight;
          if (!blockData.fieldHeights) {
            blockData.fieldHeights = {};
          }
          blockData.fieldHeights[f.name] = currentHeight;
          // Update connections after size change
          updateConnections();
        };
        
        input.addEventListener('resize', saveHeight);
        
        // Additional handler for tracking size changes
        input.addEventListener('mouseup', () => {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => {
            saveHeight();
            // Additional connection update after resize completion
            updateConnections();
          }, 100);
        });
      }
      
      
      // Add autocomplete for fields with type 'value'
      if (f.type === 'value') {
        // Input handling with autocomplete
        let autocompleteTimeout;
        input.addEventListener('input', (e)=> {
          blockData.fields[f.name] = e.target.value;
          autoResize(e.target);
          updateCounts();
          
          // Update value history on each change
          loadValueHistory();
          updateSaveStatusIndicator();
          
          // Show autocomplete with delay
          clearTimeout(autocompleteTimeout);
          autocompleteTimeout = setTimeout(() => {
            if (e.target.value.length > 0) {
              showAutocomplete(e.target);
            } else {
              hideAutocomplete();
            }
          }, 300);
        });
        
        // Focus handling
        input.addEventListener('focus', (e) => {
          if (e.target.value.length > 0) {
            showAutocomplete(e.target);
          }
        });
        
        // Blur handling
        input.addEventListener('blur', (e) => {
          // Small delay so click on autocomplete item can fire
          setTimeout(() => {
            hideAutocomplete();
          }, 150);
        });
        
        // Keyboard handling
        input.addEventListener('keydown', (e) => {
          // Handle auto-complete quotes first (if enabled)
          if (isAutoCompleteQuotesEnabled()) {
            handleAutoCompleteQuotes(e);
            // If auto-complete prevented default, don't process autocomplete
            if (e.defaultPrevented) return;
          }
          handleAutocompleteKeydown(e.target, e);
        });
        
        // Update history on blur
        input.addEventListener('blur', (e) => {
          // Update history from current project
          loadValueHistory();
        });
      } else {
        // Normal handling for other fields
        input.addEventListener('input', (e)=> {
          blockData.fields[f.name] = e.target.value;
          autoResize(e.target);
          updateCounts();
          updateSaveStatusIndicator();
          // Do not update value history for autocomplete for non-value fields
        });
        
        // Add auto-complete for quotes and brackets if enabled (for non-value fields)
        if (isAutoCompleteQuotesEnabled()) {
          input.addEventListener('keydown', handleAutoCompleteQuotes);
        }
      }
      
      // Add tooltip with field name (use placeholder or label)
      const fieldDisplayName = f.placeholder || f.label || f.name;
      addFieldTooltip(input, fieldDisplayName);
      
      content.appendChild(input);
    });
  } else {
    content.appendChild(el('div',{className:'small'}, cfg?.type || ''));
  }

  // connectors
  const flowchartType = getFlowchartType();
  if(flowchartType === 'horizontal'){
    // Horizontal flowchart: input on left, output on right
    if(!cfg || cfg.type !== 'header') {
      const leftConnector = Object.assign(document.createElement('div'), { className: 'connector connector-left' });
      addConnectorTooltip(leftConnector, 'left', '<input>');
      wrapper.appendChild(leftConnector);
    }
    // right connector for output
    if(isBranchBlock) {
      // If branch block: body on right-top, output on right-bottom
      const rightTopConnector = Object.assign(document.createElement('div'), { className: 'connector connector-right connector-right-top' });
      addConnectorTooltip(rightTopConnector, 'right-top', '<body>');
      wrapper.appendChild(rightTopConnector);
      const rightBottomConnector = Object.assign(document.createElement('div'), { className: 'connector connector-right connector-right-bottom' });
      addConnectorTooltip(rightBottomConnector, 'right-bottom', '<output>');
      wrapper.appendChild(rightBottomConnector);
    } else {
      // Regular block: output on right
      const rightConnector = Object.assign(document.createElement('div'), { className: 'connector connector-right' });
      addConnectorTooltip(rightConnector, 'right', '<output>');
      wrapper.appendChild(rightConnector);
    }
  } else {
    // Vertical flowchart: input on top, output on bottom
    if(!cfg || cfg.type !== 'header') {
      const topConnector = Object.assign(document.createElement('div'), { className: 'connector connector-top' });
      addConnectorTooltip(topConnector, 'top', '<input>');
      wrapper.appendChild(topConnector);
    }
    const bottomConnector = Object.assign(document.createElement('div'), { className: 'connector connector-bottom' });
    addConnectorTooltip(bottomConnector, 'bottom', '<output>');
    wrapper.appendChild(bottomConnector);
    // right connector for branching/loop blocks
    if(isBranchBlock) {
      const rightConnector = Object.assign(document.createElement('div'), { className: 'connector connector-right' });
      addConnectorTooltip(rightConnector, 'right', '<body>');
      wrapper.appendChild(rightConnector);
    }
  }
  
  // Add flowchart type class to wrapper
  wrapper.classList.add(`flowchart-${flowchartType}`);

  if (isBranchBlock) {
    applyRightConnectorState(wrapper, blockData);
  }

  wrapper.appendChild(indicator);
  wrapper.appendChild(lockIndicator);
  wrapper.appendChild(ignoreIssuesIndicator);
  wrapper.appendChild(header);
  wrapper.appendChild(content);

  // drag move block (start only when click NOT on input and NOT on connector)
  wrapper.addEventListener('mousedown', (ev)=>{
    // if user clicked on input or contenteditable or on connector - don't start move
    const target = ev.target;
    if(target.closest('input,textarea,[contenteditable="true"]')) return;
    if(target.closest('.connector')) return;
    // if block locked - do not allow move
    if (blockData.locked) return;
    // if Ctrl key is pressed - do not allow move (for camera panning)
    if (ev.ctrlKey) return;
    
    // Check if block is in selection
    const bid = wrapper.dataset.blockId;
    const isInSelection = selectionState && selectionState.selectedBlockIds.has(bid);
    
    // If block is in selection, hide selection area but keep block list
    if(isInSelection && selectionState.areaEl) {
      selectionState.areaEl.style.display = 'none';
    }
    
    // start dragging
    document.body.style.userSelect = 'none';
    const bd = projectData.blocks.find(b => b.id === bid);
    
    // Save initial positions of all selected blocks for dragging
    const selectedBlockInitialPositions = new Map();
    if(isInSelection && selectionState) {
      selectionState.selectedBlockIds.forEach(selectedBlockId => {
        const selectedBlock = projectData.blocks.find(b => b.id === selectedBlockId);
        if(selectedBlock && !selectedBlock.locked) {
          selectedBlockInitialPositions.set(selectedBlockId, { x: selectedBlock.x, y: selectedBlock.y, block: selectedBlock });
        }
      });
    }
    
    dragState = { 
      el: wrapper, 
      startX: ev.clientX, 
      startY: ev.clientY, 
      left: parseFloat(wrapper.style.left || 0), 
      top: parseFloat(wrapper.style.top || 0),
      initialX: bd ? bd.x : parseFloat(wrapper.style.left || 0),
      initialY: bd ? bd.y : parseFloat(wrapper.style.top || 0),
      isDraggingSelection: isInSelection,
      selectedBlockInitialPositions: selectedBlockInitialPositions,
      blockId: bid,
      blockData: bd || null,
      blockCfg: cfg || null,
      snappedPosition: null,
      snappedToBlock: null,
      snappedToConnector: null,
      wasMovedWithShift: false
    };
  });

  mainCanvas.appendChild(wrapper);
  attachBlockConnectionDescriptionHover(wrapper);
  // apply initial lock state
  applyBlockLockState(wrapper, blockData);
  // apply initial ignored state
  if (blockData.ignored === true) {
    wrapper.classList.add('block-ignored');
  }
  applyBlockVisibility(blockData.id);
  
  // Update connections after adding block to canvas (with small delay for rendering completion)
  setTimeout(() => {
    updateConnections();
  }, 10);
}

/* ========== Drag move handler & camera ========== */
document.addEventListener('mousemove', (e)=>{
  // dragging a block
  if(dragState){
    const dx = e.clientX - dragState.startX, dy = e.clientY - dragState.startY;
    let nx = dragState.left + dx, ny = dragState.top + dy;
    
    // Auto-snap to connectors if enabled
    if(isAutoSnapBlocksEnabled() && !dragState.isDraggingSelection){
      const UNSNAP_DISTANCE = 80;
      if(dragState.snappedPosition){
        // If Shift is held and block is snapped, allow movement with constraints
        if(e.shiftKey && dragState.snappedToBlock && dragState.snappedToConnector){
          // Mark that block is being moved with Shift
          dragState.wasMovedWithShift = true;
          
          const spacing = getBlockSpacing();
          const flowchartType = getFlowchartType();
          const snappedToBlockData = projectData.blocks.find(b => b.id === dragState.snappedToBlock);
          const snappedToBlockEl = mainCanvas.querySelector(`.block[data-block-id="${dragState.snappedToBlock}"]`);
          
          if(snappedToBlockData && snappedToBlockEl){
            const snappedToBlockRect = snappedToBlockEl.getBoundingClientRect();
            const draggedBlockRect = dragState.el.getBoundingClientRect();
            
            // Check if snapped to output connector
            // Horizontal: right (not right-top) or right-bottom
            // Vertical: bottom
            const isOutputConnector = flowchartType === 'horizontal' 
              ? (dragState.snappedToConnector === 'right' || dragState.snappedToConnector === 'right-bottom')
              : (dragState.snappedToConnector === 'bottom');
            
            // Check if snapped to body connector
            // Horizontal: right-top
            // Vertical: right
            const isBodyConnector = flowchartType === 'horizontal'
              ? (dragState.snappedToConnector === 'right-top')
              : (dragState.snappedToConnector === 'right');
            
            if(isOutputConnector){
              // Output connector: allow movement only on Y axis, keep X from snap position
              nx = dragState.snappedPosition.x;
              // Y can move freely (ny is already calculated from mouse movement)
            } else if(isBodyConnector){
              // Body connector: allow movement only on Y axis, but maintain minimum X distance
              const bodySpacing = spacing * 1.5;
              let minX;
              
              if(flowchartType === 'horizontal'){
                // Horizontal: maintain spacing on X axis (body connector is on right-top)
                minX = snappedToBlockData.x + snappedToBlockRect.width + bodySpacing;
              } else {
                // Vertical: maintain spacing on X axis (body connector is on right)
                minX = snappedToBlockData.x + snappedToBlockRect.width + bodySpacing;
              }
              
              // Fix X at minimum distance, allow Y movement only
              nx = minX;
              // Y can move freely (ny is already calculated from mouse movement)
            }
          }
        } else {
          // Normal snap behavior: check distance from snap position
          // If block was previously snapped (moved with Shift), restore to snap position
          // Only unsnap if moved far away from snap position WITHOUT Shift
          const distanceFromSnap = Math.sqrt(
            Math.pow(nx - dragState.snappedPosition.x, 2) + 
            Math.pow(ny - dragState.snappedPosition.y, 2)
          );
          
          // Check if block was moved with Shift (track this in dragState)
          const wasMovedWithShift = dragState.wasMovedWithShift || false;
          
          if(distanceFromSnap > UNSNAP_DISTANCE && !wasMovedWithShift){
            // Moved far away without Shift - unsnap
            dragState.snappedPosition = null;
            dragState.snappedToBlock = null;
            dragState.snappedToConnector = null;
            dragState.wasMovedWithShift = false;
          } else {
            // Keep snapped: restore to snap position
            // If was moved with Shift, always restore to snap position
            nx = dragState.snappedPosition.x;
            ny = dragState.snappedPosition.y;
            // Clear the flag after restoring
            dragState.wasMovedWithShift = false;
          }
        }
      } else {
        const snapped = findSnapPosition(dragState.el, nx, ny);
        if(snapped){
          dragState.snappedPosition = {x: snapped.x, y: snapped.y};
          dragState.snappedToBlock = snapped.toBlockId;
          dragState.snappedToConnector = snapped.toConnector;
          nx = snapped.x;
          ny = snapped.y;
        }
      }
    } else {
      if(dragState.snappedPosition) {
        dragState.snappedPosition = null;
        dragState.snappedToBlock = null;
        dragState.snappedToConnector = null;
      }
    }
    
    dragState.el.style.left = nx + 'px'; dragState.el.style.top = ny + 'px';
    const bid = dragState.blockId || dragState.el.dataset.blockId;
    const bd = dragState.blockData || projectData.blocks.find(b => b.id === bid);
    if(bd){ 
      bd.x = nx; 
      bd.y = ny;
      
      if(isAutoSnapBlocksEnabled() && isAutoConnectBlocksEnabled() && dragState.snappedPosition){
        scheduleConnectionsUpdate({ immediate: true });
      }
      
      // If dragging selected blocks, move them all together
      if(dragState.isDraggingSelection && dragState.selectedBlockInitialPositions) {
        const offsetX = nx - dragState.initialX;
        const offsetY = ny - dragState.initialY;
        
        dragState.selectedBlockInitialPositions.forEach((initialPos, selectedBlockId) => {
          // Skip main block, it's already moved
          if(selectedBlockId === bid) return;
          
          const selectedBlock = initialPos.block || projectData.blocks.find(b => b.id === selectedBlockId);
          if(selectedBlock && !selectedBlock.locked) {
            selectedBlock.x = initialPos.x + offsetX;
            selectedBlock.y = initialPos.y + offsetY;
            
            // Update visual block position
            const selectedBlockEl = mainCanvas.querySelector(`.block[data-block-id="${selectedBlockId}"]`);
            if(selectedBlockEl) {
              selectedBlockEl.style.left = selectedBlock.x + 'px';
              selectedBlockEl.style.top = selectedBlock.y + 'px';
            }
          }
        });
      } else {
        // If this is condition or loop block AND Shift is held, move entire branch on right connector
        const cfg = dragState.blockCfg || findCfg(bd.template);
        const isConditionOrLoop = cfg && (cfg.type === 'condition' || cfg.type === 'loop');
        
        if(isConditionOrLoop && e.shiftKey) {
          // Calculate offset from initial position
          const offsetX = nx - dragState.initialX;
          const offsetY = ny - dragState.initialY;
          if (!dragState.branchCache || dragState.branchCache.rootId !== bid) {
            dragState.branchCache = {
              rootId: bid,
              ids: collectBranchBlockIds(bid, 'right'),
              blocks: new Map(),
              elements: new Map()
            };
          }
          const branchIds = dragState.branchCache.ids;
          
          // Move all branch blocks by same offset from their initial positions
          for(const branchBlockId of branchIds) {
            if(!dragState.branchCache.blocks.has(branchBlockId)) {
              const branchBlockRef = projectData.blocks.find(b => b.id === branchBlockId);
              dragState.branchCache.blocks.set(branchBlockId, branchBlockRef || null);
            }
            const branchBlock = dragState.branchCache.blocks.get(branchBlockId);
            if(branchBlock) {
              // If initial position not saved yet, save it
              if(!dragState.branchInitialPositions) {
                dragState.branchInitialPositions = new Map();
              }
              if(!dragState.branchInitialPositions.has(branchBlockId)) {
                dragState.branchInitialPositions.set(branchBlockId, { x: branchBlock.x, y: branchBlock.y });
              }
              
              const initialPos = dragState.branchInitialPositions.get(branchBlockId);
              branchBlock.x = initialPos.x + offsetX;
              branchBlock.y = initialPos.y + offsetY;
              
              // Update visual block position
              if(!dragState.branchCache.elements.has(branchBlockId)) {
                dragState.branchCache.elements.set(branchBlockId, mainCanvas.querySelector(`.block[data-block-id="${branchBlockId}"]`) || null);
              }
              const branchEl = dragState.branchCache.elements.get(branchBlockId);
              if(branchEl) {
                branchEl.style.left = branchBlock.x + 'px';
                branchEl.style.top = branchBlock.y + 'px';
              }
            }
          }
        } else if(isConditionOrLoop && !e.shiftKey && dragState.branchInitialPositions) {
          // If Shift released, return branch blocks to original positions
          const branchIds = (dragState.branchCache && dragState.branchCache.ids) || collectBranchBlockIds(bid, 'right');
          for(const branchBlockId of branchIds) {
            let branchBlock = dragState.branchCache && dragState.branchCache.blocks.get(branchBlockId);
            if(!branchBlock) {
              branchBlock = projectData.blocks.find(b => b.id === branchBlockId);
              if(dragState.branchCache && !dragState.branchCache.blocks.has(branchBlockId)) {
                dragState.branchCache.blocks.set(branchBlockId, branchBlock || null);
              }
            }
            if(branchBlock && dragState.branchInitialPositions.has(branchBlockId)) {
              const initialPos = dragState.branchInitialPositions.get(branchBlockId);
              branchBlock.x = initialPos.x;
              branchBlock.y = initialPos.y;
              
              // Update visual block position
              let branchEl = dragState.branchCache && dragState.branchCache.elements.get(branchBlockId);
              if(!branchEl) {
                branchEl = mainCanvas.querySelector(`.block[data-block-id="${branchBlockId}"]`);
                if(dragState.branchCache) {
                  dragState.branchCache.elements.set(branchBlockId, branchEl || null);
                }
              }
              if(branchEl) {
                branchEl.style.left = branchBlock.x + 'px';
                branchEl.style.top = branchBlock.y + 'px';
              }
            }
          }
          // Clear saved positions
          dragState.branchInitialPositions = null;
          dragState.branchCache = null;
        }
      }
    }
    scheduleConnectionsUpdate();
    return; // when dragging block don't pan or update connecting line separately here
  }

  // panning camera
  if(isPanning){
    const dx = e.clientX - panStart.x, dy = e.clientY - panStart.y;
    camera.x = panCameraStart.x + dx; camera.y = panCameraStart.y + dy;
    updateCamera();
    scheduleConnectionsUpdate();
    return;
  }

  // updating connecting temp-line
  if(connecting){
    const rect = mainCanvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const dx = mx - connecting.startX, dy = my - connecting.startY;
    const len = Math.sqrt(dx*dx + dy*dy);
    const ang = Math.atan2(dy,dx);
    connecting.tempLine.style.width = Math.max(len,2) + 'px';
    connecting.tempLine.style.transform = `rotate(${ang}rad)`;
    
    // Highlight/dim connectors
    updateConnectorHighlighting(connecting);
  }
});

// mouseup / end interactions
document.addEventListener('mouseup', (e)=>{
  // Auto-connect if snapped
  if(dragState && dragState.snappedPosition && dragState.snappedToBlock && dragState.snappedToConnector && isAutoConnectBlocksEnabled()){
    const fromId = dragState.snappedToBlock;
    const toId = dragState.blockId || dragState.el.dataset.blockId;
    const fromConnector = dragState.snappedToConnector;
    const flowchartType = getFlowchartType();
    const toConnector = flowchartType === 'horizontal' ? 'left' : 'top';
    
    if(fromId && toId && fromConnector && toConnector){
      if(allowedConnect(fromConnector, toConnector, fromId, toId)){
        const existingConnection = projectData.connections.find(c => 
          c.from === fromId && c.to === toId && c.fromConnector === fromConnector && c.toConnector === toConnector
        );
        
        if(!existingConnection){
          projectData.connections.push({ 
            from: fromId, 
            to: toId, 
            fromConnector: fromConnector, 
            toConnector: toConnector,
            color: 'system'
          });
          updateConnections();
          updateSaveStatusIndicator();
        }
      }
    }
  }
  
  // Clear snap state
  if(dragState && dragState.snappedPosition){
    dragState.snappedPosition = null;
    dragState.snappedToBlock = null;
    dragState.snappedToConnector = null;
  }
  
  // If finished dragging selected blocks, clear selection
  if(dragState && dragState.isDraggingSelection) {
    clearSelection();
  }
  
  // stop dragging
  dragState = null;
  // stop panning
  if(isPanning){
    saveCameraPosition();
  }
  isPanning = false;
  panStart = null;
  panCameraStart = null;

  // cleanup connecting if not finished (if there is a connecting temporary line and mouseup outside connector)
  if(connecting && connecting.tempLine){
    connecting.tempLine.remove();
    connecting = null;
  }
  // Clear connector highlighting
  clearConnectorHighlighting();
  // restore selection
  document.body.style.userSelect = '';
});

// when leaving viewport, cancel panning
document.getElementById('viewport').addEventListener('mouseleave', ()=>{
  if(isPanning){
    saveCameraPosition();
  }
  isPanning = false;
  panStart = null;
  panCameraStart = null;
  // Clear connector highlighting when leaving viewport
  clearConnectorHighlighting();
});

/* ========== Selection area ========== */
function clearSelection() {
  if(selectionState && selectionState.areaEl) {
    selectionState.areaEl.remove();
  }
  // Remove highlight from selected blocks
  mainCanvas.querySelectorAll('.block-selected').forEach(el => {
    el.classList.remove('block-selected');
  });
  // Remove error dimming in panel
  const panel = document.getElementById('issuesPanel');
  if(panel) {
    panel.querySelectorAll('.issue.deemphasized').forEach(n => {
      n.classList.remove('deemphasized');
    });
  }
  selectionState = null;
}

function updateSelectionArea() {
  if(!selectionState) return;
  
  const rect = mainCanvas.getBoundingClientRect();
  const startX = Math.min(selectionState.startX, selectionState.currentX);
  const startY = Math.min(selectionState.startY, selectionState.currentY);
  const width = Math.abs(selectionState.currentX - selectionState.startX);
  const height = Math.abs(selectionState.currentY - selectionState.startY);
  
  if(!selectionState.areaEl) {
    selectionState.areaEl = document.createElement('div');
    selectionState.areaEl.className = 'selection-area';
    mainCanvas.appendChild(selectionState.areaEl);
  }
  
  selectionState.areaEl.style.left = startX + 'px';
  selectionState.areaEl.style.top = startY + 'px';
  selectionState.areaEl.style.width = width + 'px';
  selectionState.areaEl.style.height = height + 'px';
  
  // Check blocks in selected area
  const selectedBlockIds = new Set();
  const rectLeft = startX;
  const rectTop = startY;
  const rectRight = startX + width;
  const rectBottom = startY + height;
  
  mainCanvas.querySelectorAll('.block').forEach(blockEl => {
    const blockRect = blockEl.getBoundingClientRect();
    const canvasRect = mainCanvas.getBoundingClientRect();
    const blockLeft = blockRect.left - canvasRect.left;
    const blockTop = blockRect.top - canvasRect.top;
    const blockRight = blockLeft + blockRect.width;
    const blockBottom = blockTop + blockRect.height;
    
    // Check if block intersects with selection area
    const intersectionLeft = Math.max(blockLeft, rectLeft);
    const intersectionRight = Math.min(blockRight, rectRight);
    const intersectionTop = Math.max(blockTop, rectTop);
    const intersectionBottom = Math.min(blockBottom, rectBottom);
    
    const isStrictSelection = localStorage.getItem('strictBlockSelection') === 'true';
    let shouldSelect = false;
    
    if(isStrictSelection) {
      // Calculate intersection area
      const intersectionWidth = Math.max(0, intersectionRight - intersectionLeft);
      const intersectionHeight = Math.max(0, intersectionBottom - intersectionTop);
      const intersectionArea = intersectionWidth * intersectionHeight;
      
      // Calculate block area
      const blockWidth = blockRight - blockLeft;
      const blockHeight = blockBottom - blockTop;
      const blockArea = blockWidth * blockHeight;
      
      // Block is selected only if at least 30% of its area is in selection
      const MIN_SELECTION_THRESHOLD = 0.3; // 30% of block area must be in selection
      const intersectionRatio = blockArea > 0 ? intersectionArea / blockArea : 0;
      shouldSelect = intersectionRatio >= MIN_SELECTION_THRESHOLD;
    } else {
      // Old logic: simple intersection check
      shouldSelect = blockLeft < rectRight && blockRight > rectLeft && blockTop < rectBottom && blockBottom > rectTop;
    }
    
    if(shouldSelect) {
      const blockId = blockEl.dataset.blockId;
      if(blockId) {
        // Skip hidden blocks - don't add them to selection
        if(!isBlockHidden(blockId)) {
          selectedBlockIds.add(blockId);
          blockEl.classList.add('block-selected');
        }
      }
    } else {
      blockEl.classList.remove('block-selected');
    }
  });
  
  selectionState.selectedBlockIds = selectedBlockIds;
  
  // Check for errors/warnings in selected blocks
  let hasIssues = false;
  selectedBlockIds.forEach(blockId => {
    const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
    if(blockEl && (blockEl.classList.contains('block-error') || blockEl.classList.contains('block-warning'))) {
      hasIssues = true;
    }
  });
  
  // Update selection color
  selectionState.areaEl.classList.remove('has-issues', 'no-issues');
  if(selectedBlockIds.size > 0) {
    selectionState.areaEl.classList.add(hasIssues ? 'has-issues' : 'no-issues');
  }

  // Update summary (implemented in separate function)
  if (typeof updateSelectionSummary === 'function') updateSelectionSummary();
  // Update issues panel so priority in panel reflects immediately on selection/deselection
  if (typeof updateIssues === 'function') updateIssues();
}

// Start selection area
document.getElementById('viewport').addEventListener('mousedown', (e)=>{
  // If click on connector or during panning - don't start selection
  if(e.target.closest('.connector')) return;
  if(e.ctrlKey) return; // Ctrl is used for panning
  if(e.button !== 0) return; // Only left mouse button
  // If block dragging is in progress - don't start selection
  if(dragState) return;
  
  // If click on block - cancel selection but don't start new one
  if(e.target.closest('.block')) {
    clearSelection();
    return;
  }
  
  const rect = mainCanvas.getBoundingClientRect();
  const startX = e.clientX - rect.left;
  const startY = e.clientY - rect.top;
  
  // Clear previous selection before starting new one
  clearSelection();
  
  selectionState = {
    startX,
    startY,
    currentX: startX,
    currentY: startY,
    areaEl: null,
    selectedBlockIds: new Set(),
    isActive: true // Active selection flag
  };
  
  e.preventDefault();
  document.body.style.userSelect = 'none';
});

// Update selection on mouse movement
document.addEventListener('mousemove', (e)=>{
  if(selectionState && selectionState.isActive && !dragState) {
    const rect = mainCanvas.getBoundingClientRect();
    selectionState.currentX = e.clientX - rect.left;
    selectionState.currentY = e.clientY - rect.top;
    updateSelectionArea();
  }
});

// Finish selection
document.addEventListener('mouseup', (e)=>{
  if(selectionState && selectionState.isActive && e.button === 0) {
    // If area is too small, cancel selection
    const width = Math.abs(selectionState.currentX - selectionState.startX);
    const height = Math.abs(selectionState.currentY - selectionState.startY);
    if(width < 5 && height < 5) {
      clearSelection();
    } else {
      // Update area once for final state
      updateSelectionArea();
      // If no blocks in area - don't fix selection, clear it
      if(!selectionState.selectedBlockIds || selectionState.selectedBlockIds.size === 0) {
        clearSelection();
      } else {
        // Fix selection - it remains visible
        // Deactivate active selection mode but keep visualization
        selectionState.isActive = false;
        // Update area once more for final state
        updateSelectionArea();
      }
    }
    document.body.style.userSelect = '';
  }
});

// Context menu for selected area
mainCanvas.addEventListener('contextmenu', (e)=>{
  // If click on block - show block context menu (handled in document.addEventListener('contextmenu'))
  if(e.target.closest('.block')) return;
  
  if(selectionState && selectionState.selectedBlockIds.size > 0) {
    // Check that click was in selection area
    const rect = mainCanvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const clickY = e.clientY - rect.top;
    
    const startX = Math.min(selectionState.startX, selectionState.currentX);
    const startY = Math.min(selectionState.startY, selectionState.currentY);
    const width = Math.abs(selectionState.currentX - selectionState.startX);
    const height = Math.abs(selectionState.currentY - selectionState.startY);
    
    if(clickX >= startX && clickX <= startX + width && clickY >= startY && clickY <= startY + height) {
      e.preventDefault();
      e.stopPropagation(); // Stop propagation so block menu doesn't show
      showSelectionContextMenu(e);
    }
  }
});

function showSelectionContextMenu(e) {
  const menu = document.getElementById('selectionContextMenu');
  const selectedIds = getSelectedBlockIds();
  
  if(selectedIds.length === 0) return;
  
  // Check block statuses
  let allIgnoreIssues = true;
  let allNotIgnoreIssues = true;
  let allIgnored = true;
  let allNotIgnored = true;
  let hasHeader = false;
  
  selectedIds.forEach(blockId => {
    const blockData = projectData.blocks.find(b => b.id === blockId);
    if(blockData) {
      if(blockData.type === 'header') hasHeader = true;
      if(blockData.ignoreIssues !== true) allIgnoreIssues = false;
      if(blockData.ignoreIssues === true) allNotIgnoreIssues = false;
      if(blockData.ignored !== true) allIgnored = false;
      if(blockData.ignored === true) allNotIgnored = false;
    }
  });
  
  // Update ignore issues menu item
  const toggleIgnoreIssuesItem = document.getElementById('toggleIgnoreIssuesMenuItem');
  if(toggleIgnoreIssuesItem) {
    if(allIgnoreIssues) {
      toggleIgnoreIssuesItem.textContent = 'üî¥ –û—Ç–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫';
      toggleIgnoreIssuesItem.style.opacity = '1';
      toggleIgnoreIssuesItem.style.cursor = 'pointer';
    } else {
      // When statuses differ or all not ignored - offer to enable ignoring
      toggleIgnoreIssuesItem.textContent = 'üü¢ –í–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫';
      toggleIgnoreIssuesItem.style.opacity = '1';
      toggleIgnoreIssuesItem.style.cursor = 'pointer';
    }
  }
  
  // Update ignore blocks menu item
  const toggleIgnoreItem = document.getElementById('toggleIgnoreMenuItem');
  if(toggleIgnoreItem) {
    if(hasHeader) {
      toggleIgnoreItem.style.display = 'none';
    } else {
      toggleIgnoreItem.style.display = 'block';
      if(allIgnored) {
        toggleIgnoreItem.textContent = '‚úÖ –û—Ç–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ';
        toggleIgnoreItem.style.opacity = '1';
        toggleIgnoreItem.style.cursor = 'pointer';
      } else {
        // Including for mixed statuses - allow ignoring
        toggleIgnoreItem.textContent = 'üö´ –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å';
        toggleIgnoreItem.style.opacity = '1';
        toggleIgnoreItem.style.cursor = 'pointer';
      }
    }
  }
  
  menu.style.left = e.pageX + 'px';
  menu.style.top = e.pageY + 'px';
  menu.style.display = 'block';
}

// Functions for working with selected blocks
function getSelectedBlockIds() {
  if(!selectionState) return [];
  return Array.from(selectionState.selectedBlockIds);
}

function clearSelectedBlocks() {
  const selectedIds = getSelectedBlockIds();
  selectedIds.forEach(blockId => {
    const blockData = projectData.blocks.find(b => b.id === blockId);
    if(blockData && !blockData.locked) {
      // Initialize fields if not present
      if (!blockData.fields) {
        blockData.fields = {};
      }
      
      // Clear all fields in blockData
      const cfg = findCfg(blockData.template);
      if (cfg && cfg.fields) {
        cfg.fields.forEach(f => {
          blockData.fields[f.name] = '';
        });
      }
      
      // Clear all input fields in block on page
      const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
      if (blockEl) {
        const inputs = blockEl.querySelectorAll('input, textarea');
        inputs.forEach(input => {
          input.value = '';
          
          // Auto-resize for textarea
          if (input.tagName === 'TEXTAREA') {
            input.style.height = 'auto';
            const newHeight = Math.min(input.scrollHeight, 200);
            input.style.height = newHeight + 'px';
          }
        });
      }
    }
  });
  updateConnections();
  updateCounts();
  updateIssues();
  document.getElementById('selectionContextMenu').style.display = 'none';
}

// Updates/creates summary inside selection area (called on issues changes or selection changes)
function updateSelectionSummary(){
  if(!isShowSelectionSummaryEnabled()) {
    const summaryEl = document.querySelector('.selection-summary');
    if(summaryEl) summaryEl.style.display = 'none';
    return;
  }
  if(!selectionState || !selectionState.areaEl || !selectionState.selectedBlockIds) return;
  const selectedBlockIds = selectionState.selectedBlockIds;
  if(selectedBlockIds.size === 0) {
    const s = selectionState.areaEl.querySelector('.selection-summary'); if(s) s.remove();
    return;
  }

  // Calculate metrics: warnings (problems), errors, ignored issues
  // Exclude hidden blocks (blocks in hiddenBy)
  let problems = 0, errors = 0, ignoredIssues = 0;
  // Count total selected blocks (excluding hidden) and ignored blocks
  let totalBlocks = 0, ignoredBlocks = 0;
  
  selectedBlockIds.forEach(blockId => {
    // Skip hidden blocks
    if(isBlockHidden(blockId)) return;
    totalBlocks++;
    
    // Check if block is ignored
    const bdata = projectData.blocks.find(bb => bb.id === blockId);
    if(bdata && (bdata.ignored === true || bdata.ignoreIssues === true)) {
      ignoredBlocks++;
    }
  });
  
  const issuesPanel = document.getElementById('issuesPanel');
  if(issuesPanel) {
    const issueNodes = issuesPanel.querySelectorAll('.issue');
    issueNodes.forEach(node => {
      const bid = node.dataset.blockId;
      if(!bid) return;
      if(!selectedBlockIds.has(bid)) return;
      // Skip hidden blocks
      if(isBlockHidden(bid)) return;
      if(node.classList.contains('ignored')) { ignoredIssues++; return; }
      if(node.classList.contains('error')) { errors++; return; }
      if(node.classList.contains('warning')) { problems++; return; }
    });
  } else {
    // fallback: check block classes in canvas
    selectedBlockIds.forEach(blockId => {
      // Skip hidden blocks
      if(isBlockHidden(blockId)) return;
      const bEl = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
      if(!bEl) return;
      if(bEl.classList.contains('block-error')) { errors++; }
      else if(bEl.classList.contains('block-warning')) { problems++; }
      // ignored status can be on projectData
      const bdata = projectData.blocks.find(bb => bb.id === blockId);
      if(bdata && (bdata.ignored === true || bdata.ignoreIssues === true)) ignoredIssues++;
    });
  }

  // Calculate number of normal blocks (non-ignored)
  const normalBlocks = totalBlocks - ignoredBlocks;

  // create or update summary element
  let summary = selectionState.areaEl.querySelector('.selection-summary');
  if(!summary) {
    summary = document.createElement('div');
    summary.className = 'selection-summary';
    selectionState.areaEl.appendChild(summary);
  }
  // build inner html: use small icons matching right panel (no emoji)
  summary.innerHTML = '';
  const makeItem = (iconHtml, label) => {
    const it = document.createElement('div');
    it.className = 'selection-summary-item';
    const ic = document.createElement('div'); ic.className = 'mini-icon'; ic.innerHTML = iconHtml;
    const txt = document.createElement('div'); txt.className = 'mini-text'; txt.textContent = label;
    it.appendChild(ic); it.appendChild(txt);
    return it;
  };
  // rounded square icon with centered '1'
  const squareSvg = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">'
    + '<rect x="3" y="3" width="18" height="18" rx="4" ry="4" fill="none" stroke="#ffffff" stroke-width="1.4" />'
    + '<text x="12" y="15" text-anchor="middle" font-size="12" font-family="Segoe UI, Arial, sans-serif" fill="#ffffff">1</text>'
    + '</svg>';
  // Build string with block count: "X + Y –±–ª–æ–∫–æ–≤" or just "X –±–ª–æ–∫–æ–≤" if no ignored blocks
  const blocksText = ignoredBlocks > 0 
    ? `${normalBlocks} + ${ignoredBlocks} –±–ª–æ–∫–æ–≤`
    : `${normalBlocks} –±–ª–æ–∫–æ–≤`;
  summary.appendChild(makeItem(squareSvg, blocksText));
  summary.appendChild(makeItem('<span class="mini-warning">!</span>', problems + ' –ø—Ä–æ–±–ª–µ–º'));
  summary.appendChild(makeItem('<span class="mini-error">‚úï</span>', errors + ' –æ—à–∏–±–æ–∫'));
  summary.appendChild(makeItem('<span class="mini-ignored">?</span>', ignoredIssues + ' –∏–≥–Ω–æ—Ä.'));
  // show summary
  summary.style.display = 'flex';
}

function toggleIgnoreIssuesForSelected() {
  const selectedIds = getSelectedBlockIds();
  if(selectedIds.length === 0) return;
  // If at least one block without ignoreIssues -> enable for all; if all already ignored -> disable
  let allIgnoreIssues = true;
  selectedIds.forEach(blockId => {
    const blockData = projectData.blocks.find(b => b.id === blockId);
    if(blockData) {
      if(blockData.ignoreIssues !== true) allIgnoreIssues = false;
    }
  });

  const newState = allIgnoreIssues ? false : true;

  selectedIds.forEach(blockId => {
    const blockData = projectData.blocks.find(b => b.id === blockId);
    if(blockData) {
      blockData.ignoreIssues = newState;
      const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
      if(blockEl) applyBlockIgnoreIssuesState(blockEl, blockData);
    }
  });
  
  updateIssues();
  document.getElementById('selectionContextMenu').style.display = 'none';
}

function deleteSelectedBlocksConnections() {
  const selectedIds = getSelectedBlockIds();
  if(selectedIds.length === 0) return;
  
  // Remove all connections from selected blocks via 'bottom' (output) and 'right' (body) connectors
  const connectionsToDelete = [];
  selectedIds.forEach(blockId => {
    const outgoingConnections = projectData.connections.filter(c => 
      c.from === blockId && (c.fromConnector === 'bottom' || c.fromConnector === 'right')
    );
    connectionsToDelete.push(...outgoingConnections);
  });
  
  // Remove found connections from projectData.connections
  connectionsToDelete.forEach(conn => {
    const index = projectData.connections.findIndex(c => 
      c.from === conn.from && 
      c.to === conn.to && 
      c.fromConnector === conn.fromConnector && 
      c.toConnector === conn.toConnector
    );
    if(index !== -1) {
      projectData.connections.splice(index, 1);
    }
  });
  
  // Update connection visualization
  updateConnections();
  updateCounts();
  document.getElementById('selectionContextMenu').style.display = 'none';
}

function deleteSelectedBlocks() {
  const selectedIds = getSelectedBlockIds();
  if(selectedIds.length === 0) return;
  // Remove selected blocks (and their connections)
  selectedIds.forEach(blockId => {
    // Use existing block deletion function
    performDeleteBlock(blockId);
  });

  // Clear selection state
  if(selectionState && selectionState.areaEl) {
    selectionState.areaEl.remove();
    selectionState = null;
  }

  updateConnections();
  updateCounts();
  updateIssues();
  document.getElementById('selectionContextMenu').style.display = 'none';
}

function toggleIgnoreSelectedBlocks() {
  const selectedIds = getSelectedBlockIds();
  if(selectedIds.length === 0) return;
  // If at least one non-ignored block - set ignoring for all.
  // If all selected are already ignored - remove ignoring.
  let allIgnored = true;
  selectedIds.forEach(blockId => {
    const blockData = projectData.blocks.find(b => b.id === blockId);
    if(blockData && blockData.type !== 'header') {
      if(blockData.ignored !== true) allIgnored = false;
    }
  });

  const newState = allIgnored ? false : true;

  selectedIds.forEach(blockId => {
    const blockData = projectData.blocks.find(b => b.id === blockId);
    if(blockData && blockData.type !== 'header') {
      blockData.ignored = newState;
      const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
      if(blockEl) {
        if(newState) blockEl.classList.add('block-ignored'); else blockEl.classList.remove('block-ignored');
      }
    }
  });
  
  updateIssues();
  document.getElementById('selectionContextMenu').style.display = 'none';
}

// Close selection context menu on click
document.addEventListener('click', (e)=>{
  if(!e.target.closest('#selectionContextMenu')) {
    document.getElementById('selectionContextMenu').style.display = 'none';
  }
});

/* ========== Connecting blocks (temp line & finalize) ========== */
mainCanvas.addEventListener('mousedown', (e)=>{
  const conn = e.target.closest('.connector');
  if(!conn) return;
  const blockEl = conn.closest('.block');
  if(!blockEl) return;
  const blockId = blockEl.dataset.blockId;
  const blockData = projectData.blocks.find(b => b.id === blockId);
  if (blockData && isBlockHidden(blockId)) return;
  if (blockData && conn.classList.contains('connector-right') && blockData.collapsedRightBranch) return;
  e.preventDefault();
  // disable text selection while creating connection
  document.body.style.userSelect = 'none';
  const crect = conn.getBoundingClientRect(), canv = mainCanvas.getBoundingClientRect();
  const startX = crect.left + crect.width/2 - canv.left;
  const startY = crect.top + crect.height/2 - canv.top;
  const tempLine = document.createElement('div');
  tempLine.className = 'connection-line temp-line';
  tempLine.style.left = startX + 'px';
  tempLine.style.top = startY + 'px';
  tempLine.style.width = '0px';
  tempLine.style.transform = 'rotate(0rad)';
  mainCanvas.appendChild(tempLine);
  connecting = { blockEl, connEl: conn, startX, startY, tempLine };
  // Initial connector highlighting
  updateConnectorHighlighting(connecting);
});
mainCanvas.addEventListener('mouseup', (e)=>{
  if(!connecting) return;
  let targetConn = e.target.closest('.connector');
  // If mouseup happened on a block (but not exactly on a connector), snap to its input connector
  if(!targetConn){
    const hoveredBlock = e.target.closest('.block');
    if(hoveredBlock && hoveredBlock !== connecting.blockEl){
      const flowchartType = getFlowchartType();
      targetConn = hoveredBlock.querySelector(flowchartType === 'horizontal' ? '.connector-left' : '.connector-top');
    }
  }
  if(targetConn){
    const toBlock = targetConn.closest('.block');
    if(toBlock && toBlock !== connecting.blockEl){
      const fromId = connecting.blockEl.dataset.blockId, toId = toBlock.dataset.blockId;
      const fromC = connectorType(connecting.connEl), toC = connectorType(targetConn);
      if(allowedConnect(fromC, toC, fromId, toId)){
        projectData.connections.push({ 
          from: fromId, 
          to: toId, 
          fromConnector: fromC, 
          toConnector: toC,
          color: 'system'
        });
        updateConnections();
        updateSaveStatusIndicator();
      }
    }
  }
  // cleanup temp
  if(connecting?.tempLine) connecting.tempLine.remove();
  connecting = null;
  // restore selection
  document.body.style.userSelect = '';
});

/* connector helpers */
function connectorType(el){
  if(el.classList.contains('connector-top')) return 'top';
  if(el.classList.contains('connector-bottom')) return 'bottom';
  if(el.classList.contains('connector-right')) {
    if(el.classList.contains('connector-right-top')) return 'right-top';
    if(el.classList.contains('connector-right-bottom')) return 'right-bottom';
    return 'right';
  }
  if(el.classList.contains('connector-left')) return 'left';
  return '';
}
function findSnapPosition(draggedBlockEl, currentX, currentY){
  if(!draggedBlockEl) return null;
  
  const flowchartType = getFlowchartType();
  const SNAP_DISTANCE = 100;
  const spacing = getBlockSpacing();
  
  const draggedInputConnector = flowchartType === 'horizontal' 
    ? draggedBlockEl.querySelector('.connector-left')
    : draggedBlockEl.querySelector('.connector-top');
  
  if(!draggedInputConnector) return null;
  
  const draggedBlockRect = draggedBlockEl.getBoundingClientRect();
  const draggedInputRect = draggedInputConnector.getBoundingClientRect();
  const draggedInputCenterX = draggedInputRect.left + draggedInputRect.width / 2;
  const draggedInputCenterY = draggedInputRect.top + draggedInputRect.height / 2;
  
  let bestSnap = null;
  let minDistance = SNAP_DISTANCE;
  
  mainCanvas.querySelectorAll('.block').forEach(otherBlockEl => {
    if(otherBlockEl === draggedBlockEl) return;
    
    const otherBlockId = otherBlockEl.dataset.blockId;
    if(!otherBlockId || isBlockHidden(otherBlockId)) return;
    
    let outputConnectors = [];
    if(flowchartType === 'horizontal'){
      const rightConn = otherBlockEl.querySelector('.connector-right:not(.connector-right-top)');
      const rightBottomConn = otherBlockEl.querySelector('.connector-right-bottom');
      if(rightConn) outputConnectors.push({el: rightConn, type: 'right'});
      if(rightBottomConn) outputConnectors.push({el: rightBottomConn, type: 'right-bottom'});
    } else {
      const bottomConn = otherBlockEl.querySelector('.connector-bottom');
      if(bottomConn) outputConnectors.push({el: bottomConn, type: 'bottom'});
    }
    
    outputConnectors.forEach(({el: outputConn, type: outputType}) => {
      const connectorState = hasConnectorConnection(otherBlockEl, outputType);
      if(connectorState.hasConnection) return;
      
      const outputRect = outputConn.getBoundingClientRect();
      const outputCenterX = outputRect.left + outputRect.width / 2;
      const outputCenterY = outputRect.top + outputRect.height / 2;
      
      const distance = Math.sqrt(Math.pow(draggedInputCenterX - outputCenterX, 2) + Math.pow(draggedInputCenterY - outputCenterY, 2));
      
      if(distance < minDistance){
        const otherBlockRect = otherBlockEl.getBoundingClientRect();
        const otherBlockData = projectData.blocks.find(b => b.id === otherBlockId);
        if(!otherBlockData) return;
        
        let snapX = currentX, snapY = currentY;
        
        if(flowchartType === 'horizontal'){
          snapY = otherBlockData.y + (otherBlockRect.height / 2) - (draggedBlockRect.height / 2);
          snapX = otherBlockData.x + otherBlockRect.width + spacing;
        } else {
          snapX = otherBlockData.x + (otherBlockRect.width / 2) - (draggedBlockRect.width / 2);
          snapY = otherBlockData.y + otherBlockRect.height + spacing;
        }
        
        bestSnap = {x: snapX, y: snapY, toBlockId: otherBlockId, toConnector: outputType};
        minDistance = distance;
      }
    });
    
    const bodyConnectorType = flowchartType === 'horizontal' ? 'right-top' : 'right';
    const bodyConnector = flowchartType === 'horizontal'
      ? otherBlockEl.querySelector('.connector-right-top')
      : otherBlockEl.querySelector('.connector-right');
    
    if(bodyConnector){
      const bodyConnectorState = hasConnectorConnection(otherBlockEl, bodyConnectorType);
      if(!bodyConnectorState.hasConnection){
        const draggedBlockId = draggedBlockEl.dataset.blockId;
        if(draggedBlockId){
          const draggedBlockData = projectData.blocks.find(b => b.id === draggedBlockId);
          if(draggedBlockData){
            const draggedInputConnectorType = flowchartType === 'horizontal' ? 'left' : 'top';
            const draggedInputConnectorState = hasConnectorConnection(draggedBlockEl, draggedInputConnectorType);
            
            if(!draggedInputConnectorState.hasConnection){
              const otherBlockData = projectData.blocks.find(b => b.id === otherBlockId);
              if(otherBlockData && !otherBlockData.collapsedRightBranch){
                const bodyRect = bodyConnector.getBoundingClientRect();
                const bodyCenterX = bodyRect.left + bodyRect.width / 2;
                const bodyCenterYScreen = bodyRect.top + bodyRect.height / 2;
                
                const draggedBlockLeft = draggedBlockRect.left;
                const draggedBlockRight = draggedBlockRect.right;
                const draggedBlockTop = draggedBlockRect.top;
                const draggedBlockBottom = draggedBlockRect.bottom;
                
                const closestX = Math.max(draggedBlockLeft, Math.min(bodyCenterX, draggedBlockRight));
                const closestY = Math.max(draggedBlockTop, Math.min(bodyCenterYScreen, draggedBlockBottom));
                
                const distance = Math.sqrt(Math.pow(bodyCenterX - closestX, 2) + Math.pow(bodyCenterYScreen - closestY, 2));
                
                if(distance < minDistance){
                  const otherBlockRect = otherBlockEl.getBoundingClientRect();
                  
                  let snapX = currentX, snapY = currentY;
                  
                  const bodySpacing = spacing * 1.5;
                  snapX = otherBlockData.x + otherBlockRect.width + bodySpacing;
                  
                  const bodyYRelativeToBlock = bodyRect.top - otherBlockRect.top;
                  const bodyCenterYInBlock = bodyYRelativeToBlock + bodyRect.height / 2;
                  const bodyCenterYCanvas = otherBlockData.y + bodyCenterYInBlock;
                  
                  const inputOffsetY = draggedInputRect.top + draggedInputRect.height / 2 - draggedBlockRect.top;
                  
                  snapY = bodyCenterYCanvas + spacing - inputOffsetY;
                  
                  bestSnap = {x: snapX, y: snapY, toBlockId: otherBlockId, toConnector: bodyConnectorType};
                  minDistance = distance;
                }
              }
            }
          }
        }
      }
    }
  });
  
  return bestSnap;
}
function isBlockIgnored(blockId) {
  const block = projectData.blocks.find(b => b.id === blockId);
  return block && block.ignored === true;
}

function isBlockHidden(blockId) {
  const block = projectData.blocks.find(b => b.id === blockId);
  return !!(block && Array.isArray(block.hiddenBy) && block.hiddenBy.length > 0);
}

function applyBlockVisibility(blockId) {
  const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
  if (!blockEl) return;
  const hidden = isBlockHidden(blockId);
  blockEl.style.display = hidden ? 'none' : '';
}

function applyRightConnectorState(blockEl, blockData) {
  if (!blockEl) return;
  const flowchartType = getFlowchartType();
  const rightConnector = flowchartType === 'horizontal' 
    ? blockEl.querySelector('.connector-right-top') 
    : blockEl.querySelector('.connector-right');
  if (!rightConnector) return;
  const isCollapsed = !!blockData.collapsedRightBranch;
  rightConnector.classList.toggle('connector-collapsed', isCollapsed);
  if (rightConnector._tooltip) {
    rightConnector._tooltip.textContent = isCollapsed ? 'hidden...' : '<body>';
    const connectorPos = flowchartType === 'horizontal' ? 'right-top' : 'right';
    const connectionState = hasConnectorConnection(blockEl, connectorPos);
    updateConnectorTooltipColor(rightConnector._tooltip, blockEl, connectionState);
  }
  if (isCollapsed) {
    rightConnector.classList.remove('connector-valid', 'connector-invalid');
  }
}

function collectBranchBlockIds(startBlockId, connectorType = 'right') {
  const result = new Set();
  const stack = [];
  const connections = projectData.connections || [];

  connections
    .filter(c => c.from === startBlockId && c.fromConnector === connectorType)
    .forEach(c => stack.push(c.to));

  while (stack.length) {
    const current = stack.pop();
    if (!current || result.has(current)) continue;
    result.add(current);
    connections
      .filter(c => c.from === current && (c.fromConnector === 'bottom' || c.fromConnector === 'right'))
      .forEach(c => stack.push(c.to));
  }

  return Array.from(result);
}

function setBlockHiddenBy(blockId, sourceId, hidden) {
  const block = projectData.blocks.find(b => b.id === blockId);
  if (!block) return;
  if (!Array.isArray(block.hiddenBy)) {
    block.hiddenBy = [];
  }
  const idx = block.hiddenBy.indexOf(sourceId);
  if (hidden) {
    if (idx === -1) block.hiddenBy.push(sourceId);
  } else if (idx !== -1) {
    block.hiddenBy.splice(idx, 1);
  }
  applyBlockVisibility(blockId);
}

function setBlocksHiddenBy(sourceId, blockIds, hidden) {
  blockIds.forEach(blockId => setBlockHiddenBy(blockId, sourceId, hidden));
}

function updateConnectorHighlighting(connecting) {
  // Clear previous highlighting
  clearConnectorHighlighting();
  
  if (!connecting || !connecting.connEl) return;
  
  const fromConnectorType = connectorType(connecting.connEl);
  const fromBlockId = connecting.blockEl.dataset.blockId;
  
  // Check if source connector already has connection
  const fromConnectorHasConnection = hasConnectorConnection(connecting.blockEl, fromConnectorType).hasConnection;
  if (fromConnectorHasConnection) {
    // If source connector already has connection, dim it
    connecting.connEl.classList.add('connector-invalid');
  }
  
  // Find all connectors on canvas
  const allConnectors = mainCanvas.querySelectorAll('.connector');
  
  allConnectors.forEach(conn => {
    // Skip connector from which we're drawing line
    if (conn === connecting.connEl) return;
    
    const toBlock = conn.closest('.block');
    if (!toBlock || toBlock === connecting.blockEl) return;
    
    const toConnectorType = connectorType(conn);
    const toBlockId = toBlock.dataset.blockId;
    if (isBlockHidden(toBlockId)) return;
    const toBlockData = projectData.blocks.find(b => b.id === toBlockId);
    if (toBlockData && conn.classList.contains('connector-right') && toBlockData.collapsedRightBranch) {
      conn.classList.add('connector-invalid');
      return;
    }
    
    // Check if target connector already has connection
    const toConnectorHasConnection = hasConnectorConnection(toBlock, toConnectorType).hasConnection;
    
    // If target connector already has connection, dim it
    if (toConnectorHasConnection) {
      conn.classList.add('connector-invalid');
    } else {
      // Check if connection is allowed
      if (allowedConnect(fromConnectorType, toConnectorType, fromBlockId, toBlockId)) {
        conn.classList.add('connector-valid');
      } else {
        conn.classList.add('connector-invalid');
      }
    }
  });
}

function clearConnectorHighlighting() {
  mainCanvas.querySelectorAll('.connector').forEach(conn => {
    conn.classList.remove('connector-valid', 'connector-invalid');
  });
}

/* ========== Render connections ========== */
function updateConnections(){
  // remove old visuals (except temp-line) - remove each type separately to ensure all are removed
  mainCanvas.querySelectorAll('.connection-line:not(.temp-line)').forEach(n=>n.remove());
  mainCanvas.querySelectorAll('.connection-point').forEach(n=>n.remove());
  mainCanvas.querySelectorAll('.connection-svg').forEach(n=>n.remove());
  
  // Update canvas rect for SVG sizing
  const canvasRect = mainCanvas.getBoundingClientRect();
  
  // Update tooltip colors for all connectors
  mainCanvas.querySelectorAll('.connector[data-tooltip-element="true"]').forEach(connector => {
    if (connector._tooltip && connector._tooltip.classList.contains('show')) {
      const blockEl = connector.closest('.block');
      const connType = connectorType(connector);
      const connectionState = connType ? hasConnectorConnection(blockEl, connType) : null;
      updateConnectorTooltipColor(connector._tooltip, blockEl, connectionState);
    }
  });
  
  
  // iterate
  projectData.connections.forEach(c=>{
    if (isBlockHidden(c.from) || isBlockHidden(c.to)) return;
    const fromEl = mainCanvas.querySelector(`.block[data-block-id="${c.from}"]`);
    const toEl = mainCanvas.querySelector(`.block[data-block-id="${c.to}"]`);
    if(!fromEl || !toEl) return;
    const fromConn = fromEl.querySelector(`.connector-${c.fromConnector}`);
    const toConn = toEl.querySelector(`.connector-${c.toConnector}`);
    if(!fromConn || !toConn) return;
    const p1 = connectorCenterInCanvas(fromConn);
    const p2 = connectorCenterInCanvas(toConn);
    const dx = p2.x - p1.x, dy = p2.y - p1.y;
    const len = Math.sqrt(dx*dx + dy*dy), ang = Math.atan2(dy,dx);
    
    // Connection key for identification
    const connectionKey = `${c.from}->${c.to}:${c.fromConnector}->${c.toConnector}`;
    
    // Apply connection color
    const color = c.color || 'system';
    
    // Use straight lines
    const line = document.createElement('div'); 
    line.className = 'connection-line';
    line.style.left = p1.x + 'px'; 
    line.style.top = (p1.y - 2) + 'px';
    line.style.width = Math.max(len,2) + 'px'; 
    line.style.transform = `rotate(${ang}rad)`;
    line.classList.add(`color-${color}`);
    line.dataset.key = connectionKey;
    mainCanvas.appendChild(line);
    
    // Mid point clickable for deletion
    const mx = p1.x + dx/2, my = p1.y + dy/2;
    const point = document.createElement('div'); 
    point.className = 'connection-point';
    point.style.left = (mx - 6) + 'px'; 
    point.style.top = (my - 6) + 'px';
    point.dataset.key = connectionKey;
    point.addEventListener('contextmenu', (ev)=>{ 
      ev.preventDefault(); 
      contextConnectionEl = point;
      showConnectionContextMenu(ev);
    });
    // Hover tooltip: show info after a short hold
    (function(){
      let hoverTimer = null;
      point.addEventListener('mouseenter', (ev)=>{
        hoverTimer = setTimeout(()=>{
          showConnectionHoverTooltip(point);
        }, 600);
      });
      point.addEventListener('mouseleave', ()=>{
        if(hoverTimer) { clearTimeout(hoverTimer); hoverTimer = null; }
        hideConnectionHoverTooltip();
      });
      point.addEventListener('mousemove', (ev)=>{
        const tt = document.querySelector('.connection-point-tooltip');
        if(tt && tt.classList.contains('show')){
          const r = point.getBoundingClientRect();
          tt.style.left = (r.left + r.width/2) + 'px';
          tt.style.top = (r.top - 8) + 'px';
        }
      });
    })();
    mainCanvas.appendChild(point);
  });
  
  if(dragState && dragState.snappedPosition && dragState.snappedToBlock && dragState.snappedToConnector && isAutoConnectBlocksEnabled()){
    const fromId = dragState.snappedToBlock;
    const toId = dragState.blockId || dragState.el.dataset.blockId;
    const fromConnector = dragState.snappedToConnector;
    const flowchartType = getFlowchartType();
    const toConnector = flowchartType === 'horizontal' ? 'left' : 'top';
    
    if(fromId && toId && fromConnector && toConnector){
      if(allowedConnect(fromConnector, toConnector, fromId, toId)){
        const fromEl = mainCanvas.querySelector(`.block[data-block-id="${fromId}"]`);
        const toEl = dragState.el;
        
        if(fromEl && toEl){
          const fromConn = fromEl.querySelector(`.connector-${fromConnector}`);
          const toConn = toEl.querySelector(`.connector-${toConnector}`);
          
          if(fromConn && toConn){
            const p1 = connectorCenterInCanvas(fromConn);
            const p2 = connectorCenterInCanvas(toConn);
            const dx = p2.x - p1.x, dy = p2.y - p1.y;
            const len = Math.sqrt(dx*dx + dy*dy), ang = Math.atan2(dy,dx);
            
            const previewLine = document.createElement('div');
            previewLine.className = 'connection-line preview-connection';
            previewLine.style.left = p1.x + 'px';
            previewLine.style.top = (p1.y - 2) + 'px';
            previewLine.style.width = Math.max(len,2) + 'px';
            previewLine.style.transform = `rotate(${ang}rad)`;
            previewLine.style.zIndex = '39';
            mainCanvas.appendChild(previewLine);
          }
        }
      }
    }
  }
  
  updateCounts();
}

// Helper function to get connection color value (for SVG, we need actual color values)
function getConnectionColorValue(color){
  // For SVG, we can't use CSS variables directly, so we need to get computed values
  if(color === 'system'){
    // Get the computed value of --accent CSS variable
    const root = document.documentElement;
    const computedStyle = getComputedStyle(root);
    return computedStyle.getPropertyValue('--accent').trim() || '#06b6d4';
  }
  const colors = {
    'orange': '#ff8c00',
    'red': '#ff4444',
    'green': '#00ff88',
    'purple': '#8b5cf6'
  };
  return colors[color] || getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#06b6d4';
}
function connectorCenterInCanvas(connEl){
  const r = connEl.getBoundingClientRect(), c = mainCanvas.getBoundingClientRect();
  return { x: r.left + r.width/2 - c.left, y: r.top + r.height/2 - c.top };
}

// Connection hover tooltip helpers
function parseConnectionKey(key) {
  // expected format: "fromId->toId:fromConnector->toConnector"
  try {
    const parts = key.split(':');
    const blocksPart = parts[0] || '';
    const connsPart = parts[1] || '';
    const [fromBlock, toBlock] = blocksPart.split('->');
    const [fromConn, toConn] = connsPart.split('->');
    return { fromBlock, toBlock, fromConn, toConn };
  } catch(e){ return null; }
}

let _connectionHoverTooltip = null;
function showConnectionHoverTooltip(pointEl){
  // Tooltip disabled - no information shown
  return;
}

function hideConnectionHoverTooltip(){
  if(_connectionHoverTooltip){
    _connectionHoverTooltip.remove();
    _connectionHoverTooltip = null;
  }
}

function getBlockDisplayName(blockId) {
  if (!blockId) return '';
  const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
  if (blockEl) {
    if (blockEl.dataset.blockName) {
      return blockEl.dataset.blockName;
    }
    const headerEl = blockEl.querySelector('.block-header');
    if (headerEl && headerEl.textContent) {
      return headerEl.textContent.trim();
    }
  }
  const blockData = projectData.blocks.find(b => b.id === blockId);
  if (!blockData) return blockId;
  const cfg = findCfg(blockData.template);
  return blockData.displayName || blockData.name || cfg?.name || blockData.template || blockId;
}

function getBlockConnectionDescriptions(blockId) {
  // Disabled - no connection descriptions shown
  return [];
}

function attachBlockConnectionDescriptionHover(blockEl) {
  if (!blockEl) return;
  let hoverTimer = null;
  let tooltipEl = null;
  const delay = 700;
  let suppressForHeader = false;

  function hideTooltip() {
    if (tooltipEl) {
      tooltipEl.remove();
      tooltipEl = null;
    }
  }

  function positionTooltip() {
    if (!tooltipEl) return;
    const rect = blockEl.getBoundingClientRect();
    tooltipEl.style.left = (rect.left + rect.width / 2) + 'px';
    tooltipEl.style.top = (rect.top - 8) + 'px';
  }

  function showTooltip() {
    // Disabled - no tooltip shown
    return;
  }

  blockEl.addEventListener('mouseenter', () => {
    if (hoverTimer) clearTimeout(hoverTimer);
    if (suppressForHeader) return;
    hoverTimer = setTimeout(showTooltip, delay);
  });

  blockEl.addEventListener('mouseleave', () => {
    if (hoverTimer) {
      clearTimeout(hoverTimer);
      hoverTimer = null;
    }
    hideTooltip();
  });

  blockEl.addEventListener('mousemove', () => {
    if (tooltipEl && !suppressForHeader) {
      positionTooltip();
    }
  });

  blockEl.addEventListener('mousedown', () => {
    if (hoverTimer) {
      clearTimeout(hoverTimer);
      hoverTimer = null;
    }
    hideTooltip();
  });

  const headerEl = blockEl.querySelector('.block-header');
  if (headerEl) {
    headerEl.addEventListener('mouseenter', () => {
      suppressForHeader = true;
      if (hoverTimer) {
        clearTimeout(hoverTimer);
        hoverTimer = null;
      }
      hideTooltip();
    });
    headerEl.addEventListener('mouseleave', () => {
      suppressForHeader = false;
      if (blockEl.matches(':hover')) {
        if (hoverTimer) clearTimeout(hoverTimer);
        hoverTimer = setTimeout(showTooltip, delay);
      }
    });
  }
}

 

/* ========== Camera pan (Ctrl + LMB) ========== */
document.getElementById('viewport').addEventListener('mousedown', (e)=>{
  // start panning with Ctrl + LMB
  if(e.button===0 && e.ctrlKey){
    isPanning = true;
    panStart = { x: e.clientX, y: e.clientY };
    panCameraStart = { x: camera.x, y: camera.y };
    e.preventDefault();
  }
});
window.addEventListener('keyup', (e)=>{ if(e.key === 'Control') { isPanning = false; panStart = null; panCameraStart = null; } });

/* ========== Drag & Drop from palette anywhere on page ========== */
document.addEventListener('dragover', (e)=>{ e.preventDefault(); });
document.addEventListener('drop', (e)=>{
  e.preventDefault();
  const templateId = e.dataTransfer.getData('text/plain') || e.dataTransfer.getData('templateId');
  if(!templateId) return;
  const viewportRect = document.getElementById('viewport').getBoundingClientRect();
  const vx = e.clientX - viewportRect.left;
  const vy = e.clientY - viewportRect.top;
  const x = vx - camera.x;
  const y = vy - camera.y;
  createFromTemplate(templateId, x, y);
  updateConnections();
});

/* ========== Context menu actions ========== */
document.addEventListener('contextmenu', (e)=>{
  const block = e.target.closest('.block');
  const menu = document.getElementById('blockContextMenu');
  if(block){
    e.preventDefault();
    contextBlockEl = block;
    menu.style.left = e.pageX + 'px';
    menu.style.top = e.pageY + 'px';
    menu.style.display = 'block';
    // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –ø—É–Ω–∫—Ç–∞ –º–µ–Ω—é –¥–ª—è –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –æ—à–∏–±–æ–∫
    try {
      const id = contextBlockEl?.dataset?.blockId;
      const bd = projectData.blocks.find(b => b.id === id);
      const cfg = bd ? findCfg(bd.template) : null;
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É–Ω–∫—Ç –º–µ–Ω—é –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –±–ª–æ–∫–∞
      const ignoreBlockItem = document.getElementById('ignoreBlockMenuItem');
      if (ignoreBlockItem && bd && cfg) {
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –±–ª–æ–∫–æ–≤, –∫—Ä–æ–º–µ header
        const canIgnore = cfg.type !== 'header';
        if (canIgnore) {
          ignoreBlockItem.style.display = 'block';
          const isIgnored = !!(bd.ignored === true);
          ignoreBlockItem.textContent = isIgnored ? '‚úÖ –û—Ç–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ' : 'üö´ –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å';
        } else {
          ignoreBlockItem.style.display = 'none';
        }
      }
      
      const item = document.getElementById('ignoreIssueMenuItem');
      if (item) {
        const isIgnored = !!(bd && bd.ignoreIssues === true);
        item.textContent = (isIgnored ? 'üî¥ –û—Ç–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –¥–ª—è —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞' : 'üü¢ –í–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –¥–ª—è —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞');
      }
      const collapseMenuItem = document.getElementById('collapseBranchMenuItem');
      if (collapseMenuItem) {
        if (cfg && (cfg.type === 'condition' || cfg.type === 'loop')) {
          const isCollapsed = !!bd.collapsedRightBranch;
          collapseMenuItem.style.display = 'block';
          collapseMenuItem.textContent = isCollapsed ? 'üëÅÔ∏è –ü–æ–∫–∞–∑–∞—Ç—å –≤–µ—Ç–∫—É' : '‚ûñ –°–≤–µ—Ä–Ω—É—Ç—å –≤–µ—Ç–∫—É';
        } else {
          collapseMenuItem.style.display = 'none';
        }
      }
      // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ñ–æ –æ –ø—É—Ç–∏ –∏ –∏—Å—Ç–æ—á–Ω–∏–∫–µ –±–ª–æ–∫–∞
      const info = document.getElementById('blockPathInfo');
      const showBlockPath = localStorage.getItem('showBlockPath') !== 'false';
      if (info) {
        if (showBlockPath && bd) {
          const cfg = findCfg(bd.template);
          let catName = '';
          let modText = '';
          for (const cat of (blocksConfig.categories||[])){
            if ((cat.blocks||[]).some(cb => cb.id === (cfg && cfg.id))) {
              catName = cat.name || '';
              const modId = cat.modId || 'core';
              const modName = cat.modName || (modId==='core' ? '' : modId);
              if (modId !== 'core') modText = ` ¬∑ –∏–∑ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏: ${modName}`;
              break;
            }
          }
          const blockName = (cfg && cfg.name) ? cfg.name : (bd.template || '–ë–ª–æ–∫');
          info.textContent = `${catName ? catName + ' > ' : ''}${blockName}${modText}`;
          info.style.display = 'block';
        } else {
          info.style.display = 'none';
        }
      }
      // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É–Ω–∫—Ç—ã –º–µ–Ω—é –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
      const lockItem = document.getElementById('lockMenuItem');
      const allItems = Array.from(menu.querySelectorAll('.menu-item'));
      if (lockItem && bd){
        const locked = !!bd.locked;
        lockItem.textContent = locked ? 'üîì –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –±–ª–æ–∫' : 'üîí –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –±–ª–æ–∫';
        if (locked){
          // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫—É –ø—É—Ç–∏ (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞), –ø—É–Ω–∫—Ç —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–µ—Ç–∫–æ–π (–µ—Å–ª–∏ —Å–≤–µ—Ä–Ω—É—Ç–∞)
          allItems.forEach(mi => {
            const shouldShow = (mi.id === 'blockPathInfo' && showBlockPath) || mi.id === 'lockMenuItem' || (mi.id === 'collapseBranchMenuItem' && bd.collapsedRightBranch);
            mi.style.display = shouldShow ? 'block' : 'none';
          });
        } else {
          // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –ø—É–Ω–∫—Ç—ã (–∫—Ä–æ–º–µ —Ç–µ—Ö, –∫–æ—Ç–æ—Ä—ã–µ —Å–∫—Ä—ã—Ç—ã –ø–æ –¥—Ä—É–≥–∏–º –ø—Ä–∏—á–∏–Ω–∞–º)
          allItems.forEach(mi => { 
            if (mi.id === 'blockPathInfo') {
              // blockPathInfo —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –Ω–∞—Å—Ç—Ä–æ–π–∫–æ–π showBlockPath, —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –≤—ã—à–µ
            } else if (mi.id === 'ignoreBlockMenuItem') {
              if (ignoreBlockItem && ignoreBlockItem.style.display !== 'none') {
                mi.style.display = 'block';
              }
            } else if (mi.id === 'collapseBranchMenuItem') {
              // –æ—Å—Ç–∞–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –∑–∞–¥–∞–Ω–Ω–æ–µ —Ä–∞–Ω–µ–µ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ
            } else {
              mi.style.display = 'block'; 
            }
          });
        }
      }
    } catch(_) {}
  } else {
    menu.style.display = 'none';
    contextBlockEl = null;
  }
});
document.addEventListener('click', ()=> { 
  document.getElementById('blockContextMenu').style.display='none';
  hideConnectionContextMenu();
  // –°–∫—Ä—ã–≤–∞–µ–º –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –µ–≥–æ
  hideAutocomplete();
});

async function duplicateContextBlock(){
  if(!contextBlockEl) return;
  const id = contextBlockEl.dataset.blockId;
  const bd = projectData.blocks.find(b => b.id === id);
  if(!bd) return;
  
  const cfg = findCfg(bd.template);
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –±–ª–æ–∫ condition –∏–ª–∏ loop
  const isConditionOrLoop = cfg && (cfg.type === 'condition' || cfg.type === 'loop');
  
  if(isConditionOrLoop) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ
    const rightConnections = projectData.connections.filter(c => c.from === id && c.fromConnector === 'right');
    
    if(rightConnections.length > 0) {
      // –ï—Å—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
      pendingDuplicateBlockId = id;
      openDuplicateBlockBranchModal();
      document.getElementById('blockContextMenu').style.display='none';
      return;
    }
  }
  
  // –ù–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –∏–ª–∏ –Ω–µ condition/loop - –¥—É–±–ª–∏—Ä—É–µ–º –∫–∞–∫ –æ–±—ã—á–Ω–æ
  await performDuplicateBlock(id);
}

async function performDuplicateBlock(blockId) {
  const bd = projectData.blocks.find(b => b.id === blockId);
  if(!bd) return;
  
  try {
    const resp = await fetch('/api/block/duplicate', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ block_data: bd })});
    const j = await resp.json();
    if(j.status === 'success' && j.new_block){
      // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –∫ –Ω–æ–≤–æ–º—É –±–ª–æ–∫—É, –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
      if (isGlobalIgnoreEnabled()) {
        j.new_block.ignoreIssues = true;
      }
      projectData.blocks.push(j.new_block);
      createInstance(j.new_block);
      updateConnections();
      updateCounts();
      // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –∑–Ω–∞—á–µ–Ω–∏–π
      loadValueHistory();
      updateSaveStatusIndicator();
    } else alert('–û—à–∏–±–∫–∞ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è');
  } catch(err){ console.error(err); alert('–û—à–∏–±–∫–∞ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è'); }
  document.getElementById('blockContextMenu').style.display='none';
}

async function performDuplicateBranch(blockId) {
  const bd = projectData.blocks.find(b => b.id === blockId);
  if(!bd) return;
  
  // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ ID –±–ª–æ–∫–æ–≤ –≤ –≤–µ—Ç–∫–µ –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ
  const branchIds = collectBranchBlockIds(blockId, 'right');
  
  // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É —Å—Ç–∞—Ä—ã—Ö ID -> –Ω–æ–≤—ã—Ö ID –¥–ª—è –≤—Å–µ—Ö –±–ª–æ–∫–æ–≤ –≤–µ—Ç–∫–∏
  const idMap = new Map();
  
  // –°–Ω–∞—á–∞–ª–∞ –¥—É–±–ª–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π –±–ª–æ–∫
  try {
    const resp = await fetch('/api/block/duplicate', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ block_data: bd })});
    const j = await resp.json();
    if(j.status === 'success' && j.new_block){
      const newMainBlock = j.new_block;
      idMap.set(blockId, newMainBlock.id);
      
      // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –∫ –Ω–æ–≤–æ–º—É –±–ª–æ–∫—É, –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
      if (isGlobalIgnoreEnabled()) {
        newMainBlock.ignoreIssues = true;
      }
      projectData.blocks.push(newMainBlock);
      createInstance(newMainBlock);
    } else {
      alert('–û—à–∏–±–∫–∞ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –±–ª–æ–∫–∞');
      return;
    }
  } catch(err){ 
    console.error(err); 
    alert('–û—à–∏–±–∫–∞ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –±–ª–æ–∫–∞'); 
    return;
  }
  
  // –î—É–±–ª–∏—Ä—É–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –≤–µ—Ç–∫–∏
  for(const branchBlockId of branchIds) {
    const branchBlock = projectData.blocks.find(b => b.id === branchBlockId);
    if(!branchBlock) continue;
    
    try {
      const resp = await fetch('/api/block/duplicate', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ block_data: branchBlock })});
      const j = await resp.json();
      if(j.status === 'success' && j.new_block){
        const newBranchBlock = j.new_block;
        idMap.set(branchBlockId, newBranchBlock.id);
        
        // –ü—Ä–∏–º–µ–Ω—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω–æ–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –∫ –Ω–æ–≤–æ–º—É –±–ª–æ–∫—É, –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ
        if (isGlobalIgnoreEnabled()) {
          newBranchBlock.ignoreIssues = true;
        }
        projectData.blocks.push(newBranchBlock);
        createInstance(newBranchBlock);
      }
    } catch(err){ 
      console.error(err); 
      continue;
    }
  }
  
  // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –¥–ª—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –≤–µ—Ç–∫–∏
  // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –≤–µ—Ç–∫–æ–π
  const allBranchBlockIds = [blockId, ...branchIds];
  const connectionsToDuplicate = projectData.connections.filter(c => {
    // –°–æ–µ–¥–∏–Ω–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–∏ –≤–µ—Ç–∫–∏ (–æ–±–∞ –∫–æ–Ω—Ü–∞ –≤ –≤–µ—Ç–∫–µ) –∏–ª–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –æ—Ç –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –±–ª–æ–∫–∞ –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ
    const fromInBranch = allBranchBlockIds.includes(c.from);
    const toInBranch = allBranchBlockIds.includes(c.to);
    
    // –í–∫–ª—é—á–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –≤–Ω—É—Ç—Ä–∏ –≤–µ—Ç–∫–∏
    if(fromInBranch && toInBranch) {
      return true;
    }
    
    // –í–∫–ª—é—á–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –æ—Ç –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –±–ª–æ–∫–∞ –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ –∫ –ø–µ—Ä–≤–æ–º—É –±–ª–æ–∫—É –≤–µ—Ç–∫–∏
    if(c.from === blockId && c.fromConnector === 'right' && toInBranch) {
      return true;
    }
    
    return false;
  });
  
  for(const conn of connectionsToDuplicate) {
    const newFrom = idMap.get(conn.from);
    const newTo = idMap.get(conn.to);
    
    if(newFrom && newTo) {
      projectData.connections.push({
        from: newFrom,
        to: newTo,
        fromConnector: conn.fromConnector,
        toConnector: conn.toConnector,
        color: conn.color || 'system'
      });
    }
  }
  
  updateConnections();
  updateCounts();
  // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –∑–Ω–∞—á–µ–Ω–∏–π
  loadValueHistory();
  document.getElementById('blockContextMenu').style.display='none';
}

function openDuplicateBlockBranchModal() {
  const modal = document.getElementById('duplicateBlockBranchModal');
  if (modal) modal.style.display = 'block';
}

function closeDuplicateBlockBranchModal() {
  const modal = document.getElementById('duplicateBlockBranchModal');
  if (modal) modal.style.display = 'none';
  pendingDuplicateBlockId = null;
}

async function confirmDuplicateBlockOnly() {
  if(!pendingDuplicateBlockId) {
    closeDuplicateBlockBranchModal();
    return;
  }
  
  const blockId = pendingDuplicateBlockId;
  
  // –î—É–±–ª–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –±–ª–æ–∫
  await performDuplicateBlock(blockId);
  closeDuplicateBlockBranchModal();
}

async function confirmDuplicateBranch() {
  if(!pendingDuplicateBlockId) {
    closeDuplicateBlockBranchModal();
    return;
  }
  
  const blockId = pendingDuplicateBlockId;
  
  // –î—É–±–ª–∏—Ä—É–µ–º –≤—Å—é –≤–µ—Ç–∫—É
  await performDuplicateBranch(blockId);
  closeDuplicateBlockBranchModal();
}

// –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è ID –±–ª–æ–∫–∞, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —É–¥–∞–ª—è—Ç—å—Å—è
let pendingDeleteBlockId = null;

// –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è ID –±–ª–æ–∫–∞, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å—Å—è
let pendingDuplicateBlockId = null;

function deleteContextBlock(){
  if(!contextBlockEl) return;
  const id = contextBlockEl.dataset.blockId;
  const blockData = projectData.blocks.find(b => b.id === id);
  if(!blockData) return;
  
  const cfg = findCfg(blockData.template);
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –±–ª–æ–∫ condition –∏–ª–∏ loop
  const isConditionOrLoop = cfg && (cfg.type === 'condition' || cfg.type === 'loop');
  
  if(isConditionOrLoop) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ
    const rightConnections = projectData.connections.filter(c => c.from === id && c.fromConnector === 'right');
    
    if(rightConnections.length > 0) {
      // –ï—Å—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
      pendingDeleteBlockId = id;
      openDeleteBlockBranchModal();
      document.getElementById('blockContextMenu').style.display='none';
      return;
    }
  }
  
  // –ù–µ—Ç —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π –∏–ª–∏ –Ω–µ condition/loop - —É–¥–∞–ª—è–µ–º –∫–∞–∫ –æ–±—ã—á–Ω–æ
  performDeleteBlock(id);
}

function performDeleteBlock(blockId) {
  projectData.blocks = projectData.blocks.filter(b => b.id !== blockId);
  projectData.connections = projectData.connections.filter(c => c.from !== blockId && c.to !== blockId);
  const el = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
  if(el) el.remove();
  updateConnections();
  updateCounts();
  // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –∑–Ω–∞—á–µ–Ω–∏–π
  loadValueHistory();
  document.getElementById('blockContextMenu').style.display='none';
  updateSaveStatusIndicator();
}

function performDeleteBranch(blockId) {
  // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ ID –±–ª–æ–∫–æ–≤ –≤ –≤–µ—Ç–∫–µ –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ
  const branchIds = collectBranchBlockIds(blockId, 'right');
  
  // –£–¥–∞–ª—è–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –≤–µ—Ç–∫–∏
  branchIds.forEach(bid => {
    projectData.blocks = projectData.blocks.filter(b => b.id !== bid);
    projectData.connections = projectData.connections.filter(c => c.from !== bid && c.to !== bid);
    const el = mainCanvas.querySelector(`.block[data-block-id="${bid}"]`);
    if(el) el.remove();
  });
  
  // –£–¥–∞–ª—è–µ–º —Å–∞–º –±–ª–æ–∫
  performDeleteBlock(blockId);
}

function openDeleteBlockBranchModal() {
  const modal = document.getElementById('deleteBlockBranchModal');
  if (modal) modal.style.display = 'block';
}

function closeDeleteBlockBranchModal() {
  const modal = document.getElementById('deleteBlockBranchModal');
  if (modal) modal.style.display = 'none';
  pendingDeleteBlockId = null;
}

function confirmDeleteBlockOnly() {
  if(!pendingDeleteBlockId) {
    closeDeleteBlockBranchModal();
    return;
  }
  
  const blockId = pendingDeleteBlockId;
  const blockData = projectData.blocks.find(b => b.id === blockId);
  
  // –ï—Å–ª–∏ –≤–µ—Ç–∫–∞ —Å–∫—Ä—ã—Ç–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ—ë
  if(blockData && blockData.collapsedRightBranch) {
    expandRightBranch(blockData);
  }
  
  // –£–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –±–ª–æ–∫ (—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ –±—É–¥—É—Ç —Ä–∞–∑–æ—Ä–≤–∞–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏)
  performDeleteBlock(blockId);
  closeDeleteBlockBranchModal();
}

function confirmDeleteBranch() {
  if(!pendingDeleteBlockId) {
    closeDeleteBlockBranchModal();
    return;
  }
  
  const blockId = pendingDeleteBlockId;
  
  // –£–¥–∞–ª—è–µ–º –≤—Å—é –≤–µ—Ç–∫—É
  performDeleteBranch(blockId);
  closeDeleteBlockBranchModal();
}

function toggleFieldInputType(){
  if(!contextBlockEl) return;
  const id = contextBlockEl.dataset.blockId;
  const blockData = projectData.blocks.find(b => b.id === id);
  if(!blockData) return;
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º fieldTypes –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
  if (!blockData.fieldTypes) {
    blockData.fieldTypes = {};
  }
  
  // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —Ç–∏–ø –≤—Å–µ—Ö –ø–æ–ª–µ–π –≤ –±–ª–æ–∫–µ
  const cfg = findCfg(blockData.template);
  if (cfg && cfg.fields && cfg.fields.length) {
    cfg.fields.forEach(f => {
      const currentType = blockData.fieldTypes[f.name] || 'single-line';
      blockData.fieldTypes[f.name] = currentType === 'single-line' ? 'multi-line' : 'single-line';
    });
  }
  
  // –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –±–ª–æ–∫ —Å –Ω–æ–≤—ã–º–∏ —Ç–∏–ø–∞–º–∏ –ø–æ–ª–µ–π
  const blockEl = mainCanvas.querySelector(`.block[data-block-id="${id}"]`);
  if (blockEl) {
    blockEl.remove();
  }
  createInstance(blockData);
  updateCounts();
  
  // –û–±–Ω–æ–≤–ª—è–µ–º —Å–≤—è–∑–∏ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ –±–ª–æ–∫–∞ (—Å –∑–∞–¥–µ—Ä–∂–∫–æ–π –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞)
  setTimeout(() => {
    updateConnections();
    updateSaveStatusIndicator();
  }, 50);
  
  document.getElementById('blockContextMenu').style.display='none';
}

function clearContextBlock(){
  if(!contextBlockEl) return;
  const id = contextBlockEl.dataset.blockId;
  const blockData = projectData.blocks.find(b => b.id === id);
  if(!blockData) return;
  
  // –ù–µ –æ—á–∏—â–∞–µ–º –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –±–ª–æ–∫–∏
  if (blockData.locked) return;
  
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º fields –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
  if (!blockData.fields) {
    blockData.fields = {};
  }
  
  // –û—á–∏—â–∞–µ–º –≤—Å–µ –ø–æ–ª—è –≤ blockData
  const cfg = findCfg(blockData.template);
  if (cfg && cfg.fields) {
    cfg.fields.forEach(f => {
      blockData.fields[f.name] = '';
    });
  }
  
  // –û—á–∏—â–∞–µ–º –≤—Å–µ –ø–æ–ª—è –≤–≤–æ–¥–∞ –≤ –±–ª–æ–∫–µ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ
  const blockEl = mainCanvas.querySelector(`.block[data-block-id="${id}"]`);
  if (blockEl) {
    const inputs = blockEl.querySelectorAll('input, textarea');
    inputs.forEach(input => {
      input.value = '';
      
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏–∑–º–µ–Ω—è–µ–º —Ä–∞–∑–º–µ—Ä –¥–ª—è textarea
      if (input.tagName === 'TEXTAREA') {
        input.style.height = 'auto';
        const newHeight = Math.min(input.scrollHeight, 200);
        input.style.height = newHeight + 'px';
      }
    });
  }
  
  updateConnections();
  updateCounts();
  // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –∑–Ω–∞—á–µ–Ω–∏–π
  loadValueHistory();
  document.getElementById('blockContextMenu').style.display='none';
  updateSaveStatusIndicator();
}

function toggleContextBlockRightBranch(){
  if(!contextBlockEl) return;
  const id = contextBlockEl.dataset.blockId;
  const blockData = projectData.blocks.find(b => b.id === id);
  if(!blockData) return;
  const cfg = findCfg(blockData.template);
  if(!cfg || (cfg.type !== 'condition' && cfg.type !== 'loop')) return;

  if (blockData.collapsedRightBranch) {
    expandRightBranch(blockData);
  } else {
    collapseRightBranch(blockData);
  }

  const menu = document.getElementById('blockContextMenu');
  if (menu) menu.style.display='none';
}

function collapseRightBranch(blockData){
  blockData.collapsedRightBranch = true;
  const branchIds = collectBranchBlockIds(blockData.id, 'right');
  setBlocksHiddenBy(blockData.id, branchIds, true);
  const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockData.id}"]`);
  if (blockEl) applyRightConnectorState(blockEl, blockData);
  updateConnections();
}

function expandRightBranch(blockData){
  blockData.collapsedRightBranch = false;
  const branchIds = collectBranchBlockIds(blockData.id, 'right');
  setBlocksHiddenBy(blockData.id, branchIds, false);
  const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockData.id}"]`);
  if (blockEl) applyRightConnectorState(blockEl, blockData);
  updateConnections();
}

// –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –±–ª–æ–∫–∞ (–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–¥–∞)
function toggleIgnoreBlock(){
  if(!contextBlockEl) return;
  const id = contextBlockEl.dataset.blockId;
  const bd = projectData.blocks.find(b => b.id === id);
  if(!bd) return;
  
  const cfg = findCfg(bd.template);
  if(!cfg || cfg.type === 'header') return; // –ù–µ–ª—å–∑—è –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å header –±–ª–æ–∫–∏
  
  const isIgnored = !!(bd.ignored === true);
  bd.ignored = !isIgnored;
  
  // –ï—Å–ª–∏ –±–ª–æ–∫ condition –∏–ª–∏ loop, –Ω—É–∂–Ω–æ —Ç–∞–∫–∂–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –±–ª–æ–∫–∏ –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ
  if (cfg.type === 'condition' || cfg.type === 'loop') {
    const connections = projectData.connections || [];
    const rightConnections = connections.filter(c => c.from === id && c.fromConnector === 'right');
    
    // –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –≤—Å–µ –±–ª–æ–∫–∏ –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ
    function updateRightBranch(blockId, ignoredState) {
      const block = projectData.blocks.find(b => b.id === blockId);
      if (!block) return;
      
      block.ignored = ignoredState;
      
      // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ
      const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
      if (blockEl) {
        if (ignoredState) {
          blockEl.classList.add('block-ignored');
        } else {
          blockEl.classList.remove('block-ignored');
        }
      }
      
      // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –¥–ª—è –≤—Å–µ—Ö —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤ (–≤–Ω–∏–∑ –ø–æ —Ü–µ–ø–æ—á–∫–µ)
      const nextConnections = connections.filter(c => c.from === blockId && c.fromConnector === 'bottom');
      nextConnections.forEach(conn => {
        updateRightBranch(conn.to, ignoredState);
      });
      
      // –ï—Å–ª–∏ —ç—Ç–æ —Ç–æ–∂–µ condition –∏–ª–∏ loop, –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∞–≤—ã–π –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä
      const blockCfg = findCfg(block.template);
      if (blockCfg && (blockCfg.type === 'condition' || blockCfg.type === 'loop')) {
        const rightConns = connections.filter(c => c.from === blockId && c.fromConnector === 'right');
        rightConns.forEach(conn => {
          updateRightBranch(conn.to, ignoredState);
        });
      }
    }
    
    rightConnections.forEach(conn => {
      updateRightBranch(conn.to, bd.ignored);
    });
  }
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –±–ª–æ–∫–∞
  const blockEl = mainCanvas.querySelector(`.block[data-block-id="${id}"]`);
  if (blockEl) {
    if (bd.ignored) {
      blockEl.classList.add('block-ignored');
    } else {
      blockEl.classList.remove('block-ignored');
    }
  }
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞–Ω–µ–ª—å –æ—à–∏–±–æ–∫/–ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π
  updateIssues();
  
  document.getElementById('blockContextMenu').style.display='none';
}

// –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ñ–ª–∞–≥–∞ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –æ—à–∏–±–æ–∫/–ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –±–ª–æ–∫–∞
function toggleIgnoreIssuesForContextBlock(){
  if(!contextBlockEl) return;
  const id = contextBlockEl.dataset.blockId;
  const bd = projectData.blocks.find(b => b.id === id);
  if(!bd) return;
  bd.ignoreIssues = !bd.ignoreIssues;
  // –ü–µ—Ä–µ—Å—á—ë—Ç –∏ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∫–∞ –ø–∞–Ω–µ–ª—å–∫–∏ –ø—Ä–æ–±–ª–µ–º
  updateIssues();
  const blockEl = mainCanvas.querySelector(`.block[data-block-id="${id}"]`);
  if (blockEl) applyBlockIgnoreIssuesState(blockEl, bd);
  // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É–Ω–∫—Ç –º–µ–Ω—é
  const item = document.getElementById('ignoreIssueMenuItem');
  if (item) {
    item.textContent = (bd.ignoreIssues ? 'üî¥ –û—Ç–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –¥–ª—è —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞' : 'üü¢ –í–∫–ª—é—á–∏—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ –¥–ª—è —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞');
  }
  document.getElementById('blockContextMenu').style.display='none';
}

// –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –±–ª–æ–∫–∞ (–∑–∞–ø—Ä–µ—Ç –Ω–∞ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ª–µ–π)
function toggleLockForContextBlock(){
  if(!contextBlockEl) return;
  const id = contextBlockEl.dataset.blockId;
  const bd = projectData.blocks.find(b => b.id === id);
  if(!bd) return;
  // –ü—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å ‚Äî –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–µ—Ç –Ω–µ–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º—ã—Ö –ø—Ä–æ–±–ª–µ–º
  if (!bd.locked){
    const hasBlockingIssues = hasUnignoredIssuesForBlock(id);
    if (hasBlockingIssues){
      showNotification('error', '–ù–µ–ª—å–∑—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –±–ª–æ–∫', '–ë–ª–æ–∫ —Å–æ–¥–µ—Ä–∂–∏—Ç –æ—à–∏–±–∫–∏/–ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è. –°–Ω–∞—á–∞–ª–∞ –∏—Å–ø—Ä–∞–≤—å—Ç–µ –∏—Ö –∏–ª–∏ –≤–∫–ª—é—á–∏—Ç–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ.');
      const menu = document.getElementById('blockContextMenu');
      if (menu) menu.style.display='none';
      return;
    }
  }
  bd.locked = !bd.locked;
  const blockEl = mainCanvas.querySelector(`.block[data-block-id="${id}"]`);
  if (blockEl) applyBlockLockState(blockEl, bd);
  const menu = document.getElementById('blockContextMenu');
  if (menu) menu.style.display='none';
}

// –ü—Ä–∏–º–µ–Ω—è–µ—Ç –≤–∏–∑—É–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –ø–æ–ª–µ–π
function applyBlockLockState(blockEl, blockData){
  const lockEl = blockEl.querySelector('.block-lock-indicator');
  const inputs = blockEl.querySelectorAll('input, textarea');
  const isLocked = !!blockData.locked;
  if (lockEl){
    lockEl.style.display = isLocked ? 'flex' : 'none';
  }
  inputs.forEach(inp => { inp.disabled = isLocked; });
  // –ë–ª–æ–∫–∏—Ä—É–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ textarea –ø—Ä–∏ –±–ª–æ–∫–∏—Ä–æ–≤–∫–µ
  blockEl.querySelectorAll('textarea').forEach(ta => {
    ta.style.resize = isLocked ? 'none' : '';
  });
  // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –æ—à–∏–±–æ–∫
  applyBlockIgnoreIssuesState(blockEl, blockData);
}

// –ü—Ä–∏–º–µ–Ω—è–µ—Ç –≤–∏–∑—É–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –æ—à–∏–±–æ–∫
function applyBlockIgnoreIssuesState(blockEl, blockData){
  const ignoreIssuesEl = blockEl.querySelector('.block-ignore-issues-indicator');
  const lockEl = blockEl.querySelector('.block-lock-indicator');
  if (!ignoreIssuesEl) return;
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω–æ –ª–∏ –≥–ª–æ–±–∞–ª—å–Ω–æ–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ
  const isGlobalIgnore = isGlobalIgnoreEnabled();
  
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏:
  // 1. –£ –±–ª–æ–∫–∞ –≤–∫–ª—é—á–µ–Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ (ignoreIssues === true)
  // 2. –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—ã–∫–ª—é—á–µ–Ω–æ
  const shouldShow = !isGlobalIgnore && !!(blockData && blockData.ignoreIssues === true);
  
  if (shouldShow) {
    ignoreIssuesEl.style.display = 'flex';
    // –ï—Å–ª–∏ lockIndicator –≤–∏–¥–µ–Ω, —Ä–∞–∑–º–µ—â–∞–µ–º ignoreIssuesIndicator —Å–ª–µ–≤–∞ –æ—Ç –Ω–µ–≥–æ
    const isLockVisible = lockEl && lockEl.style.display === 'flex';
    if (isLockVisible) {
      ignoreIssuesEl.style.right = '28px'; // 18px (—à–∏—Ä–∏–Ω–∞) + 6px (–æ—Ç—Å—Ç—É–ø) + 4px (–ø—Ä–æ–º–µ–∂—É—Ç–æ–∫)
    } else {
      ignoreIssuesEl.style.right = '6px';
    }
  } else {
    ignoreIssuesEl.style.display = 'none';
  }
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å—Ç—å –ª–∏ —É –±–ª–æ–∫–∞ –Ω–µ–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º—ã–µ –ø—Ä–æ–±–ª–µ–º—ã (–æ—à–∏–±–∫–∏/–ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è)
function hasUnignoredIssuesForBlock(blockId){
  const panel = document.getElementById('issuesPanel');
  if (!panel) return false;
  const nodes = Array.from(panel.querySelectorAll('.issue'));
  // –ò—â–µ–º –∑–∞–ø–∏—Å–∏, –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–µ –∫ —ç—Ç–æ–º—É –±–ª–æ–∫—É (–ø–æ data-block-id), –∏—Å–∫–ª—é—á–∞—è –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º—ã–µ
  return nodes.some(n => n.dataset && n.dataset.blockId === blockId && !n.classList.contains('ignored'));
}

/* ========== Connection context menu functions ========== */
function showConnectionContextMenu(event) {
  const menu = document.getElementById('connectionContextMenu');
  menu.style.left = event.pageX + 'px';
  menu.style.top = event.pageY + 'px';
  menu.style.display = 'block';
}

function hideConnectionContextMenu() {
  const menu = document.getElementById('connectionContextMenu');
  menu.style.display = 'none';
  contextConnectionEl = null;
}

function deleteConnection() {
  if (!contextConnectionEl) return;
  
  const key = contextConnectionEl.dataset.key;
  projectData.connections = projectData.connections.filter(c => 
    `${c.from}->${c.to}:${c.fromConnector}->${c.toConnector}` !== key
  );
  
  updateConnections();
  updateCounts();
  hideConnectionContextMenu();
  updateSaveStatusIndicator();
}

function changeConnectionColor(color) {
  if (!contextConnectionEl) return;
  
  const key = contextConnectionEl.dataset.key;
  const connection = projectData.connections.find(c => 
    `${c.from}->${c.to}:${c.fromConnector}->${c.toConnector}` === key
  );
  if(connection) {
    connection.color = color;
    updateConnections();
    updateSaveStatusIndicator();
  }
  
  hideConnectionContextMenu();
}

/* ========== Export / Import / Save to server / Load from server ========== */
function openExportModal(){ document.getElementById('exportModal').style.display = 'block'; }
function closeExportModal(){ document.getElementById('exportModal').style.display = 'none'; }

// Settings modal functions
function openSettingsModal(){
  const modal = document.getElementById('settingsModal');
  modal.style.display = 'block';
  // Load current settings
  const flowchartType = localStorage.getItem('flowchartType') || 'vertical';
  document.getElementById(`flowchartType${flowchartType.charAt(0).toUpperCase() + flowchartType.slice(1)}`).checked = true;
  const arrowInversion = localStorage.getItem('arrowInversion') === 'true';
  document.getElementById('arrowInversion').checked = arrowInversion;
  const strictBlockSelection = localStorage.getItem('strictBlockSelection') === 'true';
  const strictBlockSelectionEl = document.getElementById('strictBlockSelection');
  if(strictBlockSelectionEl) strictBlockSelectionEl.checked = strictBlockSelection;
  const autoSnapBlocks = localStorage.getItem('autoSnapBlocks') === 'true';
  const autoSnapBlocksEl = document.getElementById('autoSnapBlocks');
  if(autoSnapBlocksEl) autoSnapBlocksEl.checked = autoSnapBlocks;
  const autoConnectBlocks = isAutoConnectBlocksEnabled();
  const autoConnectBlocksEl = document.getElementById('autoConnectBlocks');
  if(autoConnectBlocksEl) autoConnectBlocksEl.checked = autoConnectBlocks;
  const blockSpacing = localStorage.getItem('blockSpacing') || 'optimal';
  const blockSpacingEl = document.getElementById('blockSpacing');
  if(blockSpacingEl) blockSpacingEl.value = blockSpacing;
  updateBlockSpacingSetting();
  updateAutoConnectBlocksSetting();
  
  // Update settings ID display
  updateSettingsIdDisplay();
  
  // Load highlight styles (radio buttons)
  const warningStyle = localStorage.getItem('warningHighlightStyle') || 'full';
  const warningRadioId = `warningHighlightStyle${warningStyle.charAt(0).toUpperCase() + warningStyle.slice(1)}`;
  const warningRadio = document.getElementById(warningRadioId);
  if(warningRadio) warningRadio.checked = true;
  const errorStyle = localStorage.getItem('errorHighlightStyle') || 'full';
  const errorRadioId = `errorHighlightStyle${errorStyle.charAt(0).toUpperCase() + errorStyle.slice(1)}`;
  const errorRadio = document.getElementById(errorRadioId);
  if(errorRadio) errorRadio.checked = true;
  
  // Load display settings
  const showModsList = localStorage.getItem('showModsList') !== 'false';
  document.getElementById('showModsList').checked = showModsList;
  const showConnectorLabels = localStorage.getItem('showConnectorLabels') !== 'false';
  document.getElementById('showConnectorLabels').checked = showConnectorLabels;
  const showFieldLabels = localStorage.getItem('showFieldLabels') !== 'false';
  document.getElementById('showFieldLabels').checked = showFieldLabels;
  const showSelectionSummary = localStorage.getItem('showSelectionSummary') !== 'false';
  document.getElementById('showSelectionSummary').checked = showSelectionSummary;
  const showBlockPath = localStorage.getItem('showBlockPath') !== 'false';
  const showBlockPathEl = document.getElementById('showBlockPath');
  if(showBlockPathEl) showBlockPathEl.checked = showBlockPath;
  const showCompiledCode = localStorage.getItem('showCompiledCode') === 'true';
  const showCompiledCodeEl = document.getElementById('showCompiledCode');
  if(showCompiledCodeEl) showCompiledCodeEl.checked = showCompiledCode;
  const allFieldsMultiLine = localStorage.getItem('allFieldsMultiLine') === 'true';
  const allFieldsMultiLineEl = document.getElementById('allFieldsMultiLine');
  if(allFieldsMultiLineEl) allFieldsMultiLineEl.checked = allFieldsMultiLine;
  const autoCompleteQuotes = localStorage.getItem('autoCompleteQuotes') === 'true';
  const autoCompleteQuotesEl = document.getElementById('autoCompleteQuotes');
  if(autoCompleteQuotesEl) autoCompleteQuotesEl.checked = autoCompleteQuotes;
  updateSafeModeSettingsUI();
  const tssToggle = document.getElementById('tssSecurityToggle');
  if(tssToggle) {
    tssToggle.checked = isTssSecurityEnabled();
  }
  updateTssSecurityDescription();
  loadRequirementsFile();
}
function closeSettingsModal(){
  document.getElementById('settingsModal').style.display = 'none';
}
function changeFlowchartType(type){
  // Always vertical; ignore requested type
  const target = 'vertical';
  const current = localStorage.getItem('flowchartType') || 'vertical';
  if(current === target) return;
  localStorage.setItem('flowchartType', target);
  // Recreate all blocks with new connector positions (no-op if already vertical)
  const blocks = projectData.blocks.map(b => b);
  projectData.blocks = [];
  mainCanvas.querySelectorAll('.block').forEach(el => el.remove());
  blocks.forEach(blockData => {
    projectData.blocks.push(blockData);
    createInstance(blockData);
  });
  updateConnections();
}
function toggleArrowInversion(enabled){
  localStorage.setItem('arrowInversion', enabled ? 'true' : 'false');
  updateSettingsIdDisplay();
}
function toggleStrictBlockSelection(enabled){
  localStorage.setItem('strictBlockSelection', enabled ? 'true' : 'false');
  updateSettingsIdDisplay();
}
function toggleAutoSnapBlocks(enabled){
  localStorage.setItem('autoSnapBlocks', enabled ? 'true' : 'false');
  updateBlockSpacingSetting();
  updateAutoConnectBlocksSetting();
  updateSettingsIdDisplay();
}
function isAutoSnapBlocksEnabled(){
  return localStorage.getItem('autoSnapBlocks') === 'true';
}
function changeBlockSpacing(value){
  localStorage.setItem('blockSpacing', value);
  updateSettingsIdDisplay();
}
function getBlockSpacing(){
  const spacing = localStorage.getItem('blockSpacing') || 'optimal';
  if(spacing === 'min') return 35;
  if(spacing === 'max') return 80;
  return 50;
}
function toggleAutoConnectBlocks(enabled){
  localStorage.setItem('autoConnectBlocks', enabled ? 'true' : 'false');
  updateAutoConnectBlocksSetting();
  updateSettingsIdDisplay();
}
function isAutoConnectBlocksEnabled(){
  return localStorage.getItem('autoConnectBlocks') !== 'false';
}
function updateAutoConnectBlocksSetting(){
  const settingEl = document.getElementById('autoConnectBlocksSetting');
  const checkboxEl = document.getElementById('autoConnectBlocks');
  if(!settingEl || !checkboxEl) return;
  
  if(isAutoSnapBlocksEnabled()){
    settingEl.style.opacity = '1';
    settingEl.style.pointerEvents = 'auto';
  } else {
    settingEl.style.opacity = '0.5';
    settingEl.style.pointerEvents = 'none';
  }
}
function generateSettingsId(){
  const settings = {
    ft: localStorage.getItem('flowchartType') || 'vertical',
    sml: localStorage.getItem('showModsList') !== 'false' ? '1' : '0',
    am: localStorage.getItem('allFieldsMultiLine') === 'true' ? '1' : '0',
    aq: localStorage.getItem('autoCompleteQuotes') === 'true' ? '1' : '0',
    ai: localStorage.getItem('arrowInversion') === 'true' ? '1' : '0',
    ss: localStorage.getItem('strictBlockSelection') === 'true' ? '1' : '0',
    as: localStorage.getItem('autoSnapBlocks') === 'true' ? '1' : '0',
    ac: localStorage.getItem('autoConnectBlocks') !== 'false' ? '1' : '0',
    bs: localStorage.getItem('blockSpacing') || 'optimal',
    sc: localStorage.getItem('showConnectorLabels') !== 'false' ? '1' : '0',
    sf: localStorage.getItem('showFieldLabels') !== 'false' ? '1' : '0',
    cc: localStorage.getItem('showCompiledCode') === 'true' ? '1' : '0',
    bp: localStorage.getItem('showBlockPath') !== 'false' ? '1' : '0',
    wh: localStorage.getItem('warningHighlightStyle') || 'full',
    eh: localStorage.getItem('errorHighlightStyle') || 'full',
    sm: localStorage.getItem('safeMode') || 'restricted',
    ts: localStorage.getItem('tssSecurity') === 'true' ? '1' : '0'
  };
  const parts = [];
  if(settings.ft !== 'vertical') parts.push(`ft:${settings.ft}`);
  if(settings.sml !== '1') parts.push(`sml:${settings.sml}`);
  if(settings.am === '1') parts.push(`am:1`);
  if(settings.aq === '1') parts.push(`aq:1`);
  if(settings.ai === '1') parts.push(`ai:1`);
  if(settings.ss === '1') parts.push(`ss:1`);
  if(settings.as === '1') parts.push(`as:1`);
  if(settings.ac !== '1') parts.push(`ac:${settings.ac}`);
  if(settings.bs !== 'optimal') parts.push(`bs:${settings.bs}`);
  if(settings.sc !== '1') parts.push(`sc:${settings.sc}`);
  if(settings.sf !== '1') parts.push(`sf:${settings.sf}`);
  if(settings.cc !== '1') parts.push(`cc:${settings.cc}`);
  if(settings.bp !== '1') parts.push(`bp:${settings.bp}`);
  if(settings.wh !== 'full') parts.push(`wh:${settings.wh}`);
  if(settings.eh !== 'full') parts.push(`eh:${settings.eh}`);
  if(settings.sm !== 'restricted') parts.push(`sm:${settings.sm}`);
  if(settings.ts === '1') parts.push(`ts:1`);
  return parts.length > 0 ? parts.join('|') : 'default';
}
function parseSettingsId(id){
  if(!id || id.trim() === '' || id === 'default') return {};
  const parts = id.split('|');
  const settings = {};
  parts.forEach(part => {
    const [key, value] = part.split(':');
    if(key && value !== undefined) settings[key] = value;
  });
  return settings;
}
function applySettingsFromId(settings){
  if(settings.ft) changeFlowchartType(settings.ft);
  if(settings.sml !== undefined) toggleShowModsList(settings.sml === '1');
  if(settings.am !== undefined) toggleAllFieldsMultiLine(settings.am === '1');
  if(settings.aq !== undefined) toggleAutoCompleteQuotes(settings.aq === '1');
  if(settings.ai !== undefined) toggleArrowInversion(settings.ai === '1');
  if(settings.ss !== undefined) toggleStrictBlockSelection(settings.ss === '1');
  if(settings.as !== undefined) toggleAutoSnapBlocks(settings.as === '1');
  if(settings.ac !== undefined) toggleAutoConnectBlocks(settings.ac === '1');
  if(settings.bs) changeBlockSpacing(settings.bs);
  if(settings.sc !== undefined) toggleShowConnectorLabels(settings.sc === '1');
  if(settings.sf !== undefined) toggleShowFieldLabels(settings.sf === '1');
  if(settings.cc !== undefined) toggleShowCompiledCode(settings.cc === '1');
  if(settings.bp !== undefined) toggleShowBlockPath(settings.bp === '1');
  if(settings.wh) changeWarningHighlightStyle(settings.wh);
  if(settings.eh) changeErrorHighlightStyle(settings.eh);
  if(settings.sm) changeSafeMode(settings.sm);
  if(settings.ts !== undefined) toggleTssSecurity(settings.ts === '1');
}
function updateSettingsIdDisplay(){
  const displayEl = document.getElementById('settingsIdDisplay');
  if(displayEl){
    displayEl.value = generateSettingsId();
  }
}
function copySettingsId(){
  updateSettingsIdDisplay();
  const displayEl = document.getElementById('settingsIdDisplay');
  if(displayEl){
    displayEl.select();
    displayEl.setSelectionRange(0, 99999);
    try {
      document.execCommand('copy');
      showNotification('success', '–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω', '–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
    } catch(err) {
      navigator.clipboard.writeText(displayEl.value).then(() => {
        showNotification('success', '–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω', '–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–∫ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞');
      }).catch(() => {
        showNotification('error', '–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä');
      });
    }
  }
}
function applySettingsId(){
  const inputEl = document.getElementById('settingsIdInput');
  if(!inputEl) return;
  const id = inputEl.value.trim();
  if(!id){
    showNotification('error', '–û—à–∏–±–∫–∞', '–í–≤–µ–¥–∏—Ç–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–∫');
    return;
  }
  try {
    const settings = parseSettingsId(id);
    applySettingsFromId(settings);
    inputEl.value = '';
    openSettingsModal();
    showNotification('success', '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã', '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∏–∑ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞');
  } catch(err) {
    showNotification('error', '–û—à–∏–±–∫–∞', '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫');
  }
}
function updateBlockSpacingSetting(){
  const settingEl = document.getElementById('blockSpacingSetting');
  const selectEl = document.getElementById('blockSpacing');
  if(!settingEl || !selectEl) return;
  
  if(isAutoSnapBlocksEnabled()){
    settingEl.style.opacity = '1';
    settingEl.style.pointerEvents = 'auto';
  } else {
    settingEl.style.opacity = '0.5';
    settingEl.style.pointerEvents = 'none';
  }
}
function getSafeMode(){
  return localStorage.getItem('safeMode') || 'restricted';
}
function changeSafeMode(mode){
  localStorage.setItem('safeMode', mode);
  updateSafeModeSettingsUI();
  updateSettingsIdDisplay();
}
function updateSafeModeSettingsUI(){
  const currentMode = getSafeMode();
  document.querySelectorAll('input[name="settingsSafeMode"]').forEach(input=>{
    input.checked = input.value === currentMode;
  });
}
function isTssSecurityEnabled(){
  return localStorage.getItem('tssSecurityEnabled') !== 'false';
}
function toggleTssSecurity(enabled){
  localStorage.setItem('tssSecurityEnabled', enabled ? 'true' : 'false');
  updateTssSecurityDescription();
  updateSettingsIdDisplay();
}
function updateTssSecurityDescription(){
  const desc = document.getElementById('tssSecurityDescription');
  if(!desc) return;
  if(isTssSecurityEnabled()){
    desc.textContent = '–ö–æ–Ω—Ç—Ä–æ–ª—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∞–∫—Ç–∏–≤–µ–Ω: –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏ –±–ª–æ–∫–∏—Ä—É—é—Ç –∑–∞–ø—É—Å–∫ –∏ —Å–±–æ—Ä–∫—É.';
    desc.style.color = '#22c55e';
  } else {
    desc.textContent = '–ö–æ–Ω—Ç—Ä–æ–ª—å –æ—Ç–∫–ª—é—á—ë–Ω: –æ—à–∏–±–∫–∏ –∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –±—É–¥—É—Ç –ø—Ä–æ–ø—É—â–µ–Ω—ã.';
    desc.style.color = '#f87171';
  }
}
async function loadRequirementsFile(){
  const textarea = document.getElementById('requirementsEditor');
  if(!textarea) return;
  textarea.disabled = true;
  textarea.value = '–ó–∞–≥—Ä—É–∑–∫–∞...';
  try {
    const response = await fetch('/api/system/requirements');
    if(!response.ok) throw new Error('–°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É ' + response.status);
    const data = await response.json();
    if(data.status === 'success'){
      textarea.value = data.content || '';
    } else {
      textarea.value = data.message ? `–û—à–∏–±–∫–∞: ${data.message}` : '';
    }
  } catch (error) {
    textarea.value = `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ${error.message}`;
  } finally {
    textarea.disabled = false;
  }
}
async function saveRequirementsChanges(){
  const textarea = document.getElementById('requirementsEditor');
  const button = document.getElementById('saveRequirementsBtn');
  if(!textarea || !button) return;
  const originalText = button.textContent;
  button.disabled = true;
  button.textContent = '–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...';
  const ensureFlaskLine = (content) => {
    return content.split(/\r?\n/).some(line => line.trim().toLowerCase().startsWith('flask'));
  };
  if(!ensureFlaskLine(textarea.value)){
    showRequirementsStatusModal('error', 'Flask –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω', '–ù–µ–ª—å–∑—è —É–¥–∞–ª—è—Ç—å —Å—Ç—Ä–æ–∫—É "flask" –∏–∑ —Ñ–∞–π–ª–∞ requirements.txt.');
    button.disabled = false;
    button.textContent = originalText;
    return;
  }
  try {
    const response = await fetch('/api/system/requirements', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content: textarea.value })
    });
    const data = await response.json();
    if(data.status !== 'success'){
      throw new Error(data.message || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ–∞–π–ª');
    }
    showRequirementsStatusModal('success', '–ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã', '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –ª–∞—É–Ω—á–µ—Ä, —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤—Å—Ç—É–ø–∏–ª–∏ –≤ —Å–∏–ª—É.');
  } catch (error) {
    showRequirementsStatusModal('error', '–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è', '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å requirements.txt: ' + error.message);
  } finally {
    button.disabled = false;
    button.textContent = originalText;
  }
}
async function resetRequirementsToDefault(){
  const textarea = document.getElementById('requirementsEditor');
  try {
    const response = await fetch('/api/system/requirements/reset', { method:'POST' });
    if(!response.ok) throw new Error('–°–µ—Ä–≤–µ—Ä –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É ' + response.status);
    const data = await response.json();
    if(data.status !== 'success') throw new Error(data.message || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–±—Ä–æ—Å–∏—Ç—å requirements.txt');
    if(textarea) textarea.value = data.content || '';
    return { success: true };
  } catch (error) {
    console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–±—Ä–æ—Å–∏—Ç—å requirements.txt', error);
    return { success: false, message: error.message };
  }
}
function showRequirementsStatusModal(type, title, message){
  const modal = document.getElementById('requirementsStatusModal');
  const titleEl = document.getElementById('requirementsStatusModalTitle');
  const msgEl = document.getElementById('requirementsStatusModalMessage');
  if(titleEl) titleEl.textContent = title || '–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ';
  if(msgEl){
    msgEl.textContent = message || '';
    msgEl.style.color = type === 'error' ? '#f87171' : '#d1fae5';
  }
  if(modal) modal.style.display = 'block';
}
function closeRequirementsStatusModal(){
  const modal = document.getElementById('requirementsStatusModal');
  if(modal) modal.style.display = 'none';
}
function getFlowchartType(){
  return 'vertical';
}
function isArrowInversionEnabled(){
  return localStorage.getItem('arrowInversion') === 'true';
}
function openResetSettingsModal(){
  document.getElementById('resetSettingsModal').style.display = 'block';
}
function closeResetSettingsModal(){
  document.getElementById('resetSettingsModal').style.display = 'none';
}
async function confirmResetSettings(){
  changeFlowchartType('vertical');
  const flowVertical = document.getElementById('flowchartTypeVertical');
  if(flowVertical) flowVertical.checked = true;

  toggleShowModsList(true);
  const modsList = document.getElementById('showModsList');
  if(modsList) modsList.checked = true;

  toggleAllFieldsMultiLine(false);
  const multiLine = document.getElementById('allFieldsMultiLine');
  if(multiLine) multiLine.checked = false;

  toggleAutoCompleteQuotes(false);
  const autoQuotes = document.getElementById('autoCompleteQuotes');
  if(autoQuotes) autoQuotes.checked = false;

  toggleArrowInversion(false);
  const arrow = document.getElementById('arrowInversion');
  if(arrow) arrow.checked = false;

  toggleStrictBlockSelection(false);
  const strictSelection = document.getElementById('strictBlockSelection');
  if(strictSelection) strictSelection.checked = false;

  toggleAutoSnapBlocks(false);
  const autoSnap = document.getElementById('autoSnapBlocks');
  if(autoSnap) autoSnap.checked = false;
  toggleAutoConnectBlocks(true);
  const autoConnect = document.getElementById('autoConnectBlocks');
  if(autoConnect) autoConnect.checked = true;
  changeBlockSpacing('optimal');
  const blockSpacingEl = document.getElementById('blockSpacing');
  if(blockSpacingEl) blockSpacingEl.value = 'optimal';
  updateBlockSpacingSetting();
  updateAutoConnectBlocksSetting();

  changeWarningHighlightStyle('full');
  const warningFull = document.getElementById('warningHighlightStyleFull');
  if(warningFull) warningFull.checked = true;

  changeErrorHighlightStyle('full');
  const errorFull = document.getElementById('errorHighlightStyleFull');
  if(errorFull) errorFull.checked = true;

  toggleShowConnectorLabels(true);
  const connectorLabels = document.getElementById('showConnectorLabels');
  if(connectorLabels) connectorLabels.checked = true;

  toggleShowFieldLabels(true);
  const fieldLabels = document.getElementById('showFieldLabels');
  if(fieldLabels) fieldLabels.checked = true;

  toggleShowSelectionSummary(true);
  const selectionSummary = document.getElementById('showSelectionSummary');
  if(selectionSummary) selectionSummary.checked = true;

  toggleShowBlockPath(true);
  const showBlockPathEl = document.getElementById('showBlockPath');
  if(showBlockPathEl) showBlockPathEl.checked = true;

  toggleShowCompiledCode(false);
  const compiledCode = document.getElementById('showCompiledCode');
  if(compiledCode) compiledCode.checked = false;

  localStorage.setItem('safeMode', 'restricted');
  updateSafeModeSettingsUI();

  toggleTssSecurity(true);
  const tssToggle = document.getElementById('tssSecurityToggle');
  if(tssToggle) tssToggle.checked = true;

  const resetRequirementsResult = await resetRequirementsToDefault();
  closeResetSettingsModal();

  if(typeof showNotification === 'function'){
    if(resetRequirementsResult && resetRequirementsResult.success){
      showNotification('success', '–ù–∞—Å—Ç—Ä–æ–π–∫–∏', '–í—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é. requirements.txt –æ–±–Ω–æ–≤–ª–µ–Ω –∏–∑ static/req.');
    } else if(resetRequirementsResult && !resetRequirementsResult.success){
      showNotification('error', '–ù–∞—Å—Ç—Ä–æ–π–∫–∏', '–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–±—Ä–æ—à–µ–Ω—ã, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å requirements.txt: ' + (resetRequirementsResult.message || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'));
    } else {
      showNotification('success', '–ù–∞—Å—Ç—Ä–æ–π–∫–∏', '–í—Å–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.');
    }
  }
}
function updateBlockHighlighting(){
  const warningStyle = getWarningHighlightStyle();
  const errorStyle = getErrorHighlightStyle();
  
  // Use global sets from updateIssues
  const warningBlocks = globalWarningBlocks;
  const errorBlocks = globalErrorBlocks;
  
  // Remove all highlight classes first
  mainCanvas.querySelectorAll('.block').forEach(el=>{ 
    el.classList.remove('block-warning','block-error','highlight-outline','highlight-symbol','highlight-none'); 
  });
  
  // Apply warning highlights
  warningBlocks.forEach(id=>{
    if(!errorBlocks.has(id) && !isBlockIgnored(id)){
      const el = mainCanvas.querySelector(`.block[data-block-id="${id}"]`);
      if(el) {
        el.classList.add('block-warning');
        const ind = el.querySelector('.block-indicator');
        
        if(warningStyle === 'outline'){
          el.classList.add('highlight-outline');
          if(ind) ind.style.display = 'none';
        } else if(warningStyle === 'symbol'){
          el.classList.add('highlight-symbol');
          if(ind){ ind.style.display='flex'; ind.classList.add('indicator-warning'); ind.textContent='!'; }
        } else if(warningStyle === 'none'){
          el.classList.add('highlight-none');
          if(ind) ind.style.display = 'none';
        } else { // full
          if(ind){ ind.style.display='flex'; ind.classList.add('indicator-warning'); ind.textContent='!'; }
        }
      }
    }
  });
  
  // Apply error highlights
  errorBlocks.forEach(id=>{
    if(!isBlockIgnored(id)){
      const el = mainCanvas.querySelector(`.block[data-block-id="${id}"]`);
      if(el){
        el.classList.remove('block-warning');
        el.classList.add('block-error');
        const ind = el.querySelector('.block-indicator');
        
        if(errorStyle === 'outline'){
          el.classList.add('highlight-outline');
          if(ind) ind.style.display = 'none';
        } else if(errorStyle === 'symbol'){
          el.classList.add('highlight-symbol');
          if(ind){ ind.style.display='flex'; ind.classList.add('indicator-error'); ind.textContent='‚úï'; }
        } else if(errorStyle === 'none'){
          el.classList.add('highlight-none');
          if(ind) ind.style.display = 'none';
        } else { // full
          if(ind){ ind.style.display='flex'; ind.classList.add('indicator-error'); ind.textContent='‚úï'; }
        }
      }
    }
  });
}
function changeWarningHighlightStyle(style){
  localStorage.setItem('warningHighlightStyle', style);
  updateBlockHighlighting();
  updateSettingsIdDisplay();
}
function changeErrorHighlightStyle(style){
  localStorage.setItem('errorHighlightStyle', style);
  updateBlockHighlighting();
  updateSettingsIdDisplay();
}
function toggleShowModsList(enabled){
  localStorage.setItem('showModsList', enabled ? 'true' : 'false');
  const modsSection = document.querySelector('.mods-section');
  if(modsSection) modsSection.style.display = enabled ? '' : 'none';
  
  // If mods list is disabled, automatically enable all mods
  if(!enabled){
    const mods = summarizeMods();
    mods.forEach(m => {
      setModEnabled(m.modId, true);
    });
    // Reload blocks config to apply all mods
    loadBlocksConfig().then(() => {
      // Recreate all blocks with new mods
      const blocks = projectData.blocks.map(b => b);
      projectData.blocks = [];
      mainCanvas.querySelectorAll('.block').forEach(el => el.remove());
      blocks.forEach(blockData => {
        projectData.blocks.push(blockData);
        createInstance(blockData);
      });
      updateConnections();
      updateCounts();
    });
  } else {
    // If mods list is enabled, render the panel
    renderModsPanel();
  }
  updateSettingsIdDisplay();
}
function toggleShowConnectorLabels(enabled){
  localStorage.setItem('showConnectorLabels', enabled ? 'true' : 'false');
  // Update connector tooltips visibility
  mainCanvas.querySelectorAll('.connector').forEach(conn => {
    if(conn._tooltip) {
      conn._tooltip.style.display = enabled ? '' : 'none';
    }
  });
  updateSettingsIdDisplay();
}
function toggleShowFieldLabels(enabled){
  localStorage.setItem('showFieldLabels', enabled ? 'true' : 'false');
  // Update field tooltips visibility
  mainCanvas.querySelectorAll('input, textarea').forEach(input => {
    if(input._tooltip) {
      input._tooltip.style.display = enabled ? '' : 'none';
    }
  });
  updateSettingsIdDisplay();
}
function toggleShowSelectionSummary(enabled){
  localStorage.setItem('showSelectionSummary', enabled ? 'true' : 'false');
  // Selection summary is handled in selection code
}
function toggleShowBlockPath(enabled){
  localStorage.setItem('showBlockPath', enabled ? 'true' : 'false');
  updateSettingsIdDisplay();
}
function toggleAllFieldsMultiLine(enabled){
  localStorage.setItem('allFieldsMultiLine', enabled ? 'true' : 'false');
  updateSettingsIdDisplay();
}

function isAutoCompleteQuotesEnabled(){
  return localStorage.getItem('autoCompleteQuotes') === 'true';
}

function toggleAutoCompleteQuotes(enabled){
  localStorage.setItem('autoCompleteQuotes', enabled ? 'true' : 'false');
  updateSettingsIdDisplay();
}

function handleAutoCompleteQuotes(e){
  // Only handle if auto-complete is enabled
  if (!isAutoCompleteQuotesEnabled()) return;
  
  const input = e.target;
  const key = e.key;
  const start = input.selectionStart;
  const end = input.selectionEnd;
  const value = input.value;
  
  // Pairs: opening -> closing
  const pairs = {
    '"': '"',
    "'": "'",
    '(': ')',
    '[': ']',
    '{': '}'
  };
  
  // Check if user typed an opening quote/bracket
  if (pairs[key]) {
    // Check if there's selected text
    if (start !== end) {
      // Wrap selected text
      const selectedText = value.substring(start, end);
      const newValue = value.substring(0, start) + key + selectedText + pairs[key] + value.substring(end);
      input.value = newValue;
      input.setSelectionRange(start + 1, start + 1 + selectedText.length);
      e.preventDefault();
      return;
    }
    
    // Check if next character is already the closing pair (don't duplicate)
    const nextChar = value.substring(end, end + 1);
    if (nextChar === pairs[key]) {
      // Just move cursor forward
      input.setSelectionRange(end + 1, end + 1);
      e.preventDefault();
      return;
    }
    
    // Insert opening and closing pair, place cursor between them
    const newValue = value.substring(0, start) + key + pairs[key] + value.substring(end);
    input.value = newValue;
    input.setSelectionRange(start + 1, start + 1);
    e.preventDefault();
    return;
  }
  
  // Handle closing brackets/quotes - skip if already there
  if (key === ')' || key === ']' || key === '}') {
    const nextChar = value.substring(end, end + 1);
    if (nextChar === key) {
      // Skip over the closing bracket
      input.setSelectionRange(end + 1, end + 1);
      e.preventDefault();
      return;
    }
  }
  
  // Handle backspace - delete both if cursor is between matching pairs
  if (key === 'Backspace' && start === end && start > 0) {
    const charBefore = value.substring(start - 1, start);
    const charAfter = value.substring(start, start + 1);
    
    // Check if we're between matching pairs
    for (const [open, close] of Object.entries(pairs)) {
      if (charBefore === open && charAfter === close) {
        // Delete both
        const newValue = value.substring(0, start - 1) + value.substring(start + 1);
        input.value = newValue;
        input.setSelectionRange(start - 1, start - 1);
        e.preventDefault();
        return;
      }
    }
  }
}

function isAutoCompleteQuotesEnabled(){
  return localStorage.getItem('autoCompleteQuotes') === 'true';
}

function toggleAutoCompleteQuotes(enabled){
  localStorage.setItem('autoCompleteQuotes', enabled ? 'true' : 'false');
  // Re-apply to all existing fields
  const allInputs = mainCanvas.querySelectorAll('input.field-input, textarea.field-input');
  allInputs.forEach(input => {
    // Remove old listeners by cloning
    const newInput = input.cloneNode(true);
    input.parentNode.replaceChild(newInput, input);
    
    // Re-attach all necessary listeners based on field type
    // This is simplified - in real implementation, we'd need to restore all listeners
    // For now, we'll just add the auto-complete listener if enabled
    if (enabled) {
      newInput.addEventListener('keydown', handleAutoCompleteQuotes);
    }
    
    // Restore value
    newInput.value = input.value;
  });
  updateSettingsIdDisplay();
}

function handleAutoCompleteQuotes(e){
  // Only handle if auto-complete is enabled
  if (!isAutoCompleteQuotesEnabled()) return;
  
  const input = e.target;
  const key = e.key;
  const start = input.selectionStart;
  const end = input.selectionEnd;
  const value = input.value;
  
  // Pairs: opening -> closing
  const pairs = {
    '"': '"',
    "'": "'",
    '(': ')',
    '[': ']',
    '{': '}'
  };
  
  // Check if user typed an opening quote/bracket
  if (pairs[key]) {
    // Check if there's selected text
    if (start !== end) {
      // Wrap selected text
      const selectedText = value.substring(start, end);
      const newValue = value.substring(0, start) + key + selectedText + pairs[key] + value.substring(end);
      input.value = newValue;
      input.setSelectionRange(start + 1, start + 1 + selectedText.length);
      e.preventDefault();
      return;
    }
    
    // Check if next character is already the closing pair (don't duplicate)
    const nextChar = value.substring(end, end + 1);
    if (nextChar === pairs[key]) {
      // Just move cursor forward
      input.setSelectionRange(end + 1, end + 1);
      e.preventDefault();
      return;
    }
    
    // Insert opening and closing pair, place cursor between them
    const newValue = value.substring(0, start) + key + pairs[key] + value.substring(end);
    input.value = newValue;
    input.setSelectionRange(start + 1, start + 1);
    e.preventDefault();
    return;
  }
  
  // Handle closing brackets/quotes - skip if already there
  if (key === ')' || key === ']' || key === '}') {
    const nextChar = value.substring(end, end + 1);
    if (nextChar === key) {
      // Skip over the closing bracket
      input.setSelectionRange(end + 1, end + 1);
      e.preventDefault();
      return;
    }
  }
  
  // Handle backspace - delete both if cursor is between matching pairs
  if (key === 'Backspace' && start === end && start > 0) {
    const charBefore = value.substring(start - 1, start);
    const charAfter = value.substring(start, start + 1);
    
    // Check if we're between matching pairs
    for (const [open, close] of Object.entries(pairs)) {
      if (charBefore === open && charAfter === close) {
        // Delete both
        const newValue = value.substring(0, start - 1) + value.substring(start + 1);
        input.value = newValue;
        input.setSelectionRange(start - 1, start - 1);
        e.preventDefault();
        return;
      }
    }
  }
}
function toggleShowCompiledCode(enabled){
  localStorage.setItem('showCompiledCode', enabled ? 'true' : 'false');
  updateSettingsIdDisplay();
}
function getWarningHighlightStyle(){
  return localStorage.getItem('warningHighlightStyle') || 'full';
}
function getErrorHighlightStyle(){
  return localStorage.getItem('errorHighlightStyle') || 'full';
}
function isShowModsListEnabled(){
  return localStorage.getItem('showModsList') !== 'false';
}
function isShowConnectorLabelsEnabled(){
  return localStorage.getItem('showConnectorLabels') !== 'false';
}
function isShowFieldLabelsEnabled(){
  return localStorage.getItem('showFieldLabels') !== 'false';
}
function isShowSelectionSummaryEnabled(){
  return localStorage.getItem('showSelectionSummary') !== 'false';
}
function updateProjectNameDisplay(){
  const currentProject = localStorage.getItem('currentProject');
  const displayEl = document.getElementById('projectNameDisplay');
  if(displayEl){
    if(currentProject){
      const name = currentProject.replace('.turtcd', '');
      const hasUnsaved = hasUnsavedChanges();
      displayEl.textContent = hasUnsaved ? `${name}*` : name;
    } else {
      const hasUnsaved = hasUnsavedChanges();
      displayEl.textContent = hasUnsaved ? '–ü—Ä–æ–µ–∫—Ç*' : '–ü—Ä–æ–µ–∫—Ç';
    }
  }
}
function updateSaveStatusIndicator(){
  const indicator = document.getElementById('saveStatusIndicator');
  if(!indicator) return;
  
  const hasUnsaved = hasUnsavedChanges();
  if(hasUnsaved){
    indicator.style.borderColor = 'rgba(234,179,8,0.5)';
    indicator.style.color = '#eab308';
    indicator.innerHTML = '<span>‚ö†</span><span>–ò–∑–º–µ–Ω–µ–Ω–∏—è –Ω–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã</span>';
  } else {
    indicator.style.borderColor = 'rgba(34,197,94,0.3)';
    indicator.style.color = '#22c55e';
    indicator.innerHTML = '<span>‚úì</span><span>–ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã</span>';
  }
  
  updateProjectNameDisplay();
  updateRevertButton();
}
function updateRevertButton(){
  const revertBtn = document.getElementById('revertChangesBtn');
  if(!revertBtn) return;
  
  const hasUnsaved = hasUnsavedChanges();
  if(hasUnsaved){
    revertBtn.disabled = false;
    revertBtn.style.opacity = '1';
    revertBtn.style.cursor = 'pointer';
  } else {
    revertBtn.disabled = true;
    revertBtn.style.opacity = '0.5';
    revertBtn.style.cursor = 'not-allowed';
  }
}
function revertChanges(){
  if(!_savedSnapshot || !hasUnsavedChanges()) return;
  
  openRevertChangesModal();
}

function openRevertChangesModal(){
  document.getElementById('revertChangesModal').style.display = 'block';
}

function closeRevertChangesModal(){
  document.getElementById('revertChangesModal').style.display = 'none';
}

function confirmRevertChanges(){
  closeRevertChangesModal();
  
  if(!_savedSnapshot || !hasUnsavedChanges()) return;
  
  try {
    const savedProject = JSON.parse(_savedSnapshot);
    const restoredProject = {
      ...projectData,
      blocks: savedProject.blocks || [],
      connections: savedProject.connections || []
    };
    
    if(savedProject.variableTags){
      variableTags = savedProject.variableTags;
      try {
        localStorage.setItem('turtcd_variable_tags', JSON.stringify(variableTags));
      } catch(e) {}
    }
    
    loadProjectFromObject(restoredProject);
    markProjectSaved();
    updateSaveStatusIndicator();
    updateCounts();
    renderVariableRegistry();
    updateBlockHighlighting();
  } catch(e){
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–∞—Ç–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π:', e);
    alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫–∞—Ç–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ–µ–∫—Ç.');
  }
}
async function confirmExportTurtcd(){
  const name = (document.getElementById('exportFilename').value || 'project').trim();
  // –í–∫–ª—é—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã –∏ —Ç–µ–≥–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ —ç–∫—Å–ø–æ—Ä—Ç
  const projectDataWithCamera = {
    ...projectData,
    camera: { x: camera.x, y: camera.y, scale: camera.scale },
    variableTags: variableTags
  };
  const data = JSON.stringify(projectDataWithCamera, null, 2);

  // –ü—ã—Ç–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å File System Access API, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
  try {
    if (window.showSaveFilePicker) {
      const handle = await window.showSaveFilePicker({
        suggestedName: name + '.turtcd',
        types: [{ description: 'TurtCD Project', accept: { 'application/json': ['.turtcd'] } }]
      });
      const writable = await handle.createWritable();
      await writable.write(new Blob([data], { type: 'application/json' }));
      await writable.close();
      closeExportModal();
      showNotification && showNotification('success', '–≠–∫—Å–ø–æ—Ä—Ç', '–§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω');
      // –≠–∫—Å–ø–æ—Ä—Ç –º–æ–∂–Ω–æ —Å—á–∏—Ç–∞—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
      markProjectSaved();
      return;
    }
  } catch(e) {
    console.warn('File System Access API error', e);
  }

  // –§–æ–ª–ª–±—ç–∫: —Å–∫–∞—á–∏–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ —Å—Å—ã–ª–∫—É
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = name + '.turtcd';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  closeExportModal();
  // –≠–∫—Å–ø–æ—Ä—Ç –º–æ–∂–Ω–æ —Å—á–∏—Ç–∞—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Ç–µ–∫—É—â–µ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
  markProjectSaved();
}

async function saveProject(){
  const currentProject = localStorage.getItem('currentProject');
  if (!currentProject) {
    showNotification('error', '–û—à–∏–±–∫–∞', '–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π –ø—Ä–æ–µ–∫—Ç.');
    return;
  }
  
  try {
    // –í–∫–ª—é—á–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã –∏ —Ç–µ–≥–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –≤ –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ–µ–∫—Ç–∞
    const projectDataWithCamera = {
      ...projectData,
      camera: {
        x: camera.x,
        y: camera.y,
        scale: camera.scale
      },
      variableTags: variableTags
    };
    
    const resp = await fetch('/api/project/save-file', { 
      method:'POST', 
      headers:{'Content-Type':'application/json'}, 
      body: JSON.stringify({ 
        filename: currentProject, 
        project_data: projectDataWithCamera 
      })
    });
    const j = await resp.json();
    if(j.status === 'success') { 
      showNotification('success', '–£—Å–ø–µ—Ö', '–ü—Ä–æ–µ–∫—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω: ' + currentProject);
      markProjectSaved();
      updateProjectNameDisplay();
      updateProjectNameDisplay();
    } else {
      showNotification('error', '–û—à–∏–±–∫–∞', '–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ' + (j.message || 'unknown'));
    }
  } catch(err){ 
    showNotification('error', '–û—à–∏–±–∫–∞', '–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ' + err.message);
  }
}

function importFromFile(ev){
  const f = ev.target.files && ev.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const parsed = JSON.parse(e.target.result);
      if(parsed && parsed.blocks){
        loadProjectFromObject(parsed);
      } else alert('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞');
    } catch(err){ alert('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞: ' + err.message); }
  };
  reader.readAsText(f);
  // reset
  ev.target.value = '';
}

function loadProjectFromObject(obj){
  // clear canvas
  mainCanvas.querySelectorAll('.block').forEach(n=>n.remove());
  projectData = obj;
  updateProjectNameDisplay();
  // –ì–ª–æ–±–∞–ª—å–Ω–æ–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–∫–ª—é—á–µ–Ω–æ, –µ—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω–æ –≤ –ø—Ä–æ–µ–∫—Ç–µ
  if (typeof projectData.globalIgnore === 'undefined') {
    projectData.globalIgnore = false;
  }

  // –û–±–Ω–æ–≤–∏–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–æ–∫ –ø—Ä–∞–≤–æ–π –ø–∞–Ω–µ–ª–∏
  try {
    updateGlobalIgnoreButtonState && updateGlobalIgnoreButtonState();
  } catch(_) {}
  
  // –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º–∏ –ø—Ä–æ–µ–∫—Ç–∞–º–∏ - –¥–æ–±–∞–≤–ª—è–µ–º —Ü–≤–µ—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  if (projectData.connections) {
    projectData.connections.forEach(connection => {
      if (!connection.color) connection.color = 'system';
    });
  }
  
  // –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º–∏ –ø—Ä–æ–µ–∫—Ç–∞–º–∏ - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º fieldTypes
  if (projectData.blocks) {
    projectData.blocks.forEach(block => {
      if (!block.fieldTypes) {
        block.fieldTypes = {};
        // –î–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –±–ª–æ–∫–æ–≤ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–¥–Ω–æ—Å—Ç—Ä–æ—á–Ω—ã–µ –ø–æ–ª—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        const cfg = findCfg(block.template);
        if (cfg && cfg.fields) {
          cfg.fields.forEach(f => {
            block.fieldTypes[f.name] = 'single-line';
          });
        }
      }
    });
  }
  
  // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–≥–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, –µ—Å–ª–∏ –æ–Ω–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ –ø—Ä–æ–µ–∫—Ç–µ
  if (obj.variableTags) {
    variableTags = obj.variableTags;
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
    try { 
      localStorage.setItem('turtcd_variable_tags', JSON.stringify(variableTags)); 
    } catch(e) {}
  }
  
  // create instances
  projectData.blocks.forEach(b => createInstance(b));
  updateConnections();
  updateCounts();
  // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –∑–Ω–∞—á–µ–Ω–∏–π –∏–∑ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞
  loadValueHistory();
  
  // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã –∏–∑ localStorage (–∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –∏–º–µ–µ—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
  loadCameraPosition();
  // –ï—Å–ª–∏ –≤ –ø—Ä–æ–µ–∫—Ç–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –ø–æ–∑–∏—Ü–∏—è –∫–∞–º–µ—Ä—ã –∏ –Ω–µ—Ç –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω–æ–π - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–∑ –ø—Ä–æ–µ–∫—Ç–∞
  if (obj.camera && !localStorage.getItem(`turtcd_camera_${localStorage.getItem('currentProject')}`)) {
    camera.x = obj.camera.x || 0;
    camera.y = obj.camera.y || 0;
    camera.scale = obj.camera.scale || 1;
    updateCamera();
    saveCameraPosition();
  }

  // –ü–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–µ–∫—Ç —Å—á–∏—Ç–∞–µ—Ç—Å—è —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–º
  markProjectSaved();
  updateSaveStatusIndicator();

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–µ–∑–Ω–∞–∫–æ–º—ã–µ –±–ª–æ–∫–∏
  try {
    const unknown = [];
    for (const b of (projectData.blocks || [])) {
      if (!findCfg(b.template)) {
        unknown.push(b.template);
      }
    }
    if (unknown.length) {
      showUnknownBlocksModal(Array.from(new Set(unknown)));
    }
  } catch(e) { console.warn('Unknown blocks check failed', e); }
}

/* Server save modal */
function openSaveModal(){ document.getElementById('saveModal').style.display = 'block'; }
function closeSaveModal(){ document.getElementById('saveModal').style.display = 'none'; }
async function saveToServer(){
  const filename = document.getElementById('saveFilename').value.trim();
  if(!filename){ alert('–í–≤–µ–¥–∏—Ç–µ –∏–º—è —Ñ–∞–π–ª–∞'); return; }
  try {
    const resp = await fetch('/api/project/save-file', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ filename: filename + '.turtcd', project_data: projectData })});
    const j = await resp.json();
    if(j.status === 'success') { 
      localStorage.setItem('currentProject', j.filename);
      updateProjectNameDisplay();
      alert('–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ: ' + j.filename); 
      closeSaveModal(); 
    }
    else alert('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ' + (j.message || 'unknown'));
  } catch(err){ alert('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ' + err.message); }
}

/* Server list */
async function showServerProjects(){
  try {
    const r = await fetch('/api/project/list');
    const j = await r.json();
    if(j.status !== 'success'){ alert('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞'); return; }
    const listDiv = document.getElementById('serverList');
    listDiv.innerHTML = '';
    if(j.projects.length === 0) listDiv.appendChild(el('div', {}, '–ù–µ—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤'));
    j.projects.forEach(fn => {
      const row = el('div', {}, fn);
      row.style.display = 'flex'; row.style.justifyContent = 'space-between'; row.style.alignItems = 'center'; row.style.padding = '6px 0';
      const btn = document.createElement('button');
      btn.className = 'btn-ghost';
      btn.textContent = '–ó–∞–≥—Ä—É–∑–∏—Ç—å';
      btn.addEventListener('click', ()=> loadProjectFromServer(fn));
      row.appendChild(btn);
      listDiv.appendChild(row);
    });
    document.getElementById('serverModal').style.display = 'block';
  } catch(err){ alert('–û—à–∏–±–∫–∞: ' + err.message); }
}
function closeServerModal(){ document.getElementById('serverModal').style.display = 'none'; }
async function loadProjectFromServer(filename){
  try {
    const resp = await fetch('/api/project/load-file', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ filename })});
    const j = await resp.json();
    if(j.status === 'success' && j.project_data){
      localStorage.setItem('currentProject', filename);
      loadProjectFromObject(j.project_data);
      updateProjectNameDisplay();
      closeServerModal();
    } else alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ' + (j.message || 'unknown'));
  } catch(err){ alert('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ' + err.message); }
}

/* ========== Compile ========== */
async function compileProject(){
  // –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –∫–æ–º–ø–∏–ª—è—Ü–∏–µ–π
  await saveProject();
  const tssSecurityEnabled = isTssSecurityEnabled();
  
  // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
  console.log('–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞ –Ω–∞ –ø—É—Å—Ç–æ—Ç—É...');
  console.log('–ë–ª–æ–∫–∏ –≤ –ø—Ä–æ–µ–∫—Ç–µ:', projectData.blocks.length);
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –ø—É—Å—Ç–æ–π –ø—Ä–æ–µ–∫—Ç
  if (isProjectEmpty()) {
    console.log('–ü—Ä–æ–µ–∫—Ç —Å—á–∏—Ç–∞–µ—Ç—Å—è –ø—É—Å—Ç—ã–º');
    if (tssSecurityEnabled) {
      showEmptyProjectModal();
      return;
    } else {
      console.warn('TSS –æ—Ç–∫–ª—é—á—ë–Ω: –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –ø—É—Å—Ç–æ–º –ø—Ä–æ–µ–∫—Ç–µ');
    }
  }
  
  console.log('–ü—Ä–æ–µ–∫—Ç –Ω–µ –ø—É—Å—Ç–æ–π, –ø—Ä–æ–≤–µ—Ä—è–µ–º header –±–ª–æ–∫–∏...');
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ header –±–ª–æ–∫–æ–≤
  if (!hasHeaderBlocks()) {
    console.log('Header –±–ª–æ–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã');
    if (tssSecurityEnabled) {
      showNoHeaderBlocksModal();
      return;
    } else {
      console.warn('TSS –æ—Ç–∫–ª—é—á—ë–Ω: –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å–±–æ—Ä–∫—É –±–µ–∑ –±–ª–æ–∫–∞ "–ù–∞—á–∞–ª–æ"');
    }
  }
  
  console.log('Header –±–ª–æ–∫–∏ –Ω–∞–π–¥–µ–Ω—ã, –ø—Ä–æ–≤–µ—Ä—è–µ–º –æ—à–∏–±–∫–∏...');
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ—à–∏–±–æ–∫ –∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π
  const issues = checkForIssues();
  // –ë–ª–æ–∫–∏—Ä—É–µ–º —Å–±–æ—Ä–∫—É –ø—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –æ—à–∏–±–æ–∫ (errors > 0).
  // –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–æ–ª—å–∫–æ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–±—ã—á–Ω—ã–π –º–æ–¥–∞–ª —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è.
  if (issues.errors > 0) {
    console.log('–ù–∞–π–¥–µ–Ω—ã –æ—à–∏–±–∫–∏, —Å–±–æ—Ä–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞:', issues);
    if (tssSecurityEnabled) {
      showCompileBlockedModal(issues.errors);
      return;
    } else {
      console.warn('TSS –æ—Ç–∫–ª—é—á—ë–Ω: –æ—à–∏–±–∫–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è, —Å–±–æ—Ä–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è');
    }
  } else if (issues.warnings > 0) {
    console.log('–ù–∞–π–¥–µ–Ω—ã –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è:', issues.warnings);
    if (tssSecurityEnabled) {
      showErrorWarningModal(issues);
      return;
    } else {
      console.warn('TSS –æ—Ç–∫–ª—é—á—ë–Ω: –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω—ã');
    }
  }
  
  console.log('–í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã, –Ω–∞—á–∏–Ω–∞–µ–º –∫–æ–º–ø–∏–ª—è—Ü–∏—é...');
  
  // –ï—Å–ª–∏ –æ—à–∏–±–æ–∫ –Ω–µ—Ç, –∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º —Å—Ä–∞–∑—É
  await performCompilation();
}

function checkForIssues() {
  const panel = document.getElementById('issuesPanel');
  if (!panel) return { hasIssues: false, warnings: 0, errors: 0 };
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å –∫–ª–∞—Å—Å–∞–º–∏ issue warning –∏–ª–∏ issue error
  const warnings = panel.querySelectorAll('.issue.warning');
  const errors = panel.querySelectorAll('.issue.error');
  
  return {
    hasIssues: warnings.length > 0 || errors.length > 0,
    warnings: warnings.length,
    errors: errors.length
  };
}

function showErrorWarningModal(issues) {
  const modal = document.getElementById('errorWarningModal');
  const ignoreBtn = document.getElementById('ignoreErrorsBtn');
  const warningCountEl = document.getElementById('warningCount');
  
  // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫–∏
  warningCountEl.textContent = issues.warnings;
  
  modal.style.display = 'flex';
  ignoreBtn.disabled = true;
  ignoreBtn.textContent = '–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å (3—Å)';
  
  // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –Ω–∞ 3 —Å–µ–∫—É–Ω–¥—ã
  let countdown = 3;
  const timer = setInterval(() => {
    countdown--;
    if (countdown > 0) {
      ignoreBtn.textContent = `–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å (${countdown}—Å)`;
    } else {
      ignoreBtn.disabled = false;
      ignoreBtn.textContent = '–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å';
      clearInterval(timer);
    }
  }, 1000);
  
  // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –º–æ–¥–∞–ª–∞
  modal._timer = timer;
}

function closeErrorWarningModal() {
  const modal = document.getElementById('errorWarningModal');
  if (modal._timer) {
    clearInterval(modal._timer);
    modal._timer = null;
  }
  modal.style.display = 'none';
}

function openRgbPickerModal(){
  const modal = document.getElementById('rgbPickerModal');
  const input = document.getElementById('rgbColorInput');
  const val = document.getElementById('rgbColorValue');
  if(!modal || !input || !val) return;
  val.value = input.value || '#ffffff';
  updateRgbFontPreview();
  modal.style.display = 'block';
}
function closeRgbPickerModal(){
  const modal = document.getElementById('rgbPickerModal');
  if(modal) modal.style.display = 'none';
}
function copyRgbValue(){
  const val = document.getElementById('rgbColorValue');
  if(!val) return;
  const text = val.value || '';
  if(text && navigator.clipboard){
    navigator.clipboard.writeText(text).catch(()=>{});
  }
}
function updateRgbFontPreview(){
  const fontSel = document.getElementById('rgbFontSelector');
  const fontSizeEl = document.getElementById('rgbFontSize');
  const preview = document.getElementById('rgbFontPreview');
  const info = document.getElementById('rgbFontInfo');
  if(!fontSel || !fontSizeEl || !preview || !info) return;
  const font = fontSel.value || 'Arial';
  const size = Math.max(6, Math.min(72, parseInt(fontSizeEl.value || '14', 10)));
  preview.style.fontFamily = font;
  preview.style.fontSize = size + 'px';
  info.textContent = `${font}, ${size}`;
  fontSizeEl.value = size;
}
document.addEventListener('DOMContentLoaded', ()=>{
  const input = document.getElementById('rgbColorInput');
  const val = document.getElementById('rgbColorValue');
  if(input && val){
    input.addEventListener('input', ()=>{
      val.value = input.value || '';
    });
  }
  const fontSel = document.getElementById('rgbFontSelector');
  const fontSizeEl = document.getElementById('rgbFontSize');
  if(fontSel) fontSel.addEventListener('change', updateRgbFontPreview);
  if(fontSizeEl) fontSizeEl.addEventListener('input', updateRgbFontPreview);
  updateRgbFontPreview();
});

/* Compile blocked modal handlers */
function showCompileBlockedModal(errorCount){
  const modal = document.getElementById('compileBlockedModal');
  const el = document.getElementById('compileBlockedErrorCount');
  if(el) el.textContent = errorCount || 0;
  modal.style.display = 'flex';
}

function closeCompileBlockedModal(){
  const modal = document.getElementById('compileBlockedModal');
  modal.style.display = 'none';
}

// –°–ª–µ–¥–∏–º –∑–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏ –≤ –ø–∞–Ω–µ–ª–∏ issues –∏ –æ–±–Ω–æ–≤–ª—è–µ–º —Å–≤–æ–¥–∫—É –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö
(function attachIssuesObserver(){
  const panel = document.getElementById('issuesPanel');
  if(!panel) return;
  try{
    const mo = new MutationObserver(() => {
      if(typeof updateSelectionSummary === 'function') updateSelectionSummary();
    });
    mo.observe(panel, { childList: true, subtree: true, attributes: true, characterData: true });
  } catch(e){ console.warn('Issues observer could not be attached', e); }
})();

/* Unknown blocks modal */
function showUnknownBlocksModal(ids){
  const box = document.getElementById('unknownBlocksList');
  box.innerHTML = '';
  if (ids && ids.length){
    const ul = document.createElement('ul');
    ul.style.margin = '0';
    ul.style.paddingLeft = '18px';
    ids.forEach(id=>{
      const li = document.createElement('li');
      li.textContent = id;
      ul.appendChild(li);
    });
    box.appendChild(ul);
  } else {
    box.textContent = '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –±–ª–æ–∫–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã.';
  }
  document.getElementById('unknownBlocksModal').style.display = 'block';
}
function closeUnknownBlocksModal(){
  document.getElementById('unknownBlocksModal').style.display = 'none';
}

async function ignoreErrorsAndCompile() {
  closeErrorWarningModal();
  await performCompilation();
}

async function performCompilation() {
  try {
    const resp = await fetch('/api/project/compile', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ project_data: projectData })
    });
    const j = await resp.json();
    if(j.status === 'success'){
      localStorage.setItem("compiled_code", j.code || "# –ø—É—Å—Ç–æ");
      window.location.href = "/compiled.html";
    } else alert('–û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: ' + (j.message || 'unknown'));
  } catch(err){
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ –æ—à–∏–±–∫–æ–π "Failed to fetch"
    if (err.message.includes('Failed to fetch') || err instanceof TypeError) {
      showFailedToFetchModal();
    } else {
      alert('–û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: ' + err.message);
    }
  }
}

function showFailedToFetchModal() {
  const modal = document.getElementById('failedToFetchModal');
  modal.style.display = 'flex';
}

function closeFailedToFetchModal() {
  const modal = document.getElementById('failedToFetchModal');
  modal.style.display = 'none';
}

/* ========== Empty project checks ========== */
function isProjectEmpty() {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –±–ª–æ–∫–∏ –≤ –ø—Ä–æ–µ–∫—Ç–µ
  if (!projectData.blocks || projectData.blocks.length === 0) {
    console.log('–ù–µ—Ç –±–ª–æ–∫–æ–≤ –≤ –ø—Ä–æ–µ–∫—Ç–µ');
    return true;
  }
  
  // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–¥ –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—É—Å—Ç–æ–π –ª–∏ –æ–Ω
  const generatedCode = generatePythonCodeFromProject();
  console.log('–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥:', generatedCode);
  const isEmpty = isCodeEmpty(generatedCode);
  console.log('–ö–æ–¥ –ø—É—Å—Ç–æ–π?', isEmpty);
  return isEmpty;
}

function isCodeEmpty(code) {
  if (!code || code.trim() === '') {
    return true;
  }
  
  // –£–¥–∞–ª—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
  const lines = code.split('\n').map(line => line.trim()).filter(line => 
    line !== '' && !line.startsWith('#') && !line.startsWith('"""') && !line.startsWith("'''")
  );
  
  return lines.length === 0;
}

function hasHeaderBlocks() {
  if (!projectData.blocks || projectData.blocks.length === 0) {
    return false;
  }
  
  return projectData.blocks.some(block => block.type === 'header');
}

function generatePythonCodeFromProject() {
  if (!projectData.blocks || projectData.blocks.length === 0) {
    return "";
  }

  const blocks = {};
  for (const b of projectData.blocks) {
    blocks[b.id] = b;
  }
  const connections = projectData.connections || [];
  const outgoing = {};
  for (const conn of connections) {
    if (!outgoing[conn.from]) {
      outgoing[conn.from] = [];
    }
    outgoing[conn.from].push(conn);
  }

  const visited = new Set();
  const codeLines = [];

  function compileBlock(blockId, indent = 0) {
    if (visited.has(blockId)) {
      return;
    }
    visited.add(blockId);
    const block = blocks[blockId];
    if (!block) {
      return;
    }
    const blockCfg = findCfg(block.template);
    if (!blockCfg) {
      return;
    }
    
    const isIgnored = !!(block.ignored === true);
    
    let code = blockCfg.code || '';
    for (const [n, v] of Object.entries(block.fields || {})) {
      code = code.replace(`{${n}}`, String(v || ""));
    }
    if (code.trim()) {
      // –†–∞–∑–±–∏–≤–∞–µ–º –∫–æ–¥ –Ω–∞ —Å—Ç—Ä–æ–∫–∏ –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º –æ—Ç—Å—Ç—É–ø –∫ –∫–∞–∂–¥–æ–π —Å—Ç—Ä–æ–∫–µ
      const lines = code.trim().split('\n');
      for (const line of lines) {
        if (line.trim()) { // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
          if (isIgnored) {
            // –ö–æ–º–º–µ–Ω—Ç–∏—Ä—É–µ–º —Å—Ç—Ä–æ–∫–∏ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –±–ª–æ–∫–∞
            codeLines.push("    ".repeat(indent) + "# " + line);
          } else {
            codeLines.push("    ".repeat(indent) + line);
          }
        }
      }
    }
    
    if (blockCfg.type === 'condition' || blockCfg.type === 'loop') {
      const body = outgoing[blockId]?.find(c => c.fromConnector === 'right');
      if (body) {
        // –ï—Å–ª–∏ –±–ª–æ–∫ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω, –≤—Å–µ –±–ª–æ–∫–∏ –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ —Ç–∞–∫–∂–µ –±—É–¥—É—Ç –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω—ã
        // –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤–Ω—É—Ç—Ä–∏ compileBlock
        compileBlock(body.to, indent + 1);
      }
      const nxt = outgoing[blockId]?.find(c => c.fromConnector === 'bottom');
      if (nxt) {
        compileBlock(nxt.to, indent);
      }
    } else {
      const nxt = outgoing[blockId]?.find(c => c.fromConnector === 'bottom');
      if (nxt) {
        compileBlock(nxt.to, indent);
      }
    }
  }

  const start = Object.values(blocks).find(b => b.type === 'header');
  if (start) {
    compileBlock(start.id, 0);
  }
  return codeLines.join('\n');
}

/* ========== Modal handlers ========== */
function showEmptyProjectModal() {
  document.getElementById('emptyProjectModal').style.display = 'block';
}

function closeEmptyProjectModal() {
  document.getElementById('emptyProjectModal').style.display = 'none';
}

function showNoHeaderBlocksModal() {
  document.getElementById('noHeaderBlocksModal').style.display = 'block';
}

function closeNoHeaderBlocksModal() {
  document.getElementById('noHeaderBlocksModal').style.display = 'none';
}

async function confirmCompileWithoutHeader() {
  closeNoHeaderBlocksModal();
  await performCompilation();
}

/* ========== Variable history modal handlers ========== */
function showVariableHistory(varName){
  const modal = document.getElementById('variableHistoryModal');
  const title = document.getElementById('variableHistoryTitle');
  const list = document.getElementById('variableHistoryList');
  if (!modal || !title || !list) return;
  
  title.textContent = `–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π "${varName}"`;
  list.innerHTML = '';
  
  // –°—Ç—Ä–æ–∏–º –≥—Ä–∞—Ñ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞ –±–ª–æ–∫–æ–≤
  function buildExecutionOrder() {
    const order = [];
    const visited = new Set();
    const outgoing = {};
    
    // –ü–æ—Å—Ç—Ä–æ–∏–º –∏–Ω–¥–µ–∫—Å —Å–≤—è–∑–µ–π
    projectData.connections.forEach(c => {
      if (!outgoing[c.from]) outgoing[c.from] = [];
      outgoing[c.from].push(c);
    });
    
    // –ù–∞–π–¥–µ–º header –±–ª–æ–∫
    const headers = projectData.blocks.filter(b => b.type === 'header');
    if (headers.length === 0) return order;
    
    function traverse(blockId) {
      if (visited.has(blockId)) return;
      visited.add(blockId);
      order.push(blockId);
      
      const connections = outgoing[blockId] || [];
      connections.sort((a, b) => {
        // –°–Ω–∞—á–∞–ª–∞ bottom/right, –ø–æ—Ç–æ–º –¥—Ä—É–≥–∏–µ
        const priority = { 'bottom': 1, 'right': 2, 'top': 3, 'left': 4 };
        return (priority[a.fromConnector] || 99) - (priority[b.fromConnector] || 99);
      });
      
      connections.forEach(c => {
        if (c.fromConnector === 'bottom' || c.fromConnector === 'right') {
          traverse(c.to);
        }
      });
    }
    
    headers.forEach(h => traverse(h.id));
    return order;
  }
  
  const executionOrder = buildExecutionOrder();
  
  // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –±–ª–æ–∫–∏, –≥–¥–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —ç—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è, —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º –ø–æ–∑–∏—Ü–∏–∏ –≤ –ø–æ—Ä—è–¥–∫–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
  const usages = [];
  projectData.blocks.forEach(b => {
    const cfg = findCfg(b.template);
    if (!cfg || !cfg.fields || !b.fields) return;
    
    cfg.fields.forEach(f => {
      if (f.type === 'value' && b.fields[f.name] && b.fields[f.name] === varName) {
        const blockName = cfg.name || b.template;
        const order = executionOrder.indexOf(b.id);
        usages.push({
          blockId: b.id,
          blockName: blockName,
          fieldLabel: f.label || f.name,
          fieldName: f.name,
          order: order >= 0 ? order : 999999 // –ë–ª–æ–∫–∏ –±–µ–∑ –ø–æ—Ä—è–¥–∫–∞ –∏–¥—É—Ç –≤ –∫–æ–Ω–µ—Ü
        });
      }
    });
  });
  
  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –ø–æ—Ä—è–¥–∫—É –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
  usages.sort((a, b) => a.order - b.order);
  
  if (usages.length === 0){
    list.innerHTML = '<div style="text-align:center; padding:20px; color:var(--muted);">–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –ø—Ä–æ–µ–∫—Ç–µ</div>';
  } else {
    usages.forEach((usage, idx) => {
      const item = el('div', {
        className: 'variable-history-item',
        style: 'padding:10px; margin:4px 0; background:rgba(255,255,255,0.05); border-radius:8px; cursor:pointer; transition:all 0.2s; display:flex; justify-content:space-between; align-items:center;'
      });
      
      const textContent = `<div><strong>${usage.blockName}</strong> ‚Äî ${usage.fieldLabel}${idx === 0 ? ' <span style="color:#22c55e; font-size:11px; background:rgba(34,197,94,0.1); padding:2px 6px; border-radius:4px;">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è</span>' : ''}</div>`;
      item.innerHTML = textContent;
      
      item.addEventListener('mouseenter', () => {
        item.style.background = 'rgba(255,255,255,0.1)';
      });
      item.addEventListener('mouseleave', () => {
        item.style.background = 'rgba(255,255,255,0.05)';
      });
      item.addEventListener('click', () => {
        navigateToVariableUsage(usage.blockId, usage.fieldName);
        closeVariableHistoryModal();
      });
      list.appendChild(item);
    });
  }
  
  modal.style.display = 'block';
}

function closeVariableHistoryModal(){
  const modal = document.getElementById('variableHistoryModal');
  if (modal) modal.style.display = 'none';
}

function navigateToVariableUsage(blockId, fieldName){
  // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –∫–∞–º–µ—Ä—É –∫ –±–ª–æ–∫—É
  moveCameraToBlock(blockId);
  
  // –ù–∞—Ö–æ–¥–∏–º –∏ –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –ø–æ–ª–µ
  setTimeout(() => {
    const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
    if (!blockEl) return;
    
    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª–µ –≤–≤–æ–¥–∞
    const input = blockEl.querySelector(`input[value="${fieldName}"], textarea`);
    if (!input) return;
    
    // –í—Ä–µ–º–µ–Ω–Ω–æ –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –ø–æ–ª–µ
    input.style.backgroundColor = 'rgba(14, 165, 233, 0.3)';
    input.style.boxShadow = '0 0 16px rgba(14, 165, 233, 0.6)';
    input.style.transition = 'all 0.3s ease';
    
    setTimeout(() => {
      input.style.backgroundColor = '';
      input.style.boxShadow = '';
      setTimeout(() => {
        input.style.transition = '';
      }, 300);
    }, 2000);
  }, 200);
}

/* Validation: warnings and errors */
let globalWarningBlocks = new Set();
let globalErrorBlocks = new Set();

function updateIssues(){
  const panel = document.getElementById('issuesPanel');
  if(!panel) return;
  panel.innerHTML = '';
  // clear previous highlights
  mainCanvas.querySelectorAll('.block').forEach(el=>{ el.classList.remove('block-warning','block-error'); });
  // clear previous indicators
  mainCanvas.querySelectorAll('.block .block-indicator').forEach(ind=>{ ind.style.display='none'; ind.classList.remove('indicator-warning','indicator-error'); ind.textContent=''; });

  // collect per-block statuses
  globalWarningBlocks = new Set();
  globalErrorBlocks = new Set();
  const warningBlocks = globalWarningBlocks;
  const errorBlocks = globalErrorBlocks;

  function isIgnored(blockId){
    if(!blockId) return false;
    const b = projectData.blocks.find(bb => bb.id === blockId);
    return !!(b && b.ignoreIssues === true);
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞, –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω –ª–∏ –±–ª–æ–∫ (–Ω–µ –¥–æ–ª–∂–µ–Ω –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –≤ –ø–∞–Ω–µ–ª–∏)
  function isBlockIgnored(blockId){
    if(!blockId) return false;
    const b = projectData.blocks.find(bb => bb.id === blockId);
    return !!(b && b.ignored === true);
  }

  // Buckets to control final ordering: ignored ‚Üí errors ‚Üí warnings
  const ignoredIssueNodes = [];
  const errorIssueNodes = [];
  const warningIssueNodes = [];

  // Helper to create styled message blocks
  function addWarning(text, blockId = null){
    // –ï—Å–ª–∏ –±–ª–æ–∫ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω (ignored), –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –æ—à–∏–±–∫–∏ –¥–ª—è –Ω–µ–≥–æ
    if(blockId && isBlockIgnored(blockId)) return false;
    // –ï—Å–ª–∏ –±–ª–æ–∫ —Å–∫—Ä—ã—Ç (hidden), –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –æ—à–∏–±–∫–∏ –¥–ª—è –Ω–µ–≥–æ
    if(blockId && isBlockHidden(blockId)) return false;
    const ignored = isIgnored(blockId);
    const node = document.createElement('div');
    node.className = ignored ? 'issue ignored' : 'issue warning';
    if(blockId){ node.dataset.blockId = blockId; }
    if(blockId) {
      node.style.cursor = 'pointer';
      node.title = '–ö–ª–∏–∫–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –ø–µ—Ä–µ–π—Ç–∏ –∫ –±–ª–æ–∫—É';
    }
    const ic = document.createElement('div'); ic.className = 'icon';
    if(ignored){
      ic.textContent = '?';
      ic.style.background = '#16a34a';
      ic.style.color = '#ffffff';
      ic.style.borderRadius = '999px';
      ic.style.fontWeight = '400';
    } else {
      ic.textContent = '!';
    }
    node.appendChild(ic);
    const txt = document.createElement('div');
    if(ignored){
      // –ö—Ä–∞—Ç–∫–∞—è —Ñ–æ—Ä–º–∞ –¥–ª—è –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º—ã—Ö
      const b = projectData.blocks.find(bb => bb.id === blockId);
      const cfg = b ? findCfg(b.template) : null;
      const displayName = (cfg && cfg.name) ? cfg.name : (b ? b.id : '');
      txt.textContent = `–û—à–∏–±–∫–∞ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç—Å—è –≤ –±–ª–æ–∫–µ "${displayName}"`;
      txt.style.color = '#22c55e';
    } else {
      txt.textContent = '–ù–ï–°–û–û–¢–í–ï–¢–°–í–ò–ï! ' + text;
    }
    node.appendChild(txt);
    if(blockId) {
      node.addEventListener('click', () => moveCameraToBlock(blockId));
    }
    if(ignored) ignoredIssueNodes.push(node); else warningIssueNodes.push(node);
    return ignored;
  }
  function addError(text, blockId = null){
    // –ï—Å–ª–∏ –±–ª–æ–∫ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω (ignored), –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –æ—à–∏–±–∫–∏ –¥–ª—è –Ω–µ–≥–æ
    if(blockId && isBlockIgnored(blockId)) return false;
    // –ï—Å–ª–∏ –±–ª–æ–∫ —Å–∫—Ä—ã—Ç (hidden), –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º –æ—à–∏–±–∫–∏ –¥–ª—è –Ω–µ–≥–æ
    if(blockId && isBlockHidden(blockId)) return false;
    const ignored = isIgnored(blockId);
    const node = document.createElement('div');
    node.className = ignored ? 'issue ignored' : 'issue error';
    if(blockId){ node.dataset.blockId = blockId; }
    if(blockId) {
      node.style.cursor = 'pointer';
      node.title = '–ö–ª–∏–∫–Ω–∏—Ç–µ, —á—Ç–æ–±—ã –ø–µ—Ä–µ–π—Ç–∏ –∫ –±–ª–æ–∫—É';
    }
    const ic = document.createElement('div'); ic.className = 'icon';
    if(ignored){
      ic.textContent = '?';
      ic.style.background = '#16a34a';
      ic.style.color = '#ffffff';
      ic.style.borderRadius = '999px';
      ic.style.fontWeight = '400';
    } else {
      ic.textContent = '‚úï';
    }
    node.appendChild(ic);
    const txt = document.createElement('div');
    if(ignored){
      const b = projectData.blocks.find(bb => bb.id === blockId);
      const cfg = b ? findCfg(b.template) : null;
      const displayName = (cfg && cfg.name) ? cfg.name : (b ? b.id : '');
      txt.textContent = `–û—à–∏–±–∫–∞ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç—Å—è –≤ –±–ª–æ–∫–µ "${displayName}"`;
      txt.style.color = '#22c55e';
    } else {
      txt.textContent = '–û–®–ò–ë–ö–ê! ' + text;
    }
    node.appendChild(txt);
    if(blockId) {
      node.addEventListener('click', () => moveCameraToBlock(blockId));
    }
    if(ignored) ignoredIssueNodes.push(node); else errorIssueNodes.push(node);
    return ignored;
  }

  // 1) –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –∏ –∑–∞–ø—Ä–µ—â—ë–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –¥–ª—è value
  projectData.blocks.forEach(b=>{
    const cfg = findCfg(b.template);
    if(cfg && cfg.fields && cfg.fields.length){
      cfg.fields.forEach(f=>{
        const val = (b.fields && (b.fields[f.name] !== undefined)) ? b.fields[f.name] : '';
        if(f.type === 'value') {
          const valStr = String(val);
          if(!valStr || valStr.trim() === '') {
            const ignored = addWarning(`–í –±–ª–æ–∫ "${cfg.name || b.template}" ‚Äî –ø–æ–ª–µ "${f.label || f.name}" –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–æ`, b.id);
            if(!ignored) warningBlocks.add(b.id);
          } else if (/\s/.test(valStr)) {
            const ignored = addError(`–í –±–ª–æ–∫–µ "${cfg.name || b.template}" ‚Äî –ø–æ–ª–µ "${f.label || f.name}" –Ω–µ –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –ø—Ä–æ–±–µ–ª—ã!`, b.id);
            if(!ignored) errorBlocks.add(b.id);
          } else if (/^[\d_]+$/.test(valStr)) {
            const ignored = addError(`–í –±–ª–æ–∫–µ "${cfg.name || b.template}" ‚Äî –ø–æ–ª–µ "${f.label || f.name}" –Ω–µ –¥–æ–ª–∂–Ω–æ —Å–æ—Å—Ç–æ—è—Ç—å —Ç–æ–ª—å–∫–æ –∏–∑ —Ü–∏—Ñ—Ä –∏–ª–∏ _!`, b.id);
            if(!ignored) errorBlocks.add(b.id);
          }
        } else {
          if(!val || String(val).trim() === '') {
            const ignored = addWarning(`–í –±–ª–æ–∫ "${cfg.name || b.template}" ‚Äî –ø–æ–ª–µ "${f.label || f.name}" –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–æ`, b.id);
            if(!ignored) warningBlocks.add(b.id);
          }
        }
      });
    }
  });

  // 2) More than 1 header block -> error
  const headers = projectData.blocks.filter(b => b.type === 'header');
  if(headers.length > 1){
    addError(`–í —Å—Ö–µ–º–µ –±–æ–ª—å—à–µ –æ–¥–Ω–æ–≥–æ –±–ª–æ–∫–∞ —Ç–∏–ø–∞ header (${headers.length})`);
    headers.forEach(h=> {
      const ignored = addError(`–î—É–±–ª–∏—Ä—É—é—â–∏–π –±–ª–æ–∫ header`, h.id);
      if(!ignored) errorBlocks.add(h.id);
    });
  }

  // 3) Connector having more than 1 connection (either incoming or outgoing) -> error
  const connCountMap = {}; // key -> count, key = blockId + ':' + connector
  projectData.connections.forEach(c=>{
    const kFrom = `${c.from}:${c.fromConnector}`;
    const kTo = `${c.to}:${c.toConnector}`;
    connCountMap[kFrom] = (connCountMap[kFrom]||0) + 1;
    connCountMap[kTo] = (connCountMap[kTo]||0) + 1;
  });
  for(const key in connCountMap){
    if(connCountMap[key] > 1){
      // parse key
      const [bid, conn] = key.split(':');
      const blk = projectData.blocks.find(bb => bb.id === bid);
      const blkName = (blk && findCfg(blk.template) && findCfg(blk.template).name) ? findCfg(blk.template).name : (blk ? blk.id : bid);
      const ignored = addError(`–ö–æ–Ω–Ω–µ–∫—Ç–æ—Ä "${conn}" —É –±–ª–æ–∫–∞ "${blkName}" –∏–º–µ–µ—Ç ${connCountMap[key]} —Å–≤—è–∑–µ–π`, bid);
      if(blk && !ignored) errorBlocks.add(blk.id);
    }
  }

  // 4) Blocks with no incoming connections -> warning (except header blocks which may be start)
  projectData.blocks.forEach(b=>{
    const hasIncoming = projectData.connections.some(c => c.to === b.id);
    if(!hasIncoming && b.type !== 'header'){
      const cfg = findCfg(b.template);
      const displayName = (cfg && cfg.name) ? cfg.name : b.id;
      const ignored = addWarning(`–í –±–ª–æ–∫ "${displayName}" –Ω–µ –ø—Ä–∏—Ö–æ–¥–∏—Ç –Ω–∏ –æ–¥–Ω–∞ —Å–≤—è–∑—å`, b.id);
      if(!ignored) warningBlocks.add(b.id);
    }
  });

  // 5) Cycles and conditions without right connector connections -> warning
  projectData.blocks.forEach(b=>{
    if(b.type === 'loop' || b.type === 'condition'){
      const hasRightConnection = projectData.connections.some(c => c.from === b.id && c.fromConnector === 'right');
      if(!hasRightConnection){
        const cfg = findCfg(b.template);
        const displayName = (cfg && cfg.name) ? cfg.name : b.id;
        const ignored = addWarning(`–£ –±–ª–æ–∫–∞ "${displayName}" (${b.type === 'loop' ? '—Ü–∏–∫–ª' : '—É—Å–ª–æ–≤–∏–µ'}) –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Å–≤—è–∑—å –æ—Ç –ø—Ä–∞–≤–æ–≥–æ –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–∞`, b.id);
        if(!ignored) warningBlocks.add(b.id);
      }
    }
  });

  // 6) Cycles and conditions containing only ignored blocks -> error
  projectData.blocks.forEach(b=>{
    if(b.type === 'loop' || b.type === 'condition'){
      const rightConnections = projectData.connections.filter(c => c.from === b.id && c.fromConnector === 'right');
      if(rightConnections.length > 0){
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—Å–µ—Ö –±–ª–æ–∫–æ–≤ –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ
        const checkAllIgnored = (blockId) => {
          const block = projectData.blocks.find(bb => bb.id === blockId);
          if(!block) return true; // –ï—Å–ª–∏ –±–ª–æ–∫–∞ –Ω–µ—Ç, —Å—á–∏—Ç–∞–µ–º —á—Ç–æ –æ–Ω –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω
          
          // –ï—Å–ª–∏ –±–ª–æ–∫ —Å–∞–º –Ω–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º false
          if(!block.ignored) return false;
          
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ –±–ª–æ–∫–∏ (–≤–Ω–∏–∑ –ø–æ —Ü–µ–ø–æ—á–∫–µ)
          const nextConnections = projectData.connections.filter(c => c.from === blockId && c.fromConnector === 'bottom');
          for(const conn of nextConnections){
            if(!checkAllIgnored(conn.to)) return false;
          }
          
          // –ï—Å–ª–∏ —ç—Ç–æ —Ç–æ–∂–µ condition –∏–ª–∏ loop, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤—ã–π –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä
          const blockCfg = findCfg(block.template);
          if(blockCfg && (blockCfg.type === 'condition' || blockCfg.type === 'loop')){
            const rightConns = projectData.connections.filter(c => c.from === blockId && c.fromConnector === 'right');
            for(const conn of rightConns){
              if(!checkAllIgnored(conn.to)) return false;
            }
          }
          
          return true; // –í—Å–µ –¥–æ—á–µ—Ä–Ω–∏–µ –±–ª–æ–∫–∏ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω—ã
        };
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—Å–µ –ª–∏ –±–ª–æ–∫–∏ –Ω–∞ –ø—Ä–∞–≤–æ–º –∫–æ–Ω–Ω–µ–∫—Ç–æ—Ä–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω—ã
        let allIgnored = true;
        for(const conn of rightConnections){
          if(!checkAllIgnored(conn.to)){
            allIgnored = false;
            break;
          }
        }
        
        if(allIgnored){
          const cfg = findCfg(b.template);
          const displayName = (cfg && cfg.name) ? cfg.name : b.id;
          const ignored = addError(`–ë–ª–æ–∫ "${displayName}" (${b.type === 'loop' ? '—Ü–∏–∫–ª' : '—É—Å–ª–æ–≤–∏–µ'}) —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –±–ª–æ–∫–∏ –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º`, b.id);
          if(!ignored) errorBlocks.add(b.id);
        }
      }
    }
  });

  // If there is an active selection, prioritize issues belonging to selected blocks:
  // order: ignored (unchanged) -> selected errors -> selected warnings -> other errors (deemphasized) -> other warnings (deemphasized)
  const selectedIds = (typeof selectionState !== 'undefined' && selectionState && selectionState.selectedBlockIds && selectionState.selectedBlockIds.size>0) ? new Set(selectionState.selectedBlockIds) : null;

  if(selectedIds) {
    // split error and warning nodes into selected / other
    const selectedErrorNodes = [], otherErrorNodes = [];
    errorIssueNodes.forEach(n => {
      const bid = n.dataset.blockId;
      if(bid && selectedIds.has(bid)) { n.classList.remove('deemphasized'); selectedErrorNodes.push(n); }
      else { otherErrorNodes.push(n); }
    });
    const selectedWarningNodes = [], otherWarningNodes = [];
    warningIssueNodes.forEach(n => {
      const bid = n.dataset.blockId;
      if(bid && selectedIds.has(bid)) { n.classList.remove('deemphasized'); selectedWarningNodes.push(n); }
      else { otherWarningNodes.push(n); }
    });

    // Append: ignored (as before), then selected errors/warnings, then others (deemphasized)
    ignoredIssueNodes.forEach(n => panel.appendChild(n));
    selectedErrorNodes.forEach(n => panel.appendChild(n));
    selectedWarningNodes.forEach(n => panel.appendChild(n));
    otherErrorNodes.forEach(n => { n.classList.add('deemphasized'); panel.appendChild(n); });
    otherWarningNodes.forEach(n => { n.classList.add('deemphasized'); panel.appendChild(n); });
  } else {
    // No selection: normal ordering, ensure no lingering deemphasis classes
    ignoredIssueNodes.forEach(n => panel.appendChild(n));
    errorIssueNodes.forEach(n => { n.classList.remove('deemphasized'); panel.appendChild(n); });
    warningIssueNodes.forEach(n => { n.classList.remove('deemphasized'); panel.appendChild(n); });
  }

  // If panel is empty, show a small "–≤—Å–µ —Ö–æ—Ä–æ—à–æ"
  if(panel.children.length === 0){
    const ok = document.createElement('div');
    ok.className = 'small';
    ok.style.opacity = '0.7';
    ok.textContent = '–ü—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã ‚Äî –æ—à–∏–±–æ–∫ –∏ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –Ω–µ—Ç.';
    panel.appendChild(ok);
  }

  // apply highlights (errors override warnings)
  updateBlockHighlighting();

  // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≥–ª–æ–±–∞–ª—å–Ω–æ–π –∫–Ω–æ–ø–∫–∏ –≤ –ø—Ä–∞–≤–æ–π –ø–∞–Ω–µ–ª–∏
  updateGlobalIgnoreButtonState();
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –æ—à–∏–±–æ–∫ –¥–ª—è –≤—Å–µ—Ö –±–ª–æ–∫–æ–≤
  projectData.blocks.forEach(b => {
    const blockEl = mainCanvas.querySelector(`.block[data-block-id="${b.id}"]`);
    if(blockEl) applyBlockIgnoreIssuesState(blockEl, b);
  });

  // –û–±–Ω–æ–≤–ª—è–µ–º —Å–≤–æ–¥–∫—É –≤—ã–¥–µ–ª–µ–Ω–∏—è (–µ—Å–ª–∏ –≤—ã–¥–µ–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ)
  if (typeof updateSelectionSummary === 'function') updateSelectionSummary();
}

/* ========== Camera movement to block ========== */
function moveCameraToBlock(blockId) {
  const blockEl = mainCanvas.querySelector(`.block[data-block-id="${blockId}"]`);
  if (!blockEl) return;
  
  const blockData = projectData.blocks.find(b => b.id === blockId);
  if (!blockData) return;
  
  // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã viewport
  const viewport = document.getElementById('viewport');
  const viewportRect = viewport.getBoundingClientRect();
  
  // –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–Ω—Ç—Ä viewport
  const viewportCenterX = viewportRect.width / 2;
  const viewportCenterY = viewportRect.height / 2;
  
  // –í—ã—á–∏—Å–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –±–ª–æ–∫–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ canvas
  const blockX = blockData.x;
  const blockY = blockData.y;
  
  // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–∞–º–µ—Ä—ã –¥–ª—è —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –±–ª–æ–∫–∞
  const newCameraX = viewportCenterX - blockX;
  const newCameraY = viewportCenterY - blockY;
  
  // –ü–ª–∞–≤–Ω–æ –ø–µ—Ä–µ–º–µ—â–∞–µ–º –∫–∞–º–µ—Ä—É
  camera.x = newCameraX;
  camera.y = newCameraY;
  updateCamera();
  
  // –î–æ–±–∞–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç - –ø–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –±–ª–æ–∫
  blockEl.style.transform = 'scale(1.1)';
  blockEl.style.transition = 'transform 0.3s ease';
  
  setTimeout(() => {
    blockEl.style.transform = 'scale(1)';
    setTimeout(() => {
      blockEl.style.transition = '';
    }, 300);
  }, 1000);
}

/* ========== Small helpers ========== */
function updateCounts(){
  document.getElementById('blocksCount').textContent = projectData.blocks.length;
  document.getElementById('connsCount').textContent = projectData.connections.length;
  updateIssues();
}



/* ========== Custom dialogs ========== */
function showCustomPrompt(title, message, callback, defaultValue = '') {
  const modal = document.createElement('div');
  modal.className = 'custom-modal';
  modal.innerHTML = `
    <div class="custom-modal-content">
      <div class="custom-modal-header">${title}</div>
      <div class="custom-modal-body">
        <div style="margin-bottom: 12px; color: var(--muted);">${message}</div>
        <input type="text" class="custom-input" id="customPromptInput" value="${defaultValue}" placeholder="–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ">
      </div>
      <div class="custom-modal-footer">
        <button class="btn" onclick="handleCustomPrompt(true)">–û–ö</button>
        <button class="btn-ghost" onclick="handleCustomPrompt(false)">–û—Ç–º–µ–Ω–∞</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  // –§–æ–∫—É—Å –Ω–∞ input
  setTimeout(() => {
    const input = document.getElementById('customPromptInput');
    if (input) {
      input.focus();
      input.select();
    }
  }, 100);
  
  // –û–±—Ä–∞–±–æ—Ç–∫–∞ Enter –∏ Escape
  const handleKeydown = (e) => {
    if (e.key === 'Enter') {
      handleCustomPrompt(true);
    } else if (e.key === 'Escape') {
      handleCustomPrompt(false);
    }
  };
  
  document.addEventListener('keydown', handleKeydown);
  
  window.handleCustomPrompt = (confirmed) => {
    const input = document.getElementById('customPromptInput');
    const value = input ? input.value.trim() : '';
    
    document.body.removeChild(modal);
    document.removeEventListener('keydown', handleKeydown);
    delete window.handleCustomPrompt;
    
    if (confirmed && value) {
      callback(value);
    }
  };
}

function showCustomConfirm(title, message, callback) {
  const modal = document.createElement('div');
  modal.className = 'custom-modal';
  modal.innerHTML = `
    <div class="custom-modal-content">
      <div class="custom-modal-header">${title}</div>
      <div class="custom-modal-body">
        <div style="color: var(--white);">${message}</div>
      </div>
      <div class="custom-modal-footer">
        <button class="btn" onclick="handleCustomConfirm(true)">–î–∞</button>
        <button class="btn-ghost" onclick="handleCustomConfirm(false)">–ù–µ—Ç</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  window.handleCustomConfirm = (confirmed) => {
    document.body.removeChild(modal);
    delete window.handleCustomConfirm;
    
    if (confirmed) {
      callback();
    }
  };
}

function showCustomAlert(title, message) {
  const modal = document.createElement('div');
  modal.className = 'custom-modal';
  modal.innerHTML = `
    <div class="custom-modal-content">
      <div class="custom-modal-header">${title}</div>
      <div class="custom-modal-body">
        <div style="color: var(--white);">${message}</div>
      </div>
      <div class="custom-modal-footer">
        <button class="btn" onclick="closeCustomAlert()">–û–ö</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
  
  window.closeCustomAlert = () => {
    document.body.removeChild(modal);
    delete window.closeCustomAlert;
  };
}

function goToProjectSelection() {
  // Check unsaved changes
  if (hasUnsavedChanges()) {
    _pendingAfterUnsavedAction = () => { window.location.href = '/'; };
    openUnsavedChangesModal();
    return;
  }
  window.location.href = '/';
}

function openUnsavedChangesModal(){
  const m = document.getElementById('unsavedChangesModal');
  if (!m) return;
  m.style.display = 'block';
}

function closeUnsavedChangesModal(){
  const m = document.getElementById('unsavedChangesModal');
  if (!m) return;
  m.style.display = 'none';
}

async function confirmUnsavedSave(){
  try {
    await saveProject();
    closeUnsavedChangesModal();
    const next = _pendingAfterUnsavedAction; _pendingAfterUnsavedAction = null;
    if (typeof next === 'function') next();
  } catch(e) {
    // –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —É–∂–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ–º
  }
}

function confirmUnsavedDiscard(){
  closeUnsavedChangesModal();
  const next = _pendingAfterUnsavedAction; _pendingAfterUnsavedAction = null;
  if (typeof next === 'function') next();
}

/* ========== Sound system ========== */
// –°–∏—Å—Ç–µ–º–∞ –∑–≤—É–∫–æ–≤ –≤—ã–Ω–µ—Å–µ–Ω–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π —Ñ–∞–π–ª /static/js/sounds.js

/* ========== Custom notifications ========== */
function showNotification(type, title, message, duration = 4000) {
  // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∑–≤—É–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è (playSound –∏–∑ sounds.js)
  const soundMap = {
    'success': 'notification_success',
    'error': 'notification_error',
    'warning': 'notification_warning',
    'info': 'notification_info'
  };
  const soundName = soundMap[type] || 'notification_info';
  playSound(soundName);
  
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  notification.innerHTML = `
    <button class="notification-close" onclick="closeNotification(this)">√ó</button>
    <div class="notification-header">
      <span class="notification-icon">${type === 'success' ? '‚úÖ' : '‚ùå'}</span>
      <span class="notification-title">${title}</span>
    </div>
    <div class="notification-message">${message}</div>
  `;
  
  document.body.appendChild(notification);
  
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
  setTimeout(() => {
    notification.classList.add('show');
  }, 100);
  
  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∫—Ä—ã–≤–∞–µ–º —á–µ—Ä–µ–∑ —É–∫–∞–∑–∞–Ω–Ω–æ–µ –≤—Ä–µ–º—è
  setTimeout(() => {
    closeNotification(notification.querySelector('.notification-close'));
  }, duration);
}

function closeNotification(closeButton) {
  const notification = closeButton.closest('.notification');
  notification.classList.remove('show');
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 300);
}


/* ========== Theme management ========== */
function setTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  localStorage.setItem('turtcd-theme', theme);
  
  // Update theme dropdown
  const dropdown = document.getElementById('themeDropdown');
  if (dropdown) {
    dropdown.value = theme;
  }
}

function loadTheme() {
  const savedTheme = localStorage.getItem('turtcd-theme') || 'dark';
  setTheme(savedTheme);
}

/* ========== Clear workspace ========== */
function openClearModal(){ document.getElementById('clearModal').style.display = 'block'; }
function closeClearModal(){ document.getElementById('clearModal').style.display = 'none'; }
function confirmClearWorkspace() {
  // Clear canvas
  mainCanvas.querySelectorAll('.block').forEach(n => n.remove());
  
  // Reset project data
  projectData = { blocks: [], connections: [] };
  
  // Update counts and connections
  updateConnections();
  updateCounts();
  // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é –∑–Ω–∞—á–µ–Ω–∏–π
  loadValueHistory();
  closeClearModal();
}

/* ========== Load current project ========== */
async function loadCurrentProject() {
  const currentProject = localStorage.getItem('currentProject');
  if (currentProject) {
    try {
      const resp = await fetch('/api/project/load-file', { 
        method:'POST', 
        headers:{'Content-Type':'application/json'}, 
        body: JSON.stringify({ filename: currentProject })
      });
      const j = await resp.json();
      if(j.status === 'success' && j.project_data){
        loadProjectFromObject(j.project_data);
      }
    } catch(err){ 
      console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–µ–∫—Ç–∞:', err); 
    }
  }
}

/* ========== Help Tour System ========== */
let helpTour = {
  isActive: false,
  currentStep: 0,
  steps: [],
  overlay: null,
  spotlight: null,
  tooltip: null
};

// –®–∞–≥–∏ —ç–∫—Å–∫—É—Ä—Å–∞ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ –±–ª–æ–∫–æ–≤
const editorSteps = [
  {
    target: '.left h2',
    title: '–ü–∞–ª–∏—Ç—Ä–∞ –±–ª–æ–∫–æ–≤',
    content: '–ó–¥–µ—Å—å –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –±–ª–æ–∫–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º. –ë–ª–æ–∫–∏ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –ø–æ–∏—Å–∫–∞.',
    position: 'right'
  },
  {
    target: '.left .btn',
    title: '–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–µ–∫—Ç–æ–º',
    content: '–ö–Ω–æ–ø–∫–∏ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–µ–∫—Ç–∞. –≠–∫—Å–ø–æ—Ä—Ç —Å–æ–∑–¥–∞—ë—Ç —Ñ–∞–π–ª .turtcd, –∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–æ–µ–∫—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.',
    position: 'right'
  },
  {
    target: '.left .btn-ghost',
    title: '–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏',
    content: '–ö–Ω–æ–ø–∫–∞ "–û—á–∏—Å—Ç–∏—Ç—å –ø–æ–ª–µ" —É–¥–∞–ª—è–µ—Ç –≤—Å–µ –±–ª–æ–∫–∏ —Å —Ä–∞–±–æ—á–µ–≥–æ –ø–æ–ª—è. –ö–Ω–æ–ø–∫–∞ "–ò–º–ø–æ—Ä—Ç" –ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ–µ–∫—Ç –∏–∑ —Ñ–∞–π–ª–∞.',
    position: 'right'
  },
  {
    target: '.center .toolbar .btn',
    title: '–ö–æ–º–ø–∏–ª—è—Ü–∏—è –ø—Ä–æ–µ–∫—Ç–∞',
    content: '–ö–Ω–æ–ø–∫–∞ "–°–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å" –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –≤–∞—à–∏ –±–ª–æ–∫–∏ –≤ Python –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å.',
    position: 'bottom'
  },
  {
    target: '.center .toolbar .btn-ghost',
    title: '–ù–∞–≤–∏–≥–∞—Ü–∏—è',
    content: '–ö–Ω–æ–ø–∫–∞ "–ú–µ–Ω—é" –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é. –ö–Ω–æ–ø–∫–∞ "–ü–æ–º–æ—â—å" –∑–∞–ø—É—Å–∫–∞–µ—Ç —ç—Ç–æ—Ç —ç–∫—Å–∫—É—Ä—Å.',
    position: 'bottom'
  },
  {
    target: '#viewport',
    title: '–†–∞–±–æ—á–µ–µ –ø–æ–ª–µ',
    content: '–≠—Ç–æ –æ—Å–Ω–æ–≤–Ω–∞—è –æ–±–ª–∞—Å—Ç—å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–æ–≥—Ä–∞–º–º. –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ –±–ª–æ–∫–∏ —Å—é–¥–∞ –∏ —Å–æ–µ–¥–∏–Ω—è–π—Ç–µ –∏—Ö –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤.',
    position: 'top'
  },
  {
    target: '.right-panel .panel-title',
    title: '–ü–∞–Ω–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏',
    content: '–ó–¥–µ—Å—å –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞: –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–ª–æ–∫–æ–≤ –∏ —Å–≤—è–∑–µ–π. –¢–∞–∫–∂–µ –∑–¥–µ—Å—å –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è –∏ –æ—à–∏–±–∫–∏.',
    position: 'left'
  },
  {
    target: '#variableRegistry',
    title: '–†–µ–µ—Å—Ç—Ä –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö',
    content: '–ó–¥–µ—Å—å –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –≤ –≤–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ. –í—ã –º–æ–∂–µ—Ç–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —Ç–µ–≥–∏ –¥–ª—è –∫–∞–∂–¥–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π (–º–∞—Å—Å–∏–≤, –æ–±—ä–µ–∫—Ç, —Ñ—É–Ω–∫—Ü–∏—è –∏ —Ç.–¥.).',
    position: 'left'
  },
  {
    target: '#modsPanel',
    title: '–ú–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏',
    content: '–ó–¥–µ—Å—å –Ω–∞—Ö–æ–¥—è—Ç—Å—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–æ–¥—É–ª–∏ –∏ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è –¥–ª—è TurtCD. –í–∫–ª—é—á–∞–π—Ç–µ –Ω—É–∂–Ω—ã–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏–∏ –¥–ª—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏.',
    position: 'left'
  }
];

function startHelpTour() {
  if (helpTour.isActive) {
    return;
  }

  helpTour.isActive = true;
  helpTour.currentStep = 0;
  helpTour.steps = editorSteps;

  createHelpOverlay();
  showHelpStep(0);
}

function createHelpOverlay() {
  // –°–æ–∑–¥–∞–µ–º –æ–≤–µ—Ä–ª–µ–π
  helpTour.overlay = document.createElement('div');
  helpTour.overlay.className = 'help-tour-overlay';
  document.body.appendChild(helpTour.overlay);

  // –°–æ–∑–¥–∞–µ–º spotlight
  helpTour.spotlight = document.createElement('div');
  helpTour.spotlight.className = 'help-tour-spotlight';
  helpTour.overlay.appendChild(helpTour.spotlight);

  // –°–æ–∑–¥–∞–µ–º tooltip
  helpTour.tooltip = document.createElement('div');
  helpTour.tooltip.className = 'help-tour-tooltip';
  helpTour.overlay.appendChild(helpTour.tooltip);
}

function showHelpStep(stepIndex) {
  if (stepIndex >= helpTour.steps.length) {
    endHelpTour();
    return;
  }

  // –£–±–∏—Ä–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Å –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
  document.querySelectorAll('.help-tour-highlighted').forEach(el => {
    el.classList.remove('help-tour-highlighted');
  });

  const step = helpTour.steps[stepIndex];
  const targetElement = document.querySelector(step.target);

  if (!targetElement) {
    // –ï—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —ç—Ç–æ—Ç —à–∞–≥
    showHelpStep(stepIndex + 1);
    return;
  }

  // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É –∫ —Ç–µ–∫—É—â–µ–º—É —ç–ª–µ–º–µ–Ω—Ç—É
  targetElement.classList.add('help-tour-highlighted');

  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∞ –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –ª–µ–≤–æ–π –ø–∞–Ω–µ–ª–∏
  if (stepIndex >= 1 && stepIndex <= 2) { // –®–∞–≥–∏ —Å –∫–Ω–æ–ø–∫–∞–º–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞ –∏ –æ—á–∏—Å—Ç–∫–∏
    const leftPanel = document.querySelector('.left');
    if (leftPanel) {
      // –ü—Ä–æ–∫—Ä—É—á–∏–≤–∞–µ–º –≤ —Å–∞–º—ã–π –Ω–∏–∑ –ª–µ–≤–æ–π –ø–∞–Ω–µ–ª–∏
      leftPanel.scrollTop = leftPanel.scrollHeight;
      // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
      setTimeout(() => {
        positionElements();
      }, 100);
      return;
    }
  }

  positionElements();

  function positionElements() {
    // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º spotlight
    const rect = targetElement.getBoundingClientRect();
    helpTour.spotlight.style.left = (rect.left - 8) + 'px';
    helpTour.spotlight.style.top = (rect.top - 8) + 'px';
    helpTour.spotlight.style.width = (rect.width + 16) + 'px';
    helpTour.spotlight.style.height = (rect.height + 16) + 'px';

    // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º tooltip
    positionTooltip(step, rect);

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ tooltip
    helpTour.tooltip.innerHTML = `
      <h3>${step.title}</h3>
      <p>${step.content}</p>
      <div class="help-actions">
        ${stepIndex > 0 ? '<button class="btn-ghost" onclick="previousHelpStep()">‚Üê –ù–∞–∑–∞–¥</button>' : ''}
        <button class="btn-ghost" onclick="endHelpTour()">–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å</button>
        <button class="btn" onclick="nextHelpStep()">${stepIndex === helpTour.steps.length - 1 ? '–ó–∞–≤–µ—Ä—à–∏—Ç—å' : '–î–∞–ª–µ–µ ‚Üí'}</button>
      </div>
      <div class="help-tour-progress">${stepIndex + 1} –∏–∑ ${helpTour.steps.length}</div>
    `;

    helpTour.currentStep = stepIndex;
  }
}

function positionTooltip(step, targetRect) {
  const tooltip = helpTour.tooltip;
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const tooltipWidth = 350;
  const tooltipHeight = 200;
  const margin = 20;

  let left, top;

  switch (step.position) {
    case 'top':
      left = targetRect.left + (targetRect.width / 2) - (tooltipWidth / 2);
      top = targetRect.top - tooltipHeight - margin;
      break;
    case 'bottom':
      left = targetRect.left + (targetRect.width / 2) - (tooltipWidth / 2);
      top = targetRect.bottom + margin;
      break;
    case 'left':
      left = targetRect.left - tooltipWidth - margin;
      top = targetRect.top + (targetRect.height / 2) - (tooltipHeight / 2);
      break;
    case 'right':
      left = targetRect.right + margin;
      top = targetRect.top + (targetRect.height / 2) - (tooltipHeight / 2);
      break;
    default:
      left = targetRect.left + (targetRect.width / 2) - (tooltipWidth / 2);
      top = targetRect.bottom + margin;
  }

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥—Ä–∞–Ω–∏—Ü—ã viewport
  if (left < margin) left = margin;
  if (left + tooltipWidth > viewportWidth - margin) left = viewportWidth - tooltipWidth - margin;
  if (top < margin) top = targetRect.bottom + margin;
  if (top + tooltipHeight > viewportHeight - margin) top = targetRect.top - tooltipHeight - margin;

  tooltip.style.left = Math.max(0, left) + 'px';
  tooltip.style.top = Math.max(0, top) + 'px';
}

function nextHelpStep() {
  showHelpStep(helpTour.currentStep + 1);
}

function previousHelpStep() {
  if (helpTour.currentStep > 0) {
    showHelpStep(helpTour.currentStep - 1);
  }
}

function endHelpTour() {
  // –£–±–∏—Ä–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Å–æ –≤—Å–µ—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
  document.querySelectorAll('.help-tour-highlighted').forEach(el => {
    el.classList.remove('help-tour-highlighted');
  });

  if (helpTour.overlay) {
    helpTour.overlay.remove();
  }
  helpTour.isActive = false;
  helpTour.currentStep = 0;
  helpTour.overlay = null;
  helpTour.spotlight = null;
  helpTour.tooltip = null;
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞–≤–∏—à –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ —ç–∫—Å–∫—É—Ä—Å—É
document.addEventListener('keydown', function(e) {
  if (!helpTour.isActive) return;

  switch (e.key) {
    case 'Escape':
      endHelpTour();
      break;
    case 'ArrowRight':
    case ' ':
      e.preventDefault();
      nextHelpStep();
      break;
    case 'ArrowLeft':
      e.preventDefault();
      previousHelpStep();
      break;
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞–≤–∏—à –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã (Ctrl + —Å—Ç—Ä–µ–ª–æ—á–∫–∏)
document.addEventListener('keydown', function(e) {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∑–∞–∂–∞—Ç Ctrl –∏ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω —ç–∫—Å–∫—É—Ä—Å
  if (!e.ctrlKey || helpTour.isActive) return;
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–æ–∫—É—Å –Ω–µ –Ω–∞ –ø–æ–ª–µ –≤–≤–æ–¥–∞
  const activeElement = document.activeElement;
  if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.contentEditable === 'true')) {
    return;
  }
  
  const moveStep = 50; // –®–∞–≥ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –≤ –ø–∏–∫—Å–µ–ª—è—Ö
  const inversion = isArrowInversionEnabled();
  
  switch (e.key) {
    case 'ArrowUp':
      e.preventDefault();
      camera.y -= (inversion ? -1 : 1) * moveStep;
      updateCamera();
      scheduleConnectionsUpdate();
      saveCameraPosition();
      break;
    case 'ArrowDown':
      e.preventDefault();
      camera.y += (inversion ? -1 : 1) * moveStep;
      updateCamera();
      scheduleConnectionsUpdate();
      saveCameraPosition();
      break;
    case 'ArrowLeft':
      e.preventDefault();
      camera.x -= (inversion ? -1 : 1) * moveStep;
      updateCamera();
      scheduleConnectionsUpdate();
      saveCameraPosition();
      break;
    case 'ArrowRight':
      e.preventDefault();
      camera.x += (inversion ? -1 : 1) * moveStep;
      updateCamera();
      scheduleConnectionsUpdate();
      saveCameraPosition();
      break;
    case 'ArrowRight':
      e.preventDefault();
      camera.x += (inversion ? -1 : 1) * moveStep;
      updateCamera();
      scheduleConnectionsUpdate();
      break;
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∞–≤–∏—à Delete –∏ Backspace:
// - Delete —É–¥–∞–ª—è–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –±–ª–æ–∫–∏
// - Backspace –æ—á–∏—â–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –±–ª–æ–∫–æ–≤ (–ø–æ–≤–µ–¥–µ–Ω–∏–µ –∫–∞–∫ Enter)
document.addEventListener('keydown', function(e) {
  try {
    const active = document.activeElement;
    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç
    if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable === 'true')) return;

    const selected = (typeof getSelectedBlockIds === 'function') ? getSelectedBlockIds() : [];
    if (!selected || selected.length === 0) return;

    if (e.key === 'Delete') {
      e.preventDefault();
      deleteSelectedBlocks();
    } else if (e.key === 'Backspace') {
      e.preventDefault();
      clearSelectedBlocks();
    }
  } catch (err) { console.error('delete/backspace key handler error', err); }
});

// Toggle ignore for selected blocks when pressing 'i'
document.addEventListener('keydown', function(e) {
  try {
    if (!e.key) return;
    if (e.key.toLowerCase() === 'i' && !e.shiftKey) {
      const active = document.activeElement;
      if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable === 'true')) return;
      const selected = (typeof getSelectedBlockIds === 'function') ? getSelectedBlockIds() : [];
      if (selected && selected.length > 0) {
        e.preventDefault();
        toggleIgnoreSelectedBlocks();
      }
    }
  } catch (err) { console.error('i key handler error', err); }
});

// Clear input fields of selected blocks when pressing Enter (if focus is not in an input)
document.addEventListener('keydown', function(e) {
  try {
    if (e.key === 'Enter') {
      const active = document.activeElement;
      // –ï—Å–ª–∏ —Ñ–æ–∫—É—Å –≤ –∏–Ω–ø—É—Ç–µ/textarea –∏–ª–∏ contentEditable ‚Äî –Ω–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º
      if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable === 'true')) return;
      const selected = (typeof getSelectedBlockIds === 'function') ? getSelectedBlockIds() : [];
      if (selected && selected.length > 0) {
        e.preventDefault();
        clearSelectedBlocks();
      }
    }
  } catch (err) { console.error('enter key handler error', err); }
});

// Toggle ignore-issues for selected blocks when pressing Shift+I
document.addEventListener('keydown', function(e) {
  try {
    if (!e.key) return;
    if (e.key.toLowerCase() === 'i' && e.shiftKey) {
      const active = document.activeElement;
      if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable === 'true')) return;
      const selected = (typeof getSelectedBlockIds === 'function') ? getSelectedBlockIds() : [];
      if (selected && selected.length > 0) {
        e.preventDefault();
        toggleIgnoreIssuesForSelected();
      }
    }
  } catch (err) { console.error('Shift+I key handler error', err); }
});

/* ========== License modal ========== */
async function loadVersion() {
  try {
    const response = await fetch('/api/version');
    const data = await response.json();
    if (data.status === 'success' && data.version) {
      const versionBadge = document.getElementById('versionBadge');
      if (versionBadge) {
        versionBadge.textContent = `v${data.version}`;
      }
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≤–µ—Ä—Å–∏–∏:', error);
  }
}

let licenseAcceptUnlocked = false;
let licenseScrollListenerAttached = false;

async function openLicenseModal() {
  const modal = document.getElementById('licenseModal');
  const licenseText = document.getElementById('licenseText');
  const errorEl = document.getElementById('licenseError');
  const acceptBtn = document.getElementById('acceptLicenseBtn');
  const scrollContainer = document.getElementById('licenseScroll');
  
  if (!modal || !licenseText) return;
  
  modal.style.display = 'block';
  licenseText.textContent = '–ó–∞–≥—Ä—É–∑–∫–∞ –ª–∏—Ü–µ–Ω–∑–∏–æ–Ω–Ω–æ–≥–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—è...';
  errorEl.style.display = 'none';
  licenseAcceptUnlocked = false;
  if (acceptBtn) {
    acceptBtn.disabled = true;
  }
  
  // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∫—Ä–æ–ª–ª–∞, –µ—Å–ª–∏ –µ—â–µ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω
  if (scrollContainer && !licenseScrollListenerAttached) {
    scrollContainer.addEventListener('scroll', handleLicenseScroll);
    licenseScrollListenerAttached = true;
  }
  
  try {
    const response = await fetch('/api/license/text');
    const data = await response.json();
    
    if (data.status === 'success' && data.text) {
      licenseText.textContent = data.text;
    } else {
      licenseText.textContent = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–∏—Ü–µ–Ω–∑–∏–æ–Ω–Ω–æ–≥–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—è.';
      errorEl.textContent = data.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –ª–∏—Ü–µ–Ω–∑–∏—é';
      errorEl.style.display = 'block';
    }
  } catch (error) {
    licenseText.textContent = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–∏—Ü–µ–Ω–∑–∏–æ–Ω–Ω–æ–≥–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—è.';
    errorEl.textContent = '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ—Ä–≤–µ—Ä—É';
    errorEl.style.display = 'block';
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –ª–∏—Ü–µ–Ω–∑–∏–∏:', error);
  }
}

function handleLicenseScroll() {
  if (licenseAcceptUnlocked) return;
  const scrollContainer = document.getElementById('licenseScroll');
  const acceptBtn = document.getElementById('acceptLicenseBtn');
  const licenseText = document.getElementById('licenseText');
  if (!scrollContainer || !acceptBtn || !licenseText) return;
  if (!licenseText.textContent || licenseText.textContent.trim().length === 0) {
    acceptBtn.disabled = true;
    return;
  }
  const nearBottom = Math.ceil(scrollContainer.scrollTop + scrollContainer.clientHeight) >= scrollContainer.scrollHeight - 10;
  if (nearBottom) {
    licenseAcceptUnlocked = true;
    acceptBtn.disabled = false;
  }
}

async function acceptLicenseAgreement() {
  const acceptBtn = document.getElementById('acceptLicenseBtn');
  const errorEl = document.getElementById('licenseError');
  if (!licenseAcceptUnlocked || !acceptBtn) return;

  acceptBtn.disabled = true;
  acceptBtn.textContent = '–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...';
  if (errorEl) {
    errorEl.style.display = 'none';
    errorEl.textContent = '';
  }

  try {
    const response = await fetch('/api/license/accept', { method: 'POST' });
    const data = await response.json();
    if (data.status === 'success') {
      closeLicenseModal();
      showNotification('success', '–°–ø–∞—Å–∏–±–æ!', '–õ–∏—Ü–µ–Ω–∑–∏–æ–Ω–Ω–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ.');
    } else {
      throw new Error(data.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞');
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ª–∏—Ü–µ–Ω–∑–∏–∏:', error);
    if (errorEl) {
      errorEl.textContent = '–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: ' + error.message;
      errorEl.style.display = 'block';
    }
    acceptBtn.disabled = false;
    acceptBtn.textContent = '–ü—Ä–∏–Ω—è—Ç—å';
  }
}

function closeLicenseModal() {
  const modal = document.getElementById('licenseModal');
  if (modal) {
    modal.style.display = 'none';
  }
}

// –ó–∞–∫—Ä—ã—Ç–∏–µ –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ –ª–∏—Ü–µ–Ω–∑–∏–∏ –ø–æ Escape
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') {
    const licenseModal = document.getElementById('licenseModal');
    if (licenseModal && licenseModal.style.display === 'block') {
      closeLicenseModal();
    }
  }
});

/* ========== Init ========== */
(async function init(){
  await loadBlocksConfig();
  loadTheme();
  loadValueHistory(); // –ó–∞–≥—Ä—É–∂–∞–µ–º –∏—Å—Ç–æ—Ä–∏—é –∑–Ω–∞—á–µ–Ω–∏–π –¥–ª—è –∞–≤—Ç–æ–¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è
  await loadCurrentProject();
  loadCameraPosition(); // –ó–∞–≥—Ä—É–∂–∞–µ–º –∞–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –ø–æ–∑–∏—Ü–∏—é –∫–∞–º–µ—Ä—ã
  await loadVersion(); // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤–µ—Ä—Å–∏—é
  // apply camera transform
  updateCamera();
  updateCounts();
  updateGlobalIgnoreButtonState();
  updateSafeModeButton();
  updateSaveStatusIndicator();
  updateProjectNameDisplay();
  
  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–∞–º–µ—Ä—É –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
  window.addEventListener('beforeunload', () => {
    if(cameraSaveTimeout){
      clearTimeout(cameraSaveTimeout);
    }
    const currentProject = localStorage.getItem('currentProject');
    if(currentProject){
      try {
        const cameraData = {
          x: camera.x,
          y: camera.y,
          scale: camera.scale
        };
        localStorage.setItem(`turtcd_camera_${currentProject}`, JSON.stringify(cameraData));
      } catch(e) {
        console.warn('Failed to save camera position on unload:', e);
      }
    }
  });
})();
</script>
</body>
  <!-- License badge -->
<div id="licenseBadge" class="license-badge">
  üõ° licensed by TurtCD <span id="versionBadge" style="opacity: 0.7;">v1.0.0</span>
</div>

  <!-- License modal -->
  <div id="licenseModal" style="display:none">
    <div class="modal-backdrop" onclick="if(event.target === this) closeLicenseModal()">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="licenseModalTitle">
        <h3 id="licenseModalTitle">–õ–∏—Ü–µ–Ω–∑–∏–æ–Ω–Ω–æ–µ —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ</h3>
        <div id="licenseError" class="license-hint" style="display:none; color: var(--danger);"></div>
        <div id="licenseScroll" class="license-scroll">
          <pre id="licenseText" class="license-text">–ó–∞–≥—Ä—É–∑–∫–∞ –ª–∏—Ü–µ–Ω–∑–∏–æ–Ω–Ω–æ–≥–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—è...</pre>
        </div>
        <div class="modal-actions">
          <button id="acceptLicenseBtn" class="btn" onclick="acceptLicenseAgreement()" disabled>–ü—Ä–∏–Ω—è—Ç—å</button>
        </div>
      </div>
    </div>
  </div>
<script src="/static/js/sounds.js"></script>
</html>